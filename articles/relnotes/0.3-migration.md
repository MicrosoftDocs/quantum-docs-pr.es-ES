---
title: Guía de revisión y migración del lenguaje QDK 0,3
description: Describe las nuevas características del Microsoft Quantum Development Kit 0,3 y cómo migrar los programas de preguntas y respuestas existentes.
author: beheim
uid: microsoft.quantum.relnotes.migration-0-3
ms.author: bettina.heim@microsoft.com
ms.date: 10/29/2018
ms.topic: article
ms.openlocfilehash: df86bf163a300c1ce55d3959bd40aea3d8b8a973
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907739"
---
# <a name="qdk-03-language-release-notes-and-migration-guide"></a>Notas de la versión de idioma y guía de migración de QDK 0,3

Nos complace presentar la actualización más reciente del kit de desarrollo de Quantum.  En esta página se proporciona información general sobre las nuevas características del lenguaje Q # y se describe cómo [migrar](#Migration) programas q # existentes a la nueva sintaxis.  Consulte la documentación completa para obtener una descripción completa [del lenguaje de](xref:microsoft.quantum.language.intro)preguntas y respuestas.


## <a name="whats-new"></a>What's New 

La actualización 0,3 incluye una serie de nuevas características de lenguaje y editor.

### <a name="overview-of-features"></a>Información general sobre las características

- Integración de herramientas de desarrollo mejorada para Visual Studio y Visual Studio Code, entre las que se incluyen:
    - Compilación en directo y comentarios sobre la escritura (*también conocido* como subrayado ondulado).
    - Información de desplazamiento, incluidos resúmenes de documentación y firmas de tipo.
    - Compatibilidad con ir a definición.
    - Navegación sencilla a las declaraciones de espacio de nombres, operación, función y tipo.
    - Mensajes de diagnóstico mejorados.
- Mejoras en el lenguaje
    - Inicializaciones de qubit y tupla únicas dentro del uso y préstamos
    - Desconstrucción de tuplas en todas las asignaciones
    - Iteración sobre matrices
    - Expresiones condicionales
    - Default: abreviatura de especialización para operaciones
    - Constructores de tipos generados automáticamente
    - Modificadores de expresión


## <a name="editor-features"></a>Características del editor

El kit de desarrollo de Quantum incluye ahora un servidor de lenguaje para preguntas y respuestas de cliente para Visual Studio y Visual Studio Code.
Esto habilita un nuevo conjunto de características de IntelliSense, además del subrayado ondulado de errores y advertencias para ver los comentarios en directo.
En concreto, ir a definición ahora es compatible y la información de desplazamiento se muestra con información de tipos, así como información sobre la documentación de comentarios. Además, la información de símbolos sobre espacios de nombres, operaciones, funciones y tipos definidos está disponible y permite navegar rápidamente a las declaraciones.    
Esta actualización mejora mucho los mensajes de diagnóstico en general, con una navegación sencilla e intervalos precisos para el diagnóstico, así como detalles adicionales en la información que se muestra al mantener el mouse encima. 

En esta versión 0,3, el servidor de lenguaje incluido en el kit de desarrollo de Quantum no admite varias áreas de trabajo.
Para trabajar con un proyecto en VS Code, abra la carpeta raíz que contiene el proyecto en sí y todos los proyectos a los que se hace referencia.
Para trabajar con una solución en Visual Studio, todos los proyectos contenidos en la solución deben estar en la misma carpeta que la solución o en una de sus subcarpetas.

## <a name="language-features"></a>Características del lenguaje

En cuanto a las características del lenguaje, esta actualización unifica el tratamiento de un intervalo de patrones de lenguaje.
Los constructores de tipos, como ejemplo, se generan para cada tipo definido por el usuario y se pueden aplicar parcialmente como cualquier otra función.
Otro ejemplo es la desconstrucción de tupla, que ahora es totalmente compatible dentro de todas las asignaciones. Esto incluye no solo Let-, mutable-y set-statements, sino también la variable de iteración en bucles for, así como las asignaciones de uso y de préstamos. Además, las desconstrucciones parciales se admiten recientemente con la actualización 0,3. los guiones bajos en las desconstrucciones indican partes del valor que se van a omitir. 

En el código siguiente se muestran algunas de las nuevas características:
```qsharp
    let tuples = [(1, 0), (0, 1)];
    mutable res = (0, 0, 0);

    // For-loops can iterate over arrays, and can destructure tuples.
    for ((i1, i2) in tuples) {

        // Mutable assignments can now destructure and ignore parts of tuples,
        // using the same syntax as let-bindings.
        mutable (r1, r2, _) = res;
        set (r1, r2) = (r1 ||| i1, r2 &&& i2);

        let (_, _, s) = res;
        // The new conditional operator can be used inside expressions, avoiding
        // the need for extraneous if-statements.
        set res = (r1, r2, r1 == r2 ? s | s + 1);
    }
```
La última instrucción set usa un nuevo operador ternario que se introduce con la actualización 0,3 para admitir expresiones condicionales.
Una expresión condicional es una expresión con el formato `condition ? caseTrue | caseFalse`.
Como se puede observar en el ejemplo anterior, ahora también se admite la iteración sobre matrices.

Las asignaciones dentro de `using` y `borrowing` son posibles para una sola qubits, matrices qubit y tuplas anidadas:
```qsharp
    using (qubit = Qubit()) {
        // qubit contains a single qubit
    }

    borrowing ((qubits, qubit) = (Qubit[3], Qubit())) {
        // qubits contains an array of three qubits, and qubit contains a single qubit
    }
```

Dos nuevas directivas de generación de especializaciones `invert` y `distribute` además de `auto` se introducen para aumentar el control sobre cómo se generan las especializaciones de funcción.
Una declaración explícita de la especialización `body` predeterminada dentro de las operaciones ya no es obligatoria.
De forma similar a las funciones, las instrucciones se pueden agregar directamente a la propia declaración de operación si no se declara ninguna otra especialización dentro de la operación.
Se incluye un script de migración en la versión de para ayudar a migrar el código existente y aprovechar las nuevas características del lenguaje (consulte la [sección sobre el script de migración](#MigrationScript)).

Se trata de un cambio importante en la forma en que se tratan los tipos definidos por el usuario con la actualización 0,3. Mientras que las versiones anteriores trataban los tipos definidos por el usuario como subtipos de su tipo subyacente, ya no es el caso en avanzar (vea también la [sección sobre cambios importantes](#BreakingChanges)).  
Como parte de este cambio, se introducen modificadores de expresión que se pueden aplicar a determinadas expresiones. Las expresiones "atómicas" a las que se pueden aplicar modificadores son los identificadores, las expresiones de elementos de matriz y las tuplas aridad-1.
Los modificadores se enlazan de forma más estrecha que cualquier otro combinador de expresión y, en particular, más estrecho que los `(` `)`. 
`Adjoint`, `Controlled`y un nuevo operador postfijo ' Unwrap ' `!` se tratan como modificadores de expresión. Al tratar `Adjoint` y `Controlled` como modificadores de expresión, se elimina la necesidad de paréntesis en muchos casos. Las expresiones siguientes, por ejemplo, son válidas para `Op`, una operación de unitario `opArr` una matriz de operaciones de unitario y `arg` un argumento adecuado: 
```qsharp
    Adjoint Op (arg);
    Controlled opArr[i] (arg);
```
El script de migración quitará la mayoría de los paréntesis innecesarios y sacará el máximo partido de las nuevas características. Sin embargo, tenga en cuenta que el script no interpreta el código y no tendrá en cuenta la interpretación diferente del funcnte `Controlled` en raras ocasiones (solo es pertinente en combinación con las aplicaciones parciales).

El nuevo modificador `!` convierte un tipo definido por el usuario en su tipo subyacente. Esta conversión se considera una conversión en versiones anteriores y se ejecutó automáticamente. Con la nueva interpretación de los tipos definidos por el usuario, esto ya no es así y la conversión debe hacerse explícita.    
En el ejemplo siguiente se muestra cómo usar el modificador New: 
```qsharp
    newtype Unitary = (Qubit => Unit: Adjoint, Controlled);

    operation Foo (unitaries : Unitary[], qubit : Qubit) : Unit {

        for (unitary in unitaries[1 .. Length(unitaries)-1]) {
            // Each element of unitaries is an instance of the user-defined
            // type Unitary, so unitary! unwraps each element to an operation
            // type that we can call.
            unitary! (qubit);
            // The unwrap operator can also be used as a part of functor
            // expressions and when indexing into arrays.
            Adjoint unitary! (qubit);
            Adjoint unitaries[0]! (qubit);
        }
    }
```
Como se puede observar en el ejemplo, `!` enlaza más que los modificadores de prefijo, como `Controlled` y `Adjoint`.

## <a name="BreakingChanges"></a>Cambios importantes 

La actualización 0,3 incluye un nuevo compilador y contiene algunos cambios importantes.
Para facilitar la actualización del código existente, el compilador también proporciona una opción de formato que compila código válido o no válido y emite código de Q # con formato basado en la compilación compilada.
La herramienta proporcionada procesará automáticamente todos los cambios de sintaxis. Sin embargo, es posible que sea necesario realizar cambios en la interpretación del código válido (cambios semánticos) de forma manual. 

Además de los cambios que se muestran a continuación, el patrón `__*__` donde * es cualquier secuencia de caracteres que no sean espacios en blanco se reserva para uso interno y no se puede usar como nombre de símbolo.  

## <a name="syntax-changes"></a>Cambios de sintaxis 

- A partir de la versión 0,3, los elementos de matriz ya no se separan con punto y coma, sino que se separan mediante comas.
- Por otro lado, se requiere un punto y coma después de una directiva de generación automática para las declaraciones de especialización.
- Las condiciones de las cláusulas IF-, Elif-y Until deben encapsularse entre paréntesis. 

Para todos los demás cambios de sintaxis, el compilador simplemente generará una advertencia si se usa la sintaxis anterior.     
Un ejemplo de este tipo de cambio es la tupla de símbolos en las especializaciones definidas por el usuario. Mientras que en las versiones anteriores, una declaración de especialización controlada o controlada por se especificaba un único argumento de símbolo, a partir de 0,3 se recomienda proporcionar una tupla de símbolos para todas las especializaciones con `...` que indique que el compilador debe migrar los símbolos de la declaración a la que se puede llamar si es necesario. 

## <a name="semantic-changes"></a>Cambios semánticos 

La interrupción más impactante de la versión 0,3 es la forma en que los tipos definidos por el usuario se integran en el sistema de tipos. En versiones anteriores, los tipos definidos por el usuario se consideraban un subtipo de su tipo subyacente. Con esta versión, esto ya no es así. Los tipos definidos por el usuario ahora se consideran su propio tipo distinto y no existe ninguna conversión automática entre un tipo definido por el usuario y su tipo subyacente. Todas las conversiones deben ser explícitas a través de un operador "Unwrap" `!`y se necesita una conversión en particular para tener acceso al contenido de un objeto de tipo definido por el usuario.  

Las modificaciones en el sistema de tipos también incluyen el comportamiento de la varianza de las matrices y el tratamiento de los objetos con parámetros de tipo. A partir de 0,3, las matrices mutables e inmutables son invariables. Además, los argumentos pasados a una invocable no pueden tener parámetros de tipo. En estos casos, los argumentos de tipo se deben pasar junto con el identificador.

Las versiones anteriores del compilador de Q # permitían que se proporcionase un valor de función en el que se esperaba un valor de operación, siempre que el valor de la función tuviera los tipos de entrada y salida correctos. Se trata de un comportamiento no deseado que no se especifica en la especificación del lenguaje Q #.
En el compilador 0,3, hemos quitado este comportamiento para que los valores de función ya no se consideren valores de operación.
Para minimizar la interrupción del código existente que basó este error, hemos agregado la función ToOperation en el espacio de nombres Microsoft. Quantum. Canon que convertirá explícitamente una función en una operación con los mismos tipos de entrada y salida.

En el ejemplo siguiente se muestra cómo utilizar la función `ToOperation` para cambiar una función `Square` a una operación `op`: 
```qsharp
namespace Microsoft.Quantum.Tests {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    function Square(x : Int) : Int {
        return x * x;
    }

    operation ApplyOp<'T, 'U>(op : ('T => 'U), input : 'T) : 'U {
        return op(input);
    }

    operation ToOperationTest() : Unit {
        let op = ToOperation(Square);
        AssertIntEqual(ApplyOp(op, 3), 9, "ToOperation failed with Square.");
    }
}
```

## <a name="requirements"></a>Requisitos 

La versión es compatible con la versión 15,8 de Visual Studio 2017 o posterior para Windows 10, y en Visual Studio Code versión 1.27.2 o posterior para Windows 10, macOS y Linux.

El kit de desarrollo de Quantum usa el SDK de .NET Core (2,0 o posterior).

## <a name="installation"></a>Instalación  

Siga las instrucciones de instalación que se indican [aquí](../install-guide/index.md).

Es posible que vea Advertencias ("se encontraron conflictos entre diferentes versiones de" System. Reflection. Metadata "que no se pudieron resolver") si la versión actual de SDK de .NET Core no está actualizada.  Sin embargo, si usa SDK de .NET Core (2,0 o posterior), estas advertencias se pueden omitir.


- La versión se proporciona junto con una serie de ejemplos diferentes que muestran cómo usar las dos características existentes del kit de desarrollo de Quantum y las nuevas características disponibles en esta versión. Estos ejemplos se pueden encontrar en GitHub en el repositorio [Microsoft/Quantum](https://github.com/Microsoft/Quantum) .


## <a name="Migration"></a>Migración de proyectos existentes a Q # 0,3 

Si ya tiene proyectos de preguntas y respuestas de la versión 0,2 del kit de desarrollo de Quantum, estos son los pasos para migrar esos proyectos a la versión más reciente. También proporcionamos un [script de migración](#MigrationScript) para ayudarle con el proceso.

> [!NOTE]
> Los proyectos deben actualizarse en orden. Si tiene una solución con varios proyectos, actualice cada proyecto en el orden en el que se hace referencia a ellos.


1. En una línea de comandos, ejecute `dotnet clean` para quitar todos los archivos binarios y los archivos intermedios existentes.
2. En un editor de texto, edite el archivo. csproj para cambiar la versión de todos los `PackageReference` "Microsoft. Quantum" a la versión 0.3.1811.2802-Preview, por ejemplo:
```xml
    <PackageReference Include="Microsoft.Quantum.Canon" Version="0.3.1811.2802" />
    <PackageReference Include="Microsoft.Quantum.Development.Kit" Version="0.3.1811.2802" />
```
4. Desde la línea de comandos, use la herramienta de formato integrada en el compilador de línea de comandos para abordar todos los cambios de sintaxis mediante la ejecución de este comando: `dotnet msbuild /t:qsharpformat`  
    - Los archivos se migrarán en contexto. Se copiará una copia de seguridad de todos los archivos originales en `obj\qsharp\.backup`
    - La herramienta de formato compilará el proyecto y omitirá todos los errores de compilación y generará código de Q # con formato basado en la compilación de compilación. 
       Cualquier símbolo no reconocido (por ejemplo, un nombre de variable sin definir) se reemplazará por un texto de marcador de posición que deba reemplazarse manualmente después de aplicar el formato. En este caso, el formato se realiza correctamente mientras se genera una advertencia para el archivo afectado.     
    - El formato y, en particular, cualquier espacio en blanco del archivo se cambiará en el código emitido. Se conservarán los comentarios.   
5. Después de ejecutarlo, es posible que tenga que solucionar manualmente los cambios semánticos en los casos en los que la interpretación semántica del código ha cambiado. IntelliSense devolverá todos estos errores en Visual Studio o Visual Studio Code.
    - Abra la carpeta raíz del proyecto o la solución que lo contiene en Visual Studio 2017 o Visual Studio Code.
    - Después de abrir un archivo .qs en el editor, verá el resultado de la extensión del lenguaje Q# en la ventana de salida.
    - Una vez que el proyecto se ha cargado correctamente (loq ue se indica en la ventana de salida), abra cada archivo y solucione manualmente todos los problemas que queden.


> [!NOTE]
> * En el caso de la versión 0,3, el servidor de lenguaje incluido en el kit de desarrollo de Quantum no admite varias áreas de trabajo.
> * Para trabajar con un proyecto en Visual Studio Code, abra la carpeta raíz que contiene el proyecto y todos los proyectos a los que se hace referencia.   
> * Para trabajar con una solución en Visual Studio, todos los proyectos contenidos en la solución deben estar en la misma carpeta que la solución o en una de sus subcarpetas.  
> * **No** se admiten las referencias entre los proyectos migrados a 0,3 y posteriores, y los proyectos que usan versiones anteriores de paquetes.




## <a name="MigrationScript"></a>Script de migración 

Para facilitar la migración del proyecto, se proporciona un script de PowerShell que se puede descargar [aquí](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1).
Este script ayuda a migrar proyectos de la versión 0,2 del kit de desarrollo de Quantum para usar la versión 0,3.

> [!NOTE]
> El script de migración requiere Windows PowerShell o PowerShell Core para ejecutarse.
> Windows PowerShell viene preinstalado con Windows 10.
> Descargue PowerShell Core para Windows, macOS o Linux en https://github.com/PowerShell/PowerShell.

El script ejecuta los cuatro pasos siguientes:

- El proyecto se compila con la versión anterior del kit de desarrollo de Quantum para asegurarse de que es probable que la migración se realice correctamente. Este paso se puede omitir mediante el parámetro `-Force` en el script.
- Se instalan las nuevas plantillas de proyecto.
- El proyecto se actualiza para usar la versión actual del kit de desarrollo de Quantum.
- La herramienta de formato que se proporciona con la versión 0,3 del kit de desarrollo de Quantum se aplica para abordar automáticamente la mayoría de los cambios importantes documentados anteriormente.

Una vez que se hayan completado estos cuatro pasos, es posible que haya algunos problemas de migración que se deben controlar manualmente.
El uso de la versión más reciente de las extensiones del kit de desarrollo de Quantum para Visual Studio 2017 y Visual Studio Code puede ayudar a encontrar estos problemas fácilmente.

La documentación del script puede obtenerse mediante la ejecución de uno de los siguientes comandos en la carpeta en la que se encuentra el script:

```powershell
Get-Help ./qdk-migrate.ps1
Get-Help -Online ./qdk-migrate.ps1
```

> [!NOTE]
> De forma predeterminada, Windows impide la ejecución de scripts como medida de seguridad.
> Para permitir que los scripts como `qdk-migrate.ps1` se ejecuten en Windows, es posible que deba cambiar la Directiva de ejecución.
> Para ello, ejecute el comando `Set-ExecutionPolicy`:
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope Process
> ```
> La Directiva de ejecución se revertirá al salir de PowerShell.
> Si desea guardar la Directiva de ejecución, use un valor diferente para `-Scope`:
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
> ```

