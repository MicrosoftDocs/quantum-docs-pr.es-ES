---
title: Introducción a las técnicas de desarrollo de Quantum | Microsoft Docs
description: Introducción a las técnicas de desarrollo de Quantum
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 702d23293a1c340ddd3d7032d0e05294345469b2
ms.sourcegitcommit: aa5e6f4a2deb4271a333d3f1b1eb69b5bb9a7bad
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 11/02/2019
ms.locfileid: "73442565"
---
# <a name="q-program-overview"></a><span data-ttu-id="0a7f1-103">Información general del programa de preguntas y respuestas</span><span class="sxs-lookup"><span data-stu-id="0a7f1-103">Q# program overview</span></span>

<span data-ttu-id="0a7f1-104">Q # es un lenguaje de programación escalable, de paradigma múltiple y específico del dominio para la informática Quantum.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-104">Q# is a scalable, multi-paradigm, domain-specific programming language for quantum computing.</span></span> <span data-ttu-id="0a7f1-105">Q # es un lenguaje de programación Quantum en el que se puede usar para describir cómo se ejecutan las instrucciones en máquinas Quantum.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-105">Q# is a quantum programming language in that it can be used to describe how instructions are executed on quantum machines.</span></span> <span data-ttu-id="0a7f1-106">Los equipos a los que se puede dirigir desde simuladores hasta hardware Quantum real.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-106">The machines that can be targeted range from simulators to actual quantum hardware.</span></span> <span data-ttu-id="0a7f1-107">Q # es escalable: se puede usar para escribir programas de demostración sencillos, como teletranspórtate, que se ejecutan en unos pocos qubits, pero también admite la escritura de programas grandes y sofisticados, como simulaciones de moléculas complejas que requerirán máquinas grandes con millones de qubits.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-107">Q# is scalable: it can be used to write simple demonstration programs like teleport that run on a few qubits, but also supports writing large, sophisticated programs such as simulations of complex molecules that will require large machines with millions of qubits.</span></span> <span data-ttu-id="0a7f1-108">Aunque las máquinas físicas de gran tamaño siguen en el futuro, Q # permite a un programador programar algoritmos Quantum complejos ahora.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-108">Even though large physical machines are still in the future, Q# allows a programmer to program complex quantum algorithms now.</span></span> <span data-ttu-id="0a7f1-109">Lo que es más, Q # admite varias tareas, como la depuración, la generación de perfiles, la estimación de recursos y ciertas simulaciones de propósito especial de una manera escalable.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-109">What is more, Q# supports various tasks such as debugging, profiling, resource estimation, and certain special-purpose simulations in a scalable way.</span></span> 

<span data-ttu-id="0a7f1-110">Desde una perspectiva técnica, un programa Quantum se puede considerar como un conjunto determinado de funciones clásicas que, cuando se llama, generan circuitos Quantum como efectos secundarios.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-110">From a technical perspective, a quantum program can be seen as a particular set of classical functions which, when called, generate quantum circuits as their side effects.</span></span> <span data-ttu-id="0a7f1-111">Una consecuencia importante de esa vista es que un programa escrito en Q # no modela directamente qubits, sino que describe cómo interactúa un equipo de control clásico con esos qubits.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-111">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="0a7f1-112">Por diseño, Q # no define los Estados Quantum u otras propiedades de la mecánica de Quantum directamente, sino que, en su lugar, indirectamente a través de la acción de las diversas subrutinas definidas en el lenguaje.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-112">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly, but rather does so indirectly through the action of the various subroutines defined in the language.</span></span>
<span data-ttu-id="0a7f1-113">Por ejemplo, tenga en cuenta el estado $ \ket{+} = \left (\ket{0} + \ket{1}\right)/\sqrt{2}$ descrito en la guía de [conceptos de procesamiento de Quantum](xref:microsoft.quantum.concepts.intro) .</span><span class="sxs-lookup"><span data-stu-id="0a7f1-113">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="0a7f1-114">Para preparar este estado en Q #, usamos los hechos que los qubits se inicializan en $ \ket{0}$ State y que $ \ket{+} = H\ket{0}$, donde $H $ es la transformación Hadamard:</span><span class="sxs-lookup"><span data-stu-id="0a7f1-114">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0〉.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0〉 = |+〉, as we wanted.
}
```
## <a name="q-tranformations-of-quantum-states"></a><span data-ttu-id="0a7f1-115">Q # transformaciones de Estados Quantum</span><span class="sxs-lookup"><span data-stu-id="0a7f1-115">Q# tranformations of quantum states</span></span>

<span data-ttu-id="0a7f1-116">Lo importante es que, al escribir el programa anterior, no nos referimos explícitamente al estado en Q #, sino que describimos cómo el programa *transformó* el estado.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-116">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="0a7f1-117">Por lo tanto, de forma similar a cómo un programa del sombreador de gráficos acumula una descripción de las transformaciones en cada vértice, un programa Quantum en Q # acumula las transformaciones a los Estados de Quantum.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-117">Thus, similar to how a graphics shader program accumulates a description of transformations to each vertex, a quantum program in Q# accumulates transformations to quantum states.</span></span>
<span data-ttu-id="0a7f1-118">Esto nos permite ser totalmente independientes sobre lo que un estado de Quantum *tiene* incluso en cada máquina de destino, que podría tener interpretaciones diferentes en función del equipo.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-118">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="0a7f1-119">Desde la perspectiva de un programa de preguntas y respuestas, un qubit es una referencia totalmente opaca a la estructura interna de un equipo de destino.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-119">From the perspective of a Q# program, a qubit is an entirely opaque reference to the internal structure of a target machine.</span></span>
<span data-ttu-id="0a7f1-120">Un programa de preguntas # no tiene capacidad para Introspect en el estado de un qubit, su representación en un equipo de destino o incluso si es el mismo qubit que cualquier otro qubit disponible para el programa.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-120">A Q# program has no ability to introspect into the state of a qubit, its representation on a target machine, or even whether it is the same qubit as any other qubit available to the program.</span></span>
<span data-ttu-id="0a7f1-121">En su lugar, un programa puede llamar a operaciones como `Measure` para obtener información de un qubit y llamar a operaciones como `X` y `H` para actuar en el estado de un qubit.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-121">Rather, a program can call operations such as `Measure` to learn information from a qubit, and call operations such as `X` and `H` to act on the state of a qubit.</span></span>
<span data-ttu-id="0a7f1-122">Estas operaciones no tienen ninguna definición intrínseca en el lenguaje y solo son específicas de la máquina de destino que se usa para ejecutar un programa de preguntas # determinado.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-122">These operations have no intrinsic definition within the language, and are made concrete only by the target machine used to run a particular Q# program.</span></span>
<span data-ttu-id="0a7f1-123">Un programa de preguntas # vuelve a combinar estas operaciones, tal y como se define en un equipo de destino para crear nuevas operaciones de nivel superior para expresar el cálculo de Quantum.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-123">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="0a7f1-124">De esta manera, Q # facilita la rápida expresión de los algoritmos Quantum subyacentes de Quantum y Quantum-clásico de la lógica, a la vez que también es general con respecto a la estructura de un equipo de destino o simulador.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-124">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum-classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="0a7f1-125">Operaciones y funciones de Q #</span><span class="sxs-lookup"><span data-stu-id="0a7f1-125">Q# operations and functions</span></span>

<span data-ttu-id="0a7f1-126">Concretamente, un programa de preguntas y respuestas se compone de una o más *operaciones*, una o varias *funciones*y tipos definidos por el usuario.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-126">Concretely, a Q# program is comprised of one or more *operations*, one or more *functions*, and user defined types.</span></span> <span data-ttu-id="0a7f1-127">Las operaciones se usan para describir las transformaciones del estado de una máquina Quantum y son el bloque de creación más básico de los programas de Q #.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-127">Operations are used to describe the transformations of the state of a quantum machine and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="0a7f1-128">Cada operación definida en Q # puede llamar a cualquier número de operaciones, incluidas las operaciones *intrínsecas* integradas implementadas por un equipo de destino.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-128">Each operation defined in Q# may then call any number of other operations, including the built-in *intrinsic* operations implemented by a target machine.</span></span>
<span data-ttu-id="0a7f1-129">Cuando se compila, cada operación se representa como un tipo de clase .NET que se puede proporcionar a los equipos de destino.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-129">When compiled, each operation is represented as a .NET class type that can be provided to target machines.</span></span>

<span data-ttu-id="0a7f1-130">A diferencia de las operaciones, las funciones se usan para describir el comportamiento puramente clásico y no tienen ningún efecto además de calcular los valores de salida clásico.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-130">In contrast to operations, functions are used to describe purely classical behavior and do not have any effects besides computing classical output values.</span></span> <span data-ttu-id="0a7f1-131">Q # es un lenguaje fuertemente tipado e incluye un conjunto de tipos primitivos integrados, así como compatibilidad con tipos definidos por el usuario.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-131">Q# is a strongly typed language and comes with a set of built-in primitive types as well as support for user defined types.</span></span> 

<span data-ttu-id="0a7f1-132">En el resto de esta guía, veremos cómo usar diferentes conceptos y construcciones del lenguaje para ayudarnos a definir programas Quantum complejos a través de los bloques de creación básicos de operaciones, funciones y tipos.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-132">Throughout the rest of this guide, we will see how to use different language concepts and constructs to help us define complex quantum programs through the basic building blocks of operations, functions, and types.</span></span> 

## <a name="structure-of-q-source-files"></a><span data-ttu-id="0a7f1-133">Estructura de los archivos de código fuente de Q #</span><span class="sxs-lookup"><span data-stu-id="0a7f1-133">Structure of Q# Source Files</span></span>

<span data-ttu-id="0a7f1-134">Como mínimo, un archivo de código fuente de Q # consta de una *declaración de espacio de nombres*, que especifica un espacio de nombres de .net que contendrá las definiciones en el archivo de código fuente.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-134">Minimally, a Q# source file consists of a *namespace declaration*, which specifies a .NET namespace which will contain the definitions in the source file.</span></span>
<span data-ttu-id="0a7f1-135">Las definiciones de otros archivos de código fuente y bibliotecas de preguntas y respuestas se pueden incluir con la instrucción `open`.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-135">Definitions from other Q# source files and libraries can be included using the `open` statement.</span></span>
<span data-ttu-id="0a7f1-136">Por ejemplo, la mayoría de las operaciones que definen las puertas fundamentales se definen en el espacio de nombres <xref:microsoft.quantum.intrinsic>.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-136">For instance, most of the operations defining fundamental gates are defined in the <xref:microsoft.quantum.intrinsic> namespace.</span></span>
<span data-ttu-id="0a7f1-137">Para que esté disponible en nuestro código, simplemente `open` ese espacio de nombres en la parte superior de cada archivo:</span><span class="sxs-lookup"><span data-stu-id="0a7f1-137">To make this available to our code, we simply `open` that namespace at the top of each file:</span></span>

```qsharp
namespace Example {
    open Microsoft.Quantum.Intrinsic;

    // ...
}
```

<span data-ttu-id="0a7f1-138">Dentro de un espacio de nombres, cada archivo de código fuente de Q # puede definir cualquier combinación de *operaciones*, *funciones*y *tipos definidos por el usuario*.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-138">Within a namespace, each Q# source file can define any combination of *operations*, *functions*, and *user-defined types*.</span></span>
<span data-ttu-id="0a7f1-139">En el resto de esta sección, describiremos cada uno de ellos y proporcionaremos ejemplos de cómo se pueden usar en la práctica para crear programas Quantum útiles.</span><span class="sxs-lookup"><span data-stu-id="0a7f1-139">In the rest of this section, we will describe each in turn and provide examples of how they can be used in practice to make useful quantum programs.</span></span>
