---
title: Qubit en Quantum Computing
description: Obtenga información sobre qubits, la unidad fundamental de información en la informática Quantum.
author: QuantumWriter
uid: microsoft.quantum.concepts.qubit
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 770b739d95f5c1512234f6f7d2ca4544f1d80e64
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907535"
---
# <a name="the-qubit"></a><span data-ttu-id="0df28-103">Qubit</span><span class="sxs-lookup"><span data-stu-id="0df28-103">The Qubit</span></span>

<span data-ttu-id="0df28-104">Del mismo modo que los bits son el objeto fundamental de la información en informática clásica, [*qubits*](https://en.wikipedia.org/wiki/Qubit) (bits de Quantum) son el objeto fundamental de la información en la informática Quantum.</span><span class="sxs-lookup"><span data-stu-id="0df28-104">Just as bits are the fundamental object of information in classical computing, [*qubits*](https://en.wikipedia.org/wiki/Qubit) (quantum bits) are the fundamental object of information in quantum computing.</span></span>  <span data-ttu-id="0df28-105">Para comprender esta correspondencia, echemos un vistazo al ejemplo más simple: un único qubit.</span><span class="sxs-lookup"><span data-stu-id="0df28-105">To understand this correspondence, let's look at the simplest example: a single qubit.</span></span>

## <a name="representing-a-qubit"></a><span data-ttu-id="0df28-106">Representar un qubit</span><span class="sxs-lookup"><span data-stu-id="0df28-106">Representing a Qubit</span></span>

<span data-ttu-id="0df28-107">Aunque un bit o un dígito binario, puede tener un valor de $0 $ o $1 $, un qubit puede tener un valor que sea cualquiera de estos o una superposición de Quantum de $0 $ y $1 $.</span><span class="sxs-lookup"><span data-stu-id="0df28-107">While a bit, or binary digit, can have value either $0$ or $1$, a qubit can have a value that is either of these or a quantum superposition of $0$ and $1$.</span></span>

<span data-ttu-id="0df28-108">El estado de un único qubit se puede describir mediante un vector de columna bidimensional de la norma unitaria, es decir, la magnitud cuadrada de sus entradas debe sumar $1 $.</span><span class="sxs-lookup"><span data-stu-id="0df28-108">The state of a single qubit can be described by a two-dimensional column vector of unit norm, that is, the magnitude squared of its entries must sum to $1$.</span></span> <span data-ttu-id="0df28-109">Este vector, denominado Vector de estado de Quantum, contiene toda la información necesaria para describir el sistema Quantum de un solo qubit como un solo bit contiene toda la información necesaria para describir el estado de una variable binaria.</span><span class="sxs-lookup"><span data-stu-id="0df28-109">This vector, called the quantum state vector, holds all the information needed to describe the one-qubit quantum system just as a single bit holds all of the information needed to describe the state of a binary variable.</span></span>

<span data-ttu-id="0df28-110">Cualquier vector de columna bidimensional de números reales o complejos con la norma $1 $ representa un posible estado de Quantum mantenido por un qubit.</span><span class="sxs-lookup"><span data-stu-id="0df28-110">Any two-dimensional column vector of real or complex numbers with norm $1$ represents a possible quantum state held by a qubit.</span></span> <span data-ttu-id="0df28-111">Por lo tanto, $ \begin{bmatrix} \alpha \\\\ \beta \end{bmatrix} $ representa un estado qubit si $ \alpha $ y $ \beta $ son números complejos que satisfacen $ | \alpha | ^ 2 + | \beta | ^ 2 = $1.</span><span class="sxs-lookup"><span data-stu-id="0df28-111">Thus $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ represents a qubit state if $\alpha$ and $\beta$ are complex numbers satisfying $|\alpha|^2 + |\beta|^2 = 1$.</span></span> <span data-ttu-id="0df28-112">Algunos ejemplos de vectores de estado de Quantum válidos que representan qubits incluyen</span><span class="sxs-lookup"><span data-stu-id="0df28-112">Some examples of valid quantum state vectors representing qubits include</span></span>

<span data-ttu-id="0df28-113">$ $ \begin{bmatrix} 1 \\\\ 0 \end{bmatrix}, \begin{bmatrix} 0 \\\\ 1 \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\ \frac{1}{\sqrt{2}} \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\ \frac{-1}{\sqrt{2}} \end{bmatrix}, \text{y} \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\ \frac{i}{\sqrt{2}} \end{bmatrix}. $ $</span><span class="sxs-lookup"><span data-stu-id="0df28-113">$$\begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \begin{bmatrix} 0 \\\\  1 \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{1}{\sqrt{2}} \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{-1}{\sqrt{2}} \end{bmatrix}, \text{ and }\begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{i}{\sqrt{2}} \end{bmatrix}.$$</span></span>

<span data-ttu-id="0df28-114">Los vectores de estado Quantum $ \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} $ y $ \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} $ toman un rol especial.</span><span class="sxs-lookup"><span data-stu-id="0df28-114">The quantum state vectors $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ and $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$ take a special role.</span></span> <span data-ttu-id="0df28-115">Estos dos vectores forman una base para el espacio vectorial que describe el estado de qubit.</span><span class="sxs-lookup"><span data-stu-id="0df28-115">These two vectors form a basis for the vector space that describes the qubit's state.</span></span> <span data-ttu-id="0df28-116">Esto significa que cualquier vector de estado de Quantum se puede escribir como una suma de estos vectores de base.</span><span class="sxs-lookup"><span data-stu-id="0df28-116">This means that any quantum state vector can be written as a sum of these basis vectors.</span></span> <span data-ttu-id="0df28-117">En concreto, se puede escribir el vector $ \begin{bmatrix} x \\\\ y \end{bmatrix} $ como $x \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} + y \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} $.</span><span class="sxs-lookup"><span data-stu-id="0df28-117">Specifically, the vector $\begin{bmatrix} x \\\\  y \end{bmatrix}$ can be written as $x \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} + y \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="0df28-118">Si bien cualquier rotación de estos vectores serviría como una base perfectamente válida para el qubit, optamos por aplicar el privilegio a este, llamando al *cálculo*.</span><span class="sxs-lookup"><span data-stu-id="0df28-118">While any rotation of these vectors would serve as a perfectly valid basis for the qubit, we choose to privilege this one, by calling it the *computational basis*.</span></span>

<span data-ttu-id="0df28-119">Tomamos estos dos Estados de Quantum para que se correspondan con los dos Estados de un bit clásico, es decir, $0 $ y $1 $.</span><span class="sxs-lookup"><span data-stu-id="0df28-119">We take these two quantum states to correspond to the two states of a classical bit, namely $0$ and $1$.</span></span> <span data-ttu-id="0df28-120">La Convención estándar es elegir</span><span class="sxs-lookup"><span data-stu-id="0df28-120">The standard convention is to choose</span></span>

<span data-ttu-id="0df28-121">$ $0 \ equiv \begin{bmatrix} 1 \\\\ 0 \end{bmatrix}, \qquad 1 \equiv \begin{bmatrix} 0 \\\\ 1 \end{bmatrix}, $ $</span><span class="sxs-lookup"><span data-stu-id="0df28-121">$$0\equiv \begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \qquad 1 \equiv \begin{bmatrix} 0 \\\\  1 \end{bmatrix},$$</span></span>

<span data-ttu-id="0df28-122">Aunque la opción opuesta se podría tomar igualmente bien.</span><span class="sxs-lookup"><span data-stu-id="0df28-122">although the opposite choice could equally well be taken.</span></span> <span data-ttu-id="0df28-123">Por lo tanto, fuera del número infinito de vectores de estado de Quantum de un solo qubit posible, solo dos se corresponden con los Estados de los bits clásico; el resto de Estados de Quantum no lo hacen.</span><span class="sxs-lookup"><span data-stu-id="0df28-123">Thus, out of the infinite number of possible single-qubit quantum state vectors, only two correspond to states of classical bits; all other quantum states do not.</span></span>

## <a name="measuring-a-qubit"></a><span data-ttu-id="0df28-124">Medición de un qubit</span><span class="sxs-lookup"><span data-stu-id="0df28-124">Measuring a Qubit</span></span>

<span data-ttu-id="0df28-125">Ahora que sabemos cómo representar un qubit, podemos obtener algunos Intuition por lo que estos Estados representan tratando el concepto de [*medición*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics).</span><span class="sxs-lookup"><span data-stu-id="0df28-125">Now that we know how to represent a qubit, we can gain some intuition for what these states represent by discussing the concept of [*measurement*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics).</span></span> <span data-ttu-id="0df28-126">Una medida corresponde a la idea informal de "mirar" en un qubit, que contrae inmediatamente el estado de cuanto a uno de los dos Estados clásicos $ \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} $ o $ \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} $.</span><span class="sxs-lookup"><span data-stu-id="0df28-126">A measurement corresponds to the informal idea of “looking” at a qubit, which immediately collapses the quantum state to one of the two classical states  $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ or  $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="0df28-127">Cuando se mide un qubit proporcionado por el vector de estado Quantum $ \begin{bmatrix} \alpha \\\\ \beta \end{bmatrix} $, se obtiene el resultado $0 $ con la probabilidad $ | \alpha | ^ 2 $ y el resultado $1 $ con probabilidad $ | \beta | ^ 2 $.</span><span class="sxs-lookup"><span data-stu-id="0df28-127">When a qubit given by the quantum state vector  $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ is measured, we obtain the outcome $0$ with probability $|\alpha|^2$ and the outcome $1$  with probability $|\beta|^2$.</span></span> <span data-ttu-id="0df28-128">En el resultado $0 $, el nuevo estado del qubit es $ \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} $; en el resultado $1 $ su estado es $ \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} $.</span><span class="sxs-lookup"><span data-stu-id="0df28-128">On outcome $0$, the qubit's new state is $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$; on outcome $1$ its state is $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="0df28-129">Tenga en cuenta que estas probabilidades suman hasta $1 $ debido a la condición de normalización $ | \alpha | ^ 2 + | \beta | ^ 2 = $1.</span><span class="sxs-lookup"><span data-stu-id="0df28-129">Note that these probabilities sum up to $1$ because of the normalization condition $|\alpha|^2 + |\beta|^2 = 1$.</span></span>

<span data-ttu-id="0df28-130">Las propiedades de medición también significan que el signo global del vector de estado de Quantum es irrelevante.</span><span class="sxs-lookup"><span data-stu-id="0df28-130">The properties of measurement also mean that the overall sign of the quantum state vector is irrelevant.</span></span> <span data-ttu-id="0df28-131">Negar un vector es equivalente a $ \alpha \rightarrow-\alpha $ y $ \beta \rightarrow-\beta $.</span><span class="sxs-lookup"><span data-stu-id="0df28-131">Negating a vector is equivalent to $\alpha \rightarrow -\alpha$ and $\beta \rightarrow -\beta$.</span></span> <span data-ttu-id="0df28-132">Dado que la probabilidad de medir $0 $ y $1 $ depende de la magnitud cuadrada de los términos, la inserción de tales signos no cambia las probabilidades.</span><span class="sxs-lookup"><span data-stu-id="0df28-132">Because the probability of measuring $0$ and $1$ depends on the magnitude squared of the terms, inserting such signs does not change the probabilities whatsoever.</span></span> <span data-ttu-id="0df28-133">Estas fases se denominan normalmente [\`\`*fases globales*' '](https://en.wikipedia.org/wiki/Phase_factor) y, por lo general, pueden tener el formato $e ^ {i \phi} $ en lugar de $ \pm $1.</span><span class="sxs-lookup"><span data-stu-id="0df28-133">Such phases are commonly called [\`\`*global phases*''](https://en.wikipedia.org/wiki/Phase_factor) and more generally can be of the form $e^{i \phi}$ rather than just $\pm 1$.</span></span>

<span data-ttu-id="0df28-134">Una propiedad importante final de la medición es que no necesariamente daña todos los vectores de estado de Quantum.</span><span class="sxs-lookup"><span data-stu-id="0df28-134">A final important property of measurement is that it does not necessarily damage all quantum state vectors.</span></span> <span data-ttu-id="0df28-135">Si comenzamos con una qubit en el estado $ \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} $, que corresponde al estado clásico $0 $, la medición de este estado siempre producirá el resultado $0 $ y dejará el estado del cuanto sin cambios.</span><span class="sxs-lookup"><span data-stu-id="0df28-135">If we start with a qubit in the state $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$, which corresponds to the classical state $0$, measuring this state will always yield the outcome $0$ and leave the quantum state unchanged.</span></span> <span data-ttu-id="0df28-136">En este sentido, si solo tenemos bits clásico (es decir, qubits que son $ \begin{bmatrix}1 \\\\ 0 \end{bmatrix} $ o $ \begin{bmatrix}0 \\\\ 1 \end{bmatrix} $), la medición no daña el sistema.</span><span class="sxs-lookup"><span data-stu-id="0df28-136">In this sense, if we only have classical bits (i.e., qubits that are either $\begin{bmatrix}1 \\\\  0 \end{bmatrix}$ or $\begin{bmatrix}0 \\\\  1 \end{bmatrix}$) then measurement does not damage the system.</span></span> <span data-ttu-id="0df28-137">Esto significa que se pueden replicar los datos clásico y manipularlos en un equipo Quantum del mismo modo que en un equipo clásico.</span><span class="sxs-lookup"><span data-stu-id="0df28-137">This means that we can replicate classical data and manipulate it on a quantum computer just as one could do on a classical computer.</span></span> <span data-ttu-id="0df28-138">La capacidad, sin embargo, para almacenar información en ambos Estados a la vez es lo que eleva la informática Quantum más allá de lo que es posible de forma Robs y más equipos Quantum de la capacidad de copiar datos Quantum de forma indiscriminada, vea también [el teorema sin clonación](https://en.wikipedia.org/wiki/No-cloning_theorem).</span><span class="sxs-lookup"><span data-stu-id="0df28-138">The ability, however, to store information in both states at once is what elevates quantum computing beyond what is possible classically and further robs quantum computers of the ability to copy quantum data indiscriminately, see also [the no-cloning theorem](https://en.wikipedia.org/wiki/No-cloning_theorem).</span></span>

## <a name="visualizing-qubits-and-transformations-using-the-bloch-sphere"></a><span data-ttu-id="0df28-139">Visualización de qubits y transformaciones mediante la esfera Bloch</span><span class="sxs-lookup"><span data-stu-id="0df28-139">Visualizing Qubits and Transformations using the Bloch Sphere</span></span>

<span data-ttu-id="0df28-140">Qubits también se puede mostrar en $3 $ D mediante la representación de la [*esfera Bloch*](https://en.wikipedia.org/wiki/Bloch_sphere) .</span><span class="sxs-lookup"><span data-stu-id="0df28-140">Qubits may also be pictured in $3$D using the [*Bloch sphere*](https://en.wikipedia.org/wiki/Bloch_sphere) representation.</span></span>  <span data-ttu-id="0df28-141">La esfera Bloch proporciona una manera de describir un estado de Quantum de un solo qubit (que es un vector complejo bidimensional) como un vector de valor real de tres dimensiones.</span><span class="sxs-lookup"><span data-stu-id="0df28-141">The Bloch sphere gives a way of describing a single-qubit quantum state (which is a two-dimensional complex vector) as a three-dimensional real-valued vector.</span></span>  <span data-ttu-id="0df28-142">Esto es importante porque nos permite visualizar los Estados de qubit único y, por lo tanto, desarrollar un razonamiento que pueda ser muy valioso en la comprensión de los Estados de varios qubit (por desgracia, la representación de la esfera Bloch se interrumpe).</span><span class="sxs-lookup"><span data-stu-id="0df28-142">This is important because it allows us to visualize single-qubit states and thereby develop reasoning that can be invaluable in understanding multi-qubit states (where sadly the Bloch sphere representation breaks down).</span></span>  <span data-ttu-id="0df28-143">La esfera Bloch se puede visualizar de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="0df28-143">The Bloch sphere can be visualized as follows:</span></span>

<!--- ![](.\media\bloch.svg){ width=50% } --->
<span data-ttu-id="0df28-144">![esfera Bloch](~/media/concepts_bloch.png)</span><span class="sxs-lookup"><span data-stu-id="0df28-144">![Bloch sphere](~/media/concepts_bloch.png)</span></span>

<span data-ttu-id="0df28-145">Las flechas de este diagrama muestran la dirección en la que apunta el vector de estado de Quantum y cada transformación de la flecha puede considerarse como una rotación sobre uno de los ejes cardinales.</span><span class="sxs-lookup"><span data-stu-id="0df28-145">The arrows in this diagram show the direction in which the quantum state vector is pointing and each transformation of the arrow can be thought of as a rotation about one of the cardinal axes.</span></span>
<span data-ttu-id="0df28-146">Aunque pensar en un cálculo de Quantum como una secuencia de giros es un Intuition eficaz, es difícil usar este Intuition para diseñar y describir algoritmos.</span><span class="sxs-lookup"><span data-stu-id="0df28-146">While thinking about a quantum computation as a sequence of rotations is a powerful intuition, it is challenging to use this intuition to design and describe algorithms.</span></span> <span data-ttu-id="0df28-147">Q # alivia este problema proporcionando un lenguaje para describir tales giros.</span><span class="sxs-lookup"><span data-stu-id="0df28-147">Q# alleviates this issue by providing a language for describing such rotations.</span></span>

## <a name="single-qubit-operations"></a><span data-ttu-id="0df28-148">Operaciones de qubit único</span><span class="sxs-lookup"><span data-stu-id="0df28-148">Single-Qubit Operations</span></span>

<span data-ttu-id="0df28-149">Los equipos Quantum procesan los datos aplicando un conjunto universal de las puertas de Quantum que pueden emular cualquier rotación del vector de estado de Quantum.</span><span class="sxs-lookup"><span data-stu-id="0df28-149">Quantum computers process data by applying a universal set of quantum gates that can emulate any rotation of the quantum state vector.</span></span>
<span data-ttu-id="0df28-150">Esta noción de universalidad es similar a la noción de universalidad para la informática tradicional (es decir, clásica) en la que se considera que un conjunto de puertas es universal si se pueden realizar todas las transformaciones de los bits de entrada mediante un circuito de longitud finita.</span><span class="sxs-lookup"><span data-stu-id="0df28-150">This notion of universality is akin to the notion of universality for traditional (i.e., classical) computing where a gate set is considered to be universal if every transformation of the input bits can be performed using a finite length circuit.</span></span>
<span data-ttu-id="0df28-151">En el cálculo de Quantum Computing, las transformaciones válidas que se pueden realizar en un qubit son las transformaciones y la medida de la unitario.</span><span class="sxs-lookup"><span data-stu-id="0df28-151">In quantum computing, the valid transformations that we are allowed to perform on a qubit are unitary transformations and measurement.</span></span>
<span data-ttu-id="0df28-152">La *operación* de "contiguo" o la transposición de conjugada compleja es de importancia fundamental para la informática Quantum porque es necesario invertir transformaciones Quantum.</span><span class="sxs-lookup"><span data-stu-id="0df28-152">The *adjoint operation* or the complex conjugate transpose is of crucial importance to quantum computing because it is needed to invert quantum transformations.</span></span>
<span data-ttu-id="0df28-153">Q # refleja esto al proporcionar métodos para compilar automáticamente las secuencias de la puerta en su método contiguo, lo que evita que el programador tenga que controlar los contiguos de código en muchos casos.</span><span class="sxs-lookup"><span data-stu-id="0df28-153">Q# reflects this by providing methods to automatically compile gate sequences to their adjoint, which saves the programmer from having to hand code adjoints in many cases.</span></span> <span data-ttu-id="0df28-154">A continuación se muestra un ejemplo de esto:</span><span class="sxs-lookup"><span data-stu-id="0df28-154">An example of this is shown below:</span></span>

```qsharp
operation PrepareSuperposition(qubit : Qubit) : Unit
is Adj { // Auto-generate the adjoint of the operation
    H(qubit);
}
```

<span data-ttu-id="0df28-155">Aunque este es un ejemplo trivial (dado que la operación de <xref:microsoft.quantum.intrinsic.h> es autocontiguo), puede ver cómo esto resulta muy útil para operaciones qubit más complicadas.</span><span class="sxs-lookup"><span data-stu-id="0df28-155">Although this is a trivial example (as the <xref:microsoft.quantum.intrinsic.h> operation is self-adjoint), you can see how this becomes invaluable for more complicated qubit operations.</span></span>
<span data-ttu-id="0df28-156">Para obtener más información, vea [operaciones y funciones](xref:microsoft.quantum.techniques.opsandfunctions).</span><span class="sxs-lookup"><span data-stu-id="0df28-156">For more information, see [Operations and Functions](xref:microsoft.quantum.techniques.opsandfunctions).</span></span>

<span data-ttu-id="0df28-157">Solo hay cuatro funciones que se asignan de un bit a un bit en un equipo clásico.</span><span class="sxs-lookup"><span data-stu-id="0df28-157">There are only four functions that map one bit to one bit on a classical computer.</span></span> <span data-ttu-id="0df28-158">Por el contrario, hay un número infinito de transformaciones unitarios en un único qubit en un equipo Quantum.</span><span class="sxs-lookup"><span data-stu-id="0df28-158">In contrast, there are an infinite number of unitary transformations on a single qubit on a quantum computer.</span></span> <span data-ttu-id="0df28-159">Por lo tanto, ningún conjunto finito de operaciones de cuantos primitivos, denominados [*puertas*](https://en.wikipedia.org/wiki/Quantum_logic_gate), puede replicar exactamente el conjunto infinito de transformaciones unitarios que se permiten en Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="0df28-159">Therefore, no finite set of primitive quantum operations, called [*gates*](https://en.wikipedia.org/wiki/Quantum_logic_gate), can exactly replicate the infinite set of unitary transformations allowed in quantum computing.</span></span> <span data-ttu-id="0df28-160">Esto significa que, a diferencia de la informática clásica, no es posible que un equipo Quantum implemente todos los programas Quantum posibles con un número finito de puertas.</span><span class="sxs-lookup"><span data-stu-id="0df28-160">This means, unlike classical computing, it is impossible for a quantum computer to implement every possible quantum program exactly using a finite number of gates.</span></span> <span data-ttu-id="0df28-161">Por lo tanto, los equipos Quantum no pueden ser universales en el mismo sentido que los equipos clásico.</span><span class="sxs-lookup"><span data-stu-id="0df28-161">Thus quantum computers cannot be universal in the same sense of classical computers.</span></span> <span data-ttu-id="0df28-162">Como resultado, cuando decimos que un conjunto de puertas es *universal* para la informática Quantum, realmente nos referimos a algo ligeramente más débil de lo que nos referimos a la informática clásica.</span><span class="sxs-lookup"><span data-stu-id="0df28-162">As a result, when we say that a set of gates is *universal* for quantum computing we actually mean something slightly weaker than we mean with classical computing.</span></span>
<span data-ttu-id="0df28-163">En cuanto a la universalidad, es necesario que un equipo Quantum solo *aproxime* cada matriz de unitarios dentro de un error finito mediante una secuencia de barrera de longitud finita.</span><span class="sxs-lookup"><span data-stu-id="0df28-163">For universality, we require that a quantum computer only *approximate* every unitary matrix within a finite error using a finite length gate sequence.</span></span>
<span data-ttu-id="0df28-164">En otras palabras, un conjunto de puertas es un conjunto de puerta universal si cualquier transformación de cuantificación se puede escribir aproximadamente como un producto de las puertas de este conjunto.</span><span class="sxs-lookup"><span data-stu-id="0df28-164">In other words, a set of gates is a universal gate set if any unitary transformation can be approximately written as a product of gates from this set.</span></span> <span data-ttu-id="0df28-165">Es necesario que, para cualquier error indicado, existan las puertas $G _{1}, G_{2}, \ldots, G_N $ del conjunto de puertas</span><span class="sxs-lookup"><span data-stu-id="0df28-165">We require that for any prescribed error bound, there exist gates $G_{1}, G_{2},\ldots, G_N$ from the gate set such that</span></span>

<span data-ttu-id="0df28-166">$ $ G_N G_ {N-1} \cdots G_2 G_1 \approx U. $ $</span><span class="sxs-lookup"><span data-stu-id="0df28-166">$$ G_N G_{N-1} \cdots G_2 G_1 \approx U. $$</span></span>

<span data-ttu-id="0df28-167">Tenga en cuenta que, dado que la Convención para la multiplicación de matrices es multiplicar de derecha a izquierda la primera operación de la puerta en esta secuencia, $G _N $, es realmente la última que se aplica al vector de estado de Quantum.</span><span class="sxs-lookup"><span data-stu-id="0df28-167">Note that because the convention for matrix multiplication is to multiply from right to left the first gate operation in this sequence, $G_N$, is actually the last one applied to the quantum state vector.</span></span> <span data-ttu-id="0df28-168">Lo que es más formal, suponemos que este conjunto de puertas es universal si para cada tolerancia de error $ \epsilon > 0 $ existe $G _ 1, \ldots, G_N $ de modo que la distancia entre $G _N \ldots G_1 $ y $U $ sea como máximo $ \epsilon $.</span><span class="sxs-lookup"><span data-stu-id="0df28-168">More formally, we say that such a gate set is universal if for every error tolerance $\epsilon>0$ there exists $G_1,\ldots, G_N$ such that  the distance between $G_N\ldots G_1$ and $U$ is at most $\epsilon$.</span></span> <span data-ttu-id="0df28-169">Idealmente, el valor de $N $ necesario para alcanzar esta distancia de $ \epsilon $ debe escalarse de poliles con un valor de $1/\ épsilon $.</span><span class="sxs-lookup"><span data-stu-id="0df28-169">Ideally the value of $N$ needed to reach this distance of $\epsilon$ should scale poly-logarithmically with $1/\epsilon$.</span></span>

<span data-ttu-id="0df28-170">¿Qué aspecto tiene este conjunto de puerta universal en la práctica?</span><span class="sxs-lookup"><span data-stu-id="0df28-170">What does such a universal gate set look like in practice?</span></span>  <span data-ttu-id="0df28-171">La forma más sencilla de este conjunto de puerta universal para las puertas de qubit solo consta de dos puertas: la puerta Hadamard $H $ y la llamada $T $-Gate (también conocida como la puerta $ \ PI/8 $):</span><span class="sxs-lookup"><span data-stu-id="0df28-171">The simplest such universal gate set for single-qubit gates consists of only two gates: the Hadamard gate $H$ and the so-called $T$-gate (also known as the $\pi/8$ gate):</span></span>

<span data-ttu-id="0df28-172">$ $ H = \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\\\ 1 &-1 \end{bmatrix}, \qquad T = \begin{bmatrix} 1 & 0 \\\\ 0 & e ^ {i \ PI/4} \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="0df28-172">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix},\qquad T=\begin{bmatrix} 1 & 0 \\\\  0 & e^{i\pi/4} \end{bmatrix}.</span></span>
$$

<span data-ttu-id="0df28-173">Sin embargo, por razones prácticas relacionadas con la corrección de errores de Quantum puede ser más conveniente considerar un conjunto de puertas mayor, es decir, uno que se puede generar mediante $H $ y $T $.</span><span class="sxs-lookup"><span data-stu-id="0df28-173">However, for practical reasons related to quantum error correction it can be more convenient to consider a larger gate set, namely one that can be generated using $H$ and $T$.</span></span>
<span data-ttu-id="0df28-174">Podemos clasificar las puertas de Quantum en dos categorías: Clifford Gates y $T $-Gate.</span><span class="sxs-lookup"><span data-stu-id="0df28-174">We can classify the quantum gates into two categories: Clifford gates and the $T$-gate.</span></span>
<span data-ttu-id="0df28-175">Esta subdivisión es útil porque, en muchos esquemas de corrección de errores de Quantum, la llamada a las puertas de Clifford es fácil de implementar, es decir, requieren muy pocos recursos en cuanto a operaciones y Qubits para implementar el error de forma tolerante, mientras que las puertas de Clifford no son es bastante costoso cuando se requiere tolerancia a errores.</span><span class="sxs-lookup"><span data-stu-id="0df28-175">This subdivision is useful because in many quantum error correction schemes the so-called Clifford gates are easy to implement, that is they require very few resources in terms of operations and qubits to implement fault tolerantly, whereas non-Clifford gates are quite costly when requiring fault tolerance.</span></span> <span data-ttu-id="0df28-176">El conjunto estándar de puertas de Clifford de un solo qubit, [incluido de forma predeterminada en Q #](xref:microsoft.quantum.libraries.standard.prelude), incluye</span><span class="sxs-lookup"><span data-stu-id="0df28-176">The standard set of single-qubit Clifford gates, [included by default in Q#](xref:microsoft.quantum.libraries.standard.prelude), include</span></span>

<span data-ttu-id="0df28-177">$ $ H = \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\\\ 1 &-1 \end{bmatrix}, \qquad S = \begin{bmatrix} 1 & 0 \\\\ 0 & i \end{bmatrix} = T ^ 2, \qquad X = \begin{bmatrix} 0 & 1 \\\\ 1 & 0 \end{bmatrix} = HT ^ 4H, $ $</span><span class="sxs-lookup"><span data-stu-id="0df28-177">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix} ,\qquad S =\begin{bmatrix} 1 & 0 \\\\  0 & i \end{bmatrix}= T^2,\qquad X=\begin{bmatrix} 0 &1 \\\\  1& 0 \end{bmatrix}= HT^4H, $$</span></span>

<span data-ttu-id="0df28-178">$ $ Y = \begin{bmatrix} 0 &-i \\\\ i & 0 \end{bmatrix} = T ^ 2HT ^ 4 HT ^ 6, \qquad Z = \begin{bmatrix}1 & 0\\\\ 0 &-1 \end{bmatrix} = T ^ 4.</span><span class="sxs-lookup"><span data-stu-id="0df28-178">$$ Y = \begin{bmatrix} 0 & -i \\\\  i & 0 \end{bmatrix}=T^2HT^4  HT^6, \qquad Z=\begin{bmatrix}1&0\\\\ 0&-1 \end{bmatrix}=T^4.</span></span>
$$

<span data-ttu-id="0df28-179">Aquí las operaciones $X $, $Y $ y $Z $ se usan especialmente con frecuencia y se denominan [*operadores Pauli*](https://en.wikipedia.org/wiki/Pauli_matrices) después de Creator Wolfgang Pauli.</span><span class="sxs-lookup"><span data-stu-id="0df28-179">Here the operations $X$, $Y$ and $Z$ are used especially frequently and are named [*Pauli operators*](https://en.wikipedia.org/wiki/Pauli_matrices) after their creator Wolfgang Pauli.</span></span>
<span data-ttu-id="0df28-180">Junto con la puerta que no es de Clifford (la $T $-Gate), estas operaciones se pueden componer para aproximar cualquier transformación de unitario en una sola qubit.</span><span class="sxs-lookup"><span data-stu-id="0df28-180">Together with the non-Clifford gate (the $T$-gate), these operations can be composed to approximate any unitary transformation on a single qubit.</span></span>

<span data-ttu-id="0df28-181">Para obtener más información sobre estas operaciones, sus representaciones de esfera Bloch y las implementaciones de Q #, consulte [funciones y funciones intrínsecas](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span><span class="sxs-lookup"><span data-stu-id="0df28-181">For more information on these operations, their Bloch sphere representations and Q# implementations, see [Intrinsic Operations and Functions](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span></span>

<span data-ttu-id="0df28-182">Como ejemplo de cómo se pueden crear transformaciones de unitarios a partir de estos primitivos, las tres transformaciones que se ilustran en las esferas Bloch anteriores corresponden a la secuencia de la puerta \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} \mapsto HZH \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} = \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} $.</span><span class="sxs-lookup"><span data-stu-id="0df28-182">As an example of how unitary transformations can be built from these primitives, the three transformations pictured in the Bloch spheres above correspond to the gate sequence $\begin{bmatrix} 1 \\\\  0 \end{bmatrix} \mapsto HZH \begin{bmatrix} 1 \\\\  0 \end{bmatrix} = \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span>

<span data-ttu-id="0df28-183">Aunque el anterior constituye la más popular de las puertas primitivas para describir operaciones en el nivel lógico de la pila (piense en el nivel lógico como el nivel del algoritmo Quantum), a menudo es conveniente tener en cuenta las operaciones menos básicas en el algoritmo. nivel, por ejemplo operaciones más próximas a un nivel de descripción de función.</span><span class="sxs-lookup"><span data-stu-id="0df28-183">While the previous constitute the most popular primitive gates for describing operations on the logical level of the stack (think of the logical level as the level of the quantum algorithm), it is often convenient to consider less basic operations at the algorithmic level, for example operations closer to a function description level.</span></span> <span data-ttu-id="0df28-184">Afortunadamente, Q # también tiene métodos disponibles para implementar unitaries de nivel superior que, a su vez, permiten la implementación de algoritmos de alto nivel sin descomponer explícitamente todo en Clifford y $T $-Gates.</span><span class="sxs-lookup"><span data-stu-id="0df28-184">Fortunately, Q# also has methods available for implementing higher-level unitaries, which in turn allow high-level algorithms to be implemented without explicitly decomposing everything down to Clifford and $T$-gates.</span></span>

<span data-ttu-id="0df28-185">La más sencilla, tal primitiva, es el único qubit.</span><span class="sxs-lookup"><span data-stu-id="0df28-185">The simplest such primitive is the single qubit-rotation.</span></span> <span data-ttu-id="0df28-186">Normalmente se consideran tres rotaciones de un solo qubit: $R _x $, $R _y $ y $R _z $.</span><span class="sxs-lookup"><span data-stu-id="0df28-186">Three single-qubit rotations are typically considered: $R_x$, $R_y$ and $R_z$.</span></span> <span data-ttu-id="0df28-187">Para visualizar la acción de la rotación $R _x (\theta) $, por ejemplo, Imagine que señala el control de posición correcto a lo largo de la dirección de la $x $ AXIS de la esfera Bloch y gira el vector con la mano a través de un ángulo de $ \ Theta/2 $ radianes.</span><span class="sxs-lookup"><span data-stu-id="0df28-187">To visualize the action of the rotation $R_x(\theta)$, for example, imagine pointing your right thumb along the direction of the $x$-axis of the Bloch sphere and rotating the vector with your hand through an angle of $\theta/2$ radians.</span></span> <span data-ttu-id="0df28-188">Este factor confuso de $2 $ se produce por el hecho de que los vectores ortogonales tienen una diferencia de $180 ^ \circ $ cuando se representan en la esfera Bloch, pero en realidad son $90 ^ \circ $ degrees separados geométricamente.</span><span class="sxs-lookup"><span data-stu-id="0df28-188">This confusing factor of $2$ arises from the fact that orthogonal vectors are $180^\circ$ apart when plotted on the Bloch sphere, yet are actually $90^\circ$ degrees apart geometrically.</span></span> <span data-ttu-id="0df28-189">Las matrices unitarios correspondientes son:</span><span class="sxs-lookup"><span data-stu-id="0df28-189">The corresponding unitary matrices are:</span></span>

<span data-ttu-id="0df28-190">\begin{align *} & R_z (\theta) = e ^ {-I\theta z/2} = \begin{bmatrix} e ^ {-i \ Theta/2} & 0\\\\ 0 & e ^ {i \ Theta/2} \end{bmatrix}, \\\\ & R_x (\theta) = e ^ {-I\theta x/2} = HR_z (\theta) H = \begin{bmatrix} \cos (\ Theta/2) &-i\sin (\ Theta/2)\\\\-i\sin (\ Theta/2) & \cos (\ Theta/2) \end{bmatrix}, \\\\ & R_y (\theta) = e ^ {-I\theta y/2} = SHR_z (\theta) HS ^ \dagger = \begin{bmatrix} \cos (\ Theta/2) &-\sin (\ Theta/2)\\\\ \sin (\ Theta/2) & \cos (\ Theta/2) \end{bmatrix}. \end{align*}</span><span class="sxs-lookup"><span data-stu-id="0df28-190">\begin{align *} &R_z(\theta) = e^{-i\theta Z/2} = \begin{bmatrix} e^{-i\theta/2} & 0\\\\  0& e^{i\theta/2} \end{bmatrix}, \\\\ &R_x(\theta) = e^{-i\theta X/2} = HR_z(\theta)H = \begin{bmatrix} \cos(\theta/2) & -i\sin(\theta/2)\\\\  -i\sin(\theta/2) & \cos(\theta/2) \end{bmatrix}, \\\\ &R_y(\theta) = e^{-i\theta Y/2} = SHR_z(\theta)HS^\dagger = \begin{bmatrix} \cos(\theta/2) & -\sin(\theta/2)\\\\  \sin(\theta/2) & \cos(\theta/2) \end{bmatrix}. \end{align*}</span></span>

<span data-ttu-id="0df28-191">Del mismo modo que se pueden combinar tres rotaciones de forma conjunta para realizar una rotación arbitraria en tres dimensiones, se puede observar en la representación de la esfera Bloch que cualquier matriz de unitarios puede escribirse como una secuencia de tres giros también.</span><span class="sxs-lookup"><span data-stu-id="0df28-191">Just as any three rotations can be combined together to perform an arbitrary rotation in three dimensions, it can be seen from the Bloch sphere representation that any unitary matrix can be written as a sequence of three rotations as well.</span></span> <span data-ttu-id="0df28-192">En concreto, para cada matriz de unitario $U $ existe $ \alpha, \beta, \gamma, \delta $, que $U = e ^ {i\alpha} R_x (\beta) R_z (\gamma) R_x (\delta) $.</span><span class="sxs-lookup"><span data-stu-id="0df28-192">Specifically, for every unitary matrix $U$ there exists $\alpha,\beta,\gamma,\delta$ such that $U= e^{i\alpha} R_x(\beta)R_z(\gamma)R_x(\delta)$.</span></span> <span data-ttu-id="0df28-193">Por lo tanto $R _z (\theta) $ y $H $ también forman un conjunto de puertas universales, aunque no es un conjunto discreto porque $ \theta $ puede tomar cualquier valor.</span><span class="sxs-lookup"><span data-stu-id="0df28-193">Thus $R_z(\theta)$ and $H$ also form a universal gate set although it is not a discrete set because $\theta$ can take any value.</span></span> <span data-ttu-id="0df28-194">Por esta razón, y debido a las aplicaciones en la simulación Quantum, estas puertas continuas son cruciales para el cálculo de Quantum, especialmente en el nivel de diseño del algoritmo Quantum.</span><span class="sxs-lookup"><span data-stu-id="0df28-194">For this reason, and due to applications in quantum simulation, such continuous gates are crucial for quantum computation, especially at the quantum algorithm design level.</span></span> <span data-ttu-id="0df28-195">Para lograr una implementación de hardware tolerante a errores, se compilarán en última instancia en secuencias de puerta discretas que se aproximan a estos giros.</span><span class="sxs-lookup"><span data-stu-id="0df28-195">To achieve fault-tolerant hardware implementation, they will ultimately be compiled into discrete gate sequences that closely approximate these rotations.</span></span>
