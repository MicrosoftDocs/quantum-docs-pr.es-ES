---
title: Diagnósticos en las Q# bibliotecas estándar
description: Obtenga información sobre las funciones de diagnóstico y las operaciones de las Q# bibliotecas estándar que se usan para detectar errores o errores en los programas Quantum.
author: cgranade
uid: microsoft.quantum.libraries.diagnostics
ms.author: chgranad
ms.topic: article
no-loc:
- Q#
- $$v
ms.openlocfilehash: 11ce1bc86db0c5aa0f81ba7d0f2d6ec3463b178c
ms.sourcegitcommit: 9b0d1ffc8752334bd6145457a826505cc31fa27a
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/21/2020
ms.locfileid: "90835577"
---
# <a name="diagnostics"></a><span data-ttu-id="914e2-103">Diagnóstico</span><span class="sxs-lookup"><span data-stu-id="914e2-103">Diagnostics</span></span> #

<span data-ttu-id="914e2-104">Al igual que con el desarrollo clásico, es importante poder diagnosticar errores y errores en los programas Quantum.</span><span class="sxs-lookup"><span data-stu-id="914e2-104">As with classical development, it is important to be able to diagnose mistakes and errors in quantum programs.</span></span>
<span data-ttu-id="914e2-105">Las Q# bibliotecas estándar proporcionan diversas formas de garantizar la corrección de los programas Quantum, como se detalla en <xref:microsoft.quantum.guide.testingdebugging> .</span><span class="sxs-lookup"><span data-stu-id="914e2-105">The Q# standard libraries provide a variety of different ways to ensure the correctness of quantum programs, as detailed in <xref:microsoft.quantum.guide.testingdebugging>.</span></span>
<span data-ttu-id="914e2-106">En gran medida, esta compatibilidad se proporciona en forma de funciones y operaciones que indican a la máquina de destino que proporcione información de diagnóstico adicional al programa o desarrollador del host, o bien que aplique la corrección de condiciones e invariables expresadas por la función o la llamada de la operación.</span><span class="sxs-lookup"><span data-stu-id="914e2-106">Largely speaking, this support comes in the form of functions and operations that either instruct the target machine to provide additional diagnostic information to the host program or developer, or enforce the correctness of conditions and invariants expressed by the function or operation call.</span></span>

## <a name="machine-diagnostics"></a><span data-ttu-id="914e2-107">Diagnóstico de la máquina</span><span class="sxs-lookup"><span data-stu-id="914e2-107">Machine Diagnostics</span></span> ##

<span data-ttu-id="914e2-108">Los diagnósticos sobre valores clásico se pueden obtener mediante la <xref:microsoft.quantum.intrinsic.message> función para registrar un mensaje de forma dependiente de la máquina.</span><span class="sxs-lookup"><span data-stu-id="914e2-108">Diagnostics about classical values can be obtained by using the <xref:microsoft.quantum.intrinsic.message> function to log a message in a machine-dependent way.</span></span>
<span data-ttu-id="914e2-109">De forma predeterminada, esto escribe la cadena en la consola.</span><span class="sxs-lookup"><span data-stu-id="914e2-109">By default, this writes the string to the console.</span></span>
<span data-ttu-id="914e2-110">Cuando se usa junto con cadenas interpoladas, facilita la <xref:microsoft.quantum.intrinsic.message> notificación de información de diagnóstico sobre valores de uso clásico:</span><span class="sxs-lookup"><span data-stu-id="914e2-110">Used together with interpolated strings, <xref:microsoft.quantum.intrinsic.message> makes it easy to report diagnostic information about classical values:</span></span>

```Q#
let angle = Microsoft.Quantum.Math.PI() * 2.0 / 3.0;
Message($"About to rotate by an angle of {angle}...");
```

> [!NOTE]
> <span data-ttu-id="914e2-111">`Message` tiene `(String -> Unit)` una firma, de nuevo que no se puede observar la emisión de un mensaje de registro de depuración desde Q# .</span><span class="sxs-lookup"><span data-stu-id="914e2-111">`Message` has signature `(String -> Unit)`, again representing that emitting a debug log message cannot be observed from within Q#.</span></span>

<span data-ttu-id="914e2-112">Las <xref:microsoft.quantum.diagnostics.dumpmachine> <xref:microsoft.quantum.diagnostics.dumpregister> invocaciones de y indican a los equipos de destino que proporcionen información de diagnóstico sobre todos los qubits asignados actualmente o sobre un registro específico de qubits, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="914e2-112">The <xref:microsoft.quantum.diagnostics.dumpmachine> and <xref:microsoft.quantum.diagnostics.dumpregister> callables instruct target machines to provide diagnostic information about all currently allocated qubits or about a specific register of qubits, respectively.</span></span>
<span data-ttu-id="914e2-113">Cada máquina de destino varía en función de la información de diagnóstico que se proporciona en respuesta a una instrucción de volcado.</span><span class="sxs-lookup"><span data-stu-id="914e2-113">Each target machine varies in what diagnostic information is provided in response to a dump instruction.</span></span>
<span data-ttu-id="914e2-114">El equipo de destino del [simulador de estado completo](xref:microsoft.quantum.machines.full-state-simulator) , por ejemplo, proporciona al programa host el vector de estado que usa internamente para representar un registro de qubits.</span><span class="sxs-lookup"><span data-stu-id="914e2-114">The [full state simulator](xref:microsoft.quantum.machines.full-state-simulator) target machine, for instance, provides the host program with the state vector that it uses internally to represent a register of qubits.</span></span>
<span data-ttu-id="914e2-115">Por comparación, el equipo de destino del [simulador Toffoli](xref:microsoft.quantum.machines.toffoli-simulator) proporciona un solo bit clásico para cada qubit.</span><span class="sxs-lookup"><span data-stu-id="914e2-115">By comparison, the [Toffoli simulator](xref:microsoft.quantum.machines.toffoli-simulator) target machine provides a single classical bit for each qubit.</span></span>

 <span data-ttu-id="914e2-116">Para obtener más información sobre la salida [del simulador de estado completo](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` , eche un vistazo a la sección de funciones de volcado de nuestro [artículo sobre pruebas y depuración](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span><span class="sxs-lookup"><span data-stu-id="914e2-116">To learn more about the [full state simulator's](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` output, take a look at the dump functions section of our [testing and debugging article](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span></span>


## <a name="facts-and-assertions"></a><span data-ttu-id="914e2-117">Hechos y aserciones</span><span class="sxs-lookup"><span data-stu-id="914e2-117">Facts and Assertions</span></span> ##

<span data-ttu-id="914e2-118">Como se explicó en [pruebas y depuración](xref:microsoft.quantum.guide.testingdebugging), una función u operación con firma `Unit -> Unit` o `Unit => Unit` , respectivamente, se puede marcar como una *prueba unitaria*.</span><span class="sxs-lookup"><span data-stu-id="914e2-118">As discussed in [Testing and Debugging](xref:microsoft.quantum.guide.testingdebugging), a function or operation with signature `Unit -> Unit` or `Unit => Unit`, respectively, can be marked as a *unit test*.</span></span>
<span data-ttu-id="914e2-119">Generalmente, cada prueba unitaria consta de un pequeño programa Quantum, junto con una o más condiciones que comprueban la corrección de ese programa.</span><span class="sxs-lookup"><span data-stu-id="914e2-119">Each unit test generally consists of a small quantum program, along with one or more conditions that check the correctness of that program.</span></span>
<span data-ttu-id="914e2-120">Estas condiciones pueden presentarse en forma de _hechos_, que comprueban los valores de sus entradas, o _aserciones_, que comprueban los Estados de uno o más qubits pasados como entrada.</span><span class="sxs-lookup"><span data-stu-id="914e2-120">These conditions can come in the form of either _facts_, which check the values of their inputs, or _assertions_, which check the states of one or more qubits passed as input.</span></span>

<span data-ttu-id="914e2-121">Por ejemplo, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` representa el hecho matemático que $1 + 1 = $2, mientras `AssertQubit(One, qubit)` que representa la condición que la medición `qubit` devolverá `One` con certeza.</span><span class="sxs-lookup"><span data-stu-id="914e2-121">For example, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` represents the mathematical fact that $1 + 1 = 2$, while `AssertQubit(One, qubit)` represents the condition that measuring `qubit` will return a `One` with certainty.</span></span>
<span data-ttu-id="914e2-122">En el primer caso, podemos comprobar la exactitud de la condición dados solo sus valores, mientras que en este último, debemos conocer algo sobre el estado de la qubit para evaluar la aserción.</span><span class="sxs-lookup"><span data-stu-id="914e2-122">In the former case, we can check the correctness of the condition given only its values, while in the latter, we must know something about the state of the qubit in order to evaluate the assertion.</span></span>

<span data-ttu-id="914e2-123">Las Q# bibliotecas estándar proporcionan varias funciones diferentes para representar hechos, entre las que se incluyen:</span><span class="sxs-lookup"><span data-stu-id="914e2-123">The Q# standard libraries provide several different functions for representing facts, including:</span></span>

- <xref:microsoft.quantum.diagnostics.fact>
- <xref:microsoft.quantum.diagnostics.equalitywithintolerancefact>
- <xref:microsoft.quantum.diagnostics.nearequalityfactc>
- <xref:microsoft.quantum.diagnostics.equalityfacti>


### <a name="testing-qubit-states"></a><span data-ttu-id="914e2-124">Prueba de los Estados de qubit</span><span class="sxs-lookup"><span data-stu-id="914e2-124">Testing Qubit States</span></span> ###

<span data-ttu-id="914e2-125">En la práctica, las aserciones se basan en el hecho de que las simulaciones clásicas de la mecánica de Quantum no necesitan obedecer los [teoremas de no clonación](https://arxiv.org/abs/quant-ph/9607018), por lo que podemos hacer medidas y aserciones no físicas al usar un simulador para nuestro equipo de destino.</span><span class="sxs-lookup"><span data-stu-id="914e2-125">In practice, assertions rely on the fact that classical simulations of quantum mechanics need not obey the [no-cloning theorem](https://arxiv.org/abs/quant-ph/9607018), such that we can make unphysical measurements and assertions when using a simulator for our target machine.</span></span>
<span data-ttu-id="914e2-126">Por lo tanto, podemos probar operaciones individuales en un simulador clásico antes de la implementación en hardware.</span><span class="sxs-lookup"><span data-stu-id="914e2-126">Thus, we can test individual operations on a classical simulator before deploying on hardware.</span></span>
<span data-ttu-id="914e2-127">En los equipos de destino que no permiten la evaluación de aserciones, las llamadas a <xref:microsoft.quantum.diagnostics.assertmeasurement> se pueden omitir sin ningún riesgo.</span><span class="sxs-lookup"><span data-stu-id="914e2-127">On target machines which do not allow evaluation of assertions, calls to <xref:microsoft.quantum.diagnostics.assertmeasurement> can be safely ignored.</span></span>

<span data-ttu-id="914e2-128">En general, la <xref:microsoft.quantum.diagnostics.assertmeasurement> operación afirma que la medición del qubits determinado en la base de Pauli determinada siempre tendrá el resultado especificado.</span><span class="sxs-lookup"><span data-stu-id="914e2-128">More generally, the <xref:microsoft.quantum.diagnostics.assertmeasurement> operation asserts that measuring the given qubits in the given Pauli basis will always have the given result.</span></span>
<span data-ttu-id="914e2-129">Si se produce un error en la aserción, la ejecución finaliza mediante una llamada `fail` a con el mensaje especificado.</span><span class="sxs-lookup"><span data-stu-id="914e2-129">If the assertion fails, the run ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="914e2-130">De forma predeterminada, esta operación no está implementada. los simuladores que pueden admitirlo deben proporcionar una implementación que realice la comprobación en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="914e2-130">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="914e2-131">`AssertMeasurement` tiene una firma `((Pauli[], Qubit[], Result, String) -> ())` .</span><span class="sxs-lookup"><span data-stu-id="914e2-131">`AssertMeasurement` has signature `((Pauli[], Qubit[], Result, String) -> ())`.</span></span>
<span data-ttu-id="914e2-132">Dado que `AssertMeasurement` es una función con una tupla vacía como su tipo de salida, ningún efecto de haber llamado a `AssertMeasurement` se observa dentro de un Q# programa.</span><span class="sxs-lookup"><span data-stu-id="914e2-132">Since `AssertMeasurement` is a function with an empty tuple as its output type, no effects from having called `AssertMeasurement` are observable within a Q# program.</span></span>

<span data-ttu-id="914e2-133">La <xref:microsoft.quantum.diagnostics.assertmeasurementprobability> función de operación valida que la medición del qubits determinado en la base de Pauli determinada tendrá el resultado dado con la probabilidad determinada, dentro de cierta tolerancia.</span><span class="sxs-lookup"><span data-stu-id="914e2-133">The <xref:microsoft.quantum.diagnostics.assertmeasurementprobability> operation function asserts that measuring the given qubits in the given Pauli basis will have the given result with the given probability, within some tolerance.</span></span>
<span data-ttu-id="914e2-134">La tolerancia es aditiva (por ejemplo, `abs(expected-actual) < tol` ).</span><span class="sxs-lookup"><span data-stu-id="914e2-134">Tolerance is additive (for example, `abs(expected-actual) < tol`).</span></span>
<span data-ttu-id="914e2-135">Si se produce un error en la aserción, la ejecución finaliza mediante una llamada `fail` a con el mensaje especificado.</span><span class="sxs-lookup"><span data-stu-id="914e2-135">If the assertion fails, the run ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="914e2-136">De forma predeterminada, esta operación no está implementada. los simuladores que pueden admitirlo deben proporcionar una implementación que realice la comprobación en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="914e2-136">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="914e2-137">`AssertMeasurementProbability` tiene una firma `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)` .</span><span class="sxs-lookup"><span data-stu-id="914e2-137">`AssertMeasurementProbability` has signature `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)`.</span></span> <span data-ttu-id="914e2-138">El primero de `Double` los parámetros proporciona la probabilidad deseada del resultado y la tolerancia.</span><span class="sxs-lookup"><span data-stu-id="914e2-138">The first of `Double` parameters gives the desired probability of the result, and the second one the tolerance.</span></span>

<span data-ttu-id="914e2-139">Podemos hacer más que imponer una sola medida, con lo que la información clásica que usa un simulador para representar el estado interno de un qubit es receptiva a la copia, de modo que no es necesario realizar realmente una medida para probar nuestra aserción.</span><span class="sxs-lookup"><span data-stu-id="914e2-139">We can do more than assert a single measurement, using that the classical information used by a simulator to represent the internal state of a qubit is amenable to copying, such that we do not need to actually perform a measurement to test our assertion.</span></span>
<span data-ttu-id="914e2-140">En concreto, esto nos permite pensar en las mediciones *incompatibles* que serían imposibles en el hardware real.</span><span class="sxs-lookup"><span data-stu-id="914e2-140">In particular, this allows us to reason about *incompatible* measurements that would be impossible on actual hardware.</span></span>

<span data-ttu-id="914e2-141">Supongamos que `P : Qubit => Unit` es una operación diseñada para preparar el estado $ \ket{\psi} $ cuando su entrada está en el estado $ \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="914e2-141">Suppose that `P : Qubit => Unit` is an operation intended to prepare the state $\ket{\psi}$ when its input is in the state $\ket{0}$.</span></span>
<span data-ttu-id="914e2-142">Permita que $ \ket{\psi '} $ sea el estado real preparado por `P` .</span><span class="sxs-lookup"><span data-stu-id="914e2-142">Let $\ket{\psi'}$ be the actual state prepared by `P`.</span></span>
<span data-ttu-id="914e2-143">Después, $ \ket{\psi} = \ket{\psi '} $ si y solo si la medición de $ \ket{\psi '} $ en el eje descrito por $ \ket{\psi} $ siempre devuelve `Zero` .</span><span class="sxs-lookup"><span data-stu-id="914e2-143">Then, $\ket{\psi} = \ket{\psi'}$ if and only if measuring $\ket{\psi'}$ in the axis described by $\ket{\psi}$ always returns `Zero`.</span></span>
<span data-ttu-id="914e2-144">Es decir, \begin{align} \ket{\psi} = \ket{\psi '} \text{if y Only if} \braket{\psi | \psi '} = 1.</span><span class="sxs-lookup"><span data-stu-id="914e2-144">That is, \begin{align} \ket{\psi} = \ket{\psi'} \text{ if and only if } \braket{\psi | \psi'} = 1.</span></span>
<span data-ttu-id="914e2-145">\end{align} usar las operaciones primitivas definidas en el preparado, podemos realizar directamente una medida que devuelve `Zero` si $ \ket{\psi} $ es un eigenstate de uno de los operadores de Pauli.</span><span class="sxs-lookup"><span data-stu-id="914e2-145">\end{align} Using the primitive operations defined in the prelude, we can directly perform a measurement that returns `Zero` if $\ket{\psi}$ is an eigenstate of one of the Pauli operators.</span></span>


<span data-ttu-id="914e2-146">La operación <xref:microsoft.quantum.diagnostics.assertqubit> proporciona una forma abreviada especialmente útil para hacerlo en caso de que desee probar la aserción $ \ket{\psi} = \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="914e2-146">The operation <xref:microsoft.quantum.diagnostics.assertqubit> provides a particularly useful shorthand to do so in the case that we wish to test the assertion $\ket{\psi} = \ket{0}$.</span></span>
<span data-ttu-id="914e2-147">Esto es común, por ejemplo, cuando se ha descalculado para devolver ancilla qubits a $ \ket {0} $ antes de liberarlos.</span><span class="sxs-lookup"><span data-stu-id="914e2-147">This is common, for instance, when we have uncomputed to return ancilla qubits to $\ket{0}$ before releasing them.</span></span>
<span data-ttu-id="914e2-148">La aserción de $ \ket {0} $ también es útil cuando se desea afirmar que dos preparación `P` y operaciones de estado `Q` preparan el mismo estado, y cuando `Q` es compatible con `Adjoint` .</span><span class="sxs-lookup"><span data-stu-id="914e2-148">Asserting against $\ket{0}$ is also useful when we wish to assert that two state preparation `P` and `Q` operations both prepare the same state, and when `Q` supports `Adjoint`.</span></span>
<span data-ttu-id="914e2-149">En particular,</span><span class="sxs-lookup"><span data-stu-id="914e2-149">In particular,</span></span>

```qsharp
using (register = Qubit()) {
    P(register);
    Adjoint Q(register);

    AssertQubit(Zero, register);
}
```

<span data-ttu-id="914e2-150">En general, sin embargo, es posible que no tengamos acceso a las aserciones sobre los Estados que no coinciden con eigenstates de los operadores Pauli.</span><span class="sxs-lookup"><span data-stu-id="914e2-150">More generally, however, we may not have access to assertions about states that do not coincide with eigenstates of Pauli operators.</span></span>
<span data-ttu-id="914e2-151">Por ejemplo, $ \ket{\psi} = (\ket {0} + e ^ {i \pi/8} \ket {1} )/\sqrt {2} $ no es un eigenstate de ningún operador Pauli, de modo que no se puede usar <xref:microsoft.quantum.diagnostics.assertmeasurementprobability> para determinar de forma única que un estado $ \ket{\psi '} $ es igual a $ \ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="914e2-151">For example, $\ket{\psi} = (\ket{0} + e^{i \pi / 8} \ket{1}) / \sqrt{2}$ is not an eigenstate of any Pauli operator, such that we cannot use <xref:microsoft.quantum.diagnostics.assertmeasurementprobability> to uniquely determine that a state $\ket{\psi'}$ is equal to $\ket{\psi}$.</span></span>
<span data-ttu-id="914e2-152">En su lugar, debemos descomponer la aserción $ \ket{\psi '} = \ket{\psi} $ en suposiciones que se puedan probar directamente con las primitivas admitidas por nuestro simulador.</span><span class="sxs-lookup"><span data-stu-id="914e2-152">Instead, we must decompose the assertion $\ket{\psi'} = \ket{\psi}$ into assumptions that can be directly tested using  the primitives supported by our simulator.</span></span>
<span data-ttu-id="914e2-153">Para ello, deje que $ \ket{\psi} = \alpha \ket {0} + \beta \ket {1} $ para los números complejos $ \alpha = a \_ r + a \_ i $ y $ \beta $.</span><span class="sxs-lookup"><span data-stu-id="914e2-153">To do so, let $\ket{\psi} = \alpha \ket{0} + \beta \ket{1}$ for complex numbers $\alpha = a\_r + a\_i i$ and $\beta$.</span></span>
<span data-ttu-id="914e2-154">Tenga en cuenta que esta expresión requiere cuatro números reales $ a \{ \_ r, a \_ i, b \_ r, b \_ i \} $ para especificar, ya que cada número complejo se puede expresar como la suma de una parte real e imaginaria.</span><span class="sxs-lookup"><span data-stu-id="914e2-154">Note that this expression requires four real numbers $\{a\_r, a\_i, b\_r, b\_i\}$ to specify, as each complex number can be expressed as the sum of a real and imaginary part.</span></span>
<span data-ttu-id="914e2-155">Sin embargo, debido a la fase global, podemos elegir $a \_ = $0, de modo que solo necesitamos tres números reales para especificar de forma única un estado de qubit único.</span><span class="sxs-lookup"><span data-stu-id="914e2-155">Due to the global phase, however, we can choose $a\_i = 0$, such that we only need three real numbers to uniquely specify a single-qubit state.</span></span>

<span data-ttu-id="914e2-156">Por lo tanto, es necesario especificar tres aserciones que son independientes entre sí con el fin de validar el estado que se espera.</span><span class="sxs-lookup"><span data-stu-id="914e2-156">Thus, we need to specify three assertions which are independent of each other in order to assert the state that we expect.</span></span>
<span data-ttu-id="914e2-157">Para ello, se busca la probabilidad de observar `Zero` para cada medida de Pauli dada $ \alpha $ y $ \beta $, y se validan cada una de ellas de forma independiente.</span><span class="sxs-lookup"><span data-stu-id="914e2-157">We do so by finding the probability of observing `Zero` for each Pauli measurement given $\alpha$ and $\beta$, and asserting each independently.</span></span>
<span data-ttu-id="914e2-158">Permita $x $, $y $ y $z $ sean `Result` valores para Pauli $X $, $Y $ y $Z $ Measurements respectivamente.</span><span class="sxs-lookup"><span data-stu-id="914e2-158">Let $x$, $y$, and $z$ be `Result` values for Pauli $X$, $Y$, and $Z$ measurements respectively.</span></span>
<span data-ttu-id="914e2-159">A continuación, con la función de probabilidad para las mediciones de Quantum, \begin{align} \Pr (x = \texttt{Zero} | \alpha, \beta) & = \frac12 + a \_ r b \_ r + a \_ i b \_ i \\ \\ \Pr (y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a \_ r b \_ i-a \_ i b \_ r \\ \\ \Pr (z = \texttt{Zero} | \alpha, \beta) & = \frac12\left (1 + a \_ r ^ 2 + a \_ i ^ 2 + b \_ r ^ 2 + b \_ i ^ 2 \right).</span><span class="sxs-lookup"><span data-stu-id="914e2-159">Then, using the likelihood function for quantum measurements, \begin{align} \Pr(x = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_r + a\_i b\_i \\\\ \Pr(y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_i - a\_i b\_r \\\\ \Pr(z = \texttt{Zero} | \alpha, \beta) & = \frac12\left( 1 + a\_r^2 + a\_i^2 + b\_r^2 + b\_i^2 \right).</span></span>
<span data-ttu-id="914e2-160">\end{align}</span><span class="sxs-lookup"><span data-stu-id="914e2-160">\end{align}</span></span>

<span data-ttu-id="914e2-161">La <xref:microsoft.quantum.diagnostics.assertqubitisinstatewithintolerance> operación implementa estas aserciones dadas las representaciones de $ \alpha $ y $ \beta $ como valores de tipo <xref:microsoft.quantum.math.complex> .</span><span class="sxs-lookup"><span data-stu-id="914e2-161">The <xref:microsoft.quantum.diagnostics.assertqubitisinstatewithintolerance> operation implements these assertions given representations of $\alpha$ and $\beta$ as values of type <xref:microsoft.quantum.math.complex>.</span></span>
<span data-ttu-id="914e2-162">Esto resulta útil cuando el estado esperado se puede calcular de forma matemática.</span><span class="sxs-lookup"><span data-stu-id="914e2-162">This is helpful when the expected state can be computed mathematically.</span></span>

### <a name="asserting-equality-of-quantum-operations"></a><span data-ttu-id="914e2-163">Validar la igualdad de las operaciones Quantum</span><span class="sxs-lookup"><span data-stu-id="914e2-163">Asserting Equality of Quantum Operations</span></span> ###

<span data-ttu-id="914e2-164">Hasta ahora, nos hemos preocupado en las operaciones de prueba que están destinadas a preparar estados concretos.</span><span class="sxs-lookup"><span data-stu-id="914e2-164">Thus far, we have been concerned with testing operations which are intended to prepare particular states.</span></span>
<span data-ttu-id="914e2-165">Sin embargo, a menudo estamos interesados en cómo actúa una operación para entradas arbitrarias en lugar de en una sola entrada fija.</span><span class="sxs-lookup"><span data-stu-id="914e2-165">Often, however, we are interested in how an operation acts for arbitrary inputs rather than for a single fixed input.</span></span>
<span data-ttu-id="914e2-166">Por ejemplo, supongamos que hemos implementado una operación `U : ((Double, Qubit[]) => () : Adjoint)` que corresponde a una familia de operadores unitarios $U (t) $ y ha proporcionado un `adjoint` bloque explícito en lugar de usar `adjoint auto` .</span><span class="sxs-lookup"><span data-stu-id="914e2-166">For example, suppose we have implemented an operation `U : ((Double, Qubit[]) => () : Adjoint)` corresponding to a family of unitary operators $U(t)$, and have provided an explicit `adjoint` block instead of using `adjoint auto`.</span></span>
<span data-ttu-id="914e2-167">Es posible que le interese afirmar que $U ^ \dagger (t) = U (-t) $, como se esperaba si $t $ representa una hora de evolución.</span><span class="sxs-lookup"><span data-stu-id="914e2-167">We may be interested in asserting that $U^\dagger(t) = U(-t)$, as expected if $t$ represents an evolution time.</span></span>

<span data-ttu-id="914e2-168">En términos generales, hay dos estrategias diferentes que podemos seguir para realizar la aserción de que dos operaciones `U` y `V` actúan exactamente igual.</span><span class="sxs-lookup"><span data-stu-id="914e2-168">Broadly speaking, there are two different strategies that we can follow in making the assertion that two operations `U` and `V` act identically.</span></span>
<span data-ttu-id="914e2-169">En primer lugar, podemos comprobar que `U(target); (Adjoint V)(target);` conserva cada estado de forma determinada.</span><span class="sxs-lookup"><span data-stu-id="914e2-169">First, we can check that `U(target); (Adjoint V)(target);` preserves each state in a given basis.</span></span>
<span data-ttu-id="914e2-170">En segundo lugar, podemos comprobar que `U(target); (Adjoint V)(target);` actuar a la mitad de un estado inactivo conserva ese inenredo.</span><span class="sxs-lookup"><span data-stu-id="914e2-170">Second, we can check that `U(target); (Adjoint V)(target);` acting on half of an entangled state preserves that entanglement.</span></span>
<span data-ttu-id="914e2-171">Estas estrategias las implementan las operaciones de Canon <xref:microsoft.quantum.diagnostics.assertoperationsequalinplace> y <xref:microsoft.quantum.diagnostics.assertoperationsequalreferenced> , respectivamente.</span><span class="sxs-lookup"><span data-stu-id="914e2-171">These strategies are implemented by the canon operations <xref:microsoft.quantum.diagnostics.assertoperationsequalinplace> and <xref:microsoft.quantum.diagnostics.assertoperationsequalreferenced>, respectively.</span></span>

> [!NOTE]
> <span data-ttu-id="914e2-172">La aserción a la que se hace referencia anteriormente funciona en función de [Choi – Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), un marco de trabajo matemático que relaciona las operaciones en $n $ qubits con los Estados indebidos en $2N $ qubits.</span><span class="sxs-lookup"><span data-stu-id="914e2-172">The referenced assertion discussed above works based on the [Choi–Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), a mathematical framework which relates operations on $n$ qubits to entangled states on $2n$ qubits.</span></span>
> <span data-ttu-id="914e2-173">En concreto, la operación de identidad en $n $ qubits se representa mediante $n $ copias del estado enenredado $ \ket{\ beta_ {00} } \mathrel{: =} (\ket {00} + \ket {11} )/\sqrt {2} $.</span><span class="sxs-lookup"><span data-stu-id="914e2-173">In particular, the identity operation on $n$ qubits is represented by $n$ copies of the entangled state $\ket{\beta_{00}} \mathrel{:=} (\ket{00} + \ket{11}) / \sqrt{2}$.</span></span>
> <span data-ttu-id="914e2-174">La operación <xref:microsoft.quantum.preparation.preparechoistate> implementa este isomorphism y prepara un estado que representa una operación determinada.</span><span class="sxs-lookup"><span data-stu-id="914e2-174">The operation <xref:microsoft.quantum.preparation.preparechoistate> implements this isomorphism, preparing a state that represents a given operation.</span></span>

<span data-ttu-id="914e2-175">En líneas generales, estas estrategias se distinguen por un equilibrio de tiempo y espacio.</span><span class="sxs-lookup"><span data-stu-id="914e2-175">Roughly, these strategies are distinguished by a time–space tradeoff.</span></span>
<span data-ttu-id="914e2-176">Recorrer en iteración cada estado de entrada tarda más tiempo, mientras que si se usa el inenredo como referencia, es necesario almacenar qubits adicionales.</span><span class="sxs-lookup"><span data-stu-id="914e2-176">Iterating through each input state takes additional time, while using entanglement as a reference requires storing additional qubits.</span></span>
<span data-ttu-id="914e2-177">En los casos en los que una operación implementa una operación clásica reversible, de modo que solo estamos interesados en su comportamiento en Estados de base de cálculo, <xref:microsoft.quantum.diagnostics.assertoperationsequalinplacecompbasis> comprueba la igualdad de este conjunto restringido de entradas.</span><span class="sxs-lookup"><span data-stu-id="914e2-177">In cases where an operation implements a reversible classical operation, such that we are only interested in its behavior on computational basis states, <xref:microsoft.quantum.diagnostics.assertoperationsequalinplacecompbasis> tests equality on this restricted set of inputs.</span></span>

> [!TIP]
> <span data-ttu-id="914e2-178">La iteración en Estados de entrada se controla mediante las operaciones de enumeración <xref:microsoft.quantum.canon.iteratethroughcartesianproduct> y <xref:microsoft.quantum.canon.iteratethroughcartesianpower> .</span><span class="sxs-lookup"><span data-stu-id="914e2-178">The iteration over input states is handled by the enumeration operations <xref:microsoft.quantum.canon.iteratethroughcartesianproduct> and <xref:microsoft.quantum.canon.iteratethroughcartesianpower>.</span></span>
> <span data-ttu-id="914e2-179">Estas operaciones son más útiles en general para aplicar una operación a cada elemento del producto cartesiano entre dos o más conjuntos.</span><span class="sxs-lookup"><span data-stu-id="914e2-179">These operations are useful more generally for applying an operation to each element of the Cartesian product between two or more sets.</span></span>

<span data-ttu-id="914e2-180">Sin embargo, de forma más crítica, los dos enfoques prueban las distintas propiedades de las operaciones en examen.</span><span class="sxs-lookup"><span data-stu-id="914e2-180">More critically, however, the two approaches test different properties of the operations under examination.</span></span>
<span data-ttu-id="914e2-181">Dado que la aserción en contexto llama a cada operación varias veces, una vez para cada estado de entrada, las opciones aleatorias y los resultados de la medición podrían cambiar entre las llamadas.</span><span class="sxs-lookup"><span data-stu-id="914e2-181">Since the in-place assertion calls each operation multiple times, once for each input state, any random choices and measurement results might change between calls.</span></span>
<span data-ttu-id="914e2-182">Por el contrario, la aserción a la que se hace referencia llama a cada operación exactamente una vez, de modo que comprueba que las operaciones son iguales *en una sola captura*.</span><span class="sxs-lookup"><span data-stu-id="914e2-182">By contrast, the referenced assertion calls each operation exactly once, such that it checks that the operations are equal *in a single shot*.</span></span>
<span data-ttu-id="914e2-183">Ambas pruebas son útiles para garantizar la corrección de los programas Quantum.</span><span class="sxs-lookup"><span data-stu-id="914e2-183">Both of these tests are useful in ensuring the correctness of quantum programs.</span></span>


## <a name="further-reading"></a><span data-ttu-id="914e2-184">Lecturas adicionales</span><span class="sxs-lookup"><span data-stu-id="914e2-184">Further Reading</span></span> ##

- <xref:microsoft.quantum.guide.testingdebugging>
- <xref:microsoft.quantum.diagnostics>
