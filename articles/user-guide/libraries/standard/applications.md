---
title: Aplicaciones en las Q# bibliotecas estándar
description: 'Obtenga información sobre dos aplicaciones fundamentales en Quantum Computing: Hamiltonian Simulation y el algoritmo de búsqueda de mé.'
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro
ms.date: 12/11/2017
ms.topic: conceptual
no-loc:
- Q#
- $$v
ms.openlocfilehash: 214d584840f235868c66a1fb3ee24d0acab49630
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/26/2021
ms.locfileid: "98857237"
---
# <a name="applications"></a><span data-ttu-id="fd5ee-103">Aplicaciones</span><span class="sxs-lookup"><span data-stu-id="fd5ee-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="fd5ee-104">Simulación de Hamilton</span><span class="sxs-lookup"><span data-stu-id="fd5ee-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="fd5ee-105">La simulación de los sistemas Quantum es una de las aplicaciones más interesantes del cálculo de Quantum.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="fd5ee-106">En un equipo clásico, la dificultad de simular la mecánica de Quantum, en general, se escala con la dimensión $N $ de su representación de vector de estado.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="fd5ee-107">A medida que esta representación aumenta exponencialmente con el número de $n $ qubits $N = 2 ^ n $, un rasgo conocido que también se conoce como el [Curse de dimensionalidad](xref:microsoft.quantum.concepts.multiple-qubits), la simulación de Quantum en hardware clásico es inestable.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="fd5ee-108">Sin embargo, la situación puede ser muy diferente en el hardware Quantum.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="fd5ee-109">La variación más común de la simulación de Quantum se denomina problema de simulación de Hamiltonian independiente del tiempo.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="fd5ee-110">Allí, se proporciona una descripción del sistema Hamiltonian $H $, que es una matriz Hermitian, y algunos estados iniciales de Quantum $ \ket{\psi (0)} $ que se codifican de alguna manera en $n $ qubits en un equipo Quantum.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="fd5ee-111">Como los Estados de Quantum en sistemas cerrados evolucionan con la ecuación Schrödinger $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)}, \end{align} $ $ el objetivo es implementar el operador unitario Time-Evolution $U (t) = e ^ {-iHt} $ en un tiempo fijo $t $, donde $ \ket{\psi (t)} = U (t) \ket{\psi (0)} $ resuelve la ecuación Schrödinger.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="fd5ee-112">De forma análoga, el problema de simulación de Hamiltonian dependiente del tiempo resuelve la misma ecuación, pero con $H (t) $ ahora es una función de tiempo.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="fd5ee-113">Hamiltonian Simulation es un componente importante de muchos otros problemas de simulación de Quantum y las soluciones para el problema de simulación de Hamiltonian son algoritmos que describen una secuencia de las puertas de Quantum primitivas para sintetizar una unidad aproximada de la unidad $ \tilde{U} $ con el error $ \\ | \tilde{U}-U (t) \\ | \le \epsilon $ en la [norma espectral](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="fd5ee-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="fd5ee-114">La complejidad de estos algoritmos depende en gran parte del modo en que un equipo Quantum puede acceder a una descripción del Hamiltonian de interés.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="fd5ee-115">Por ejemplo, en el peor de los casos, si $H $ actuando en $n $ qubits se proporcionara como una lista de $2 ^ n \times 2 ^ n $ Numbers, uno para cada elemento de la matriz, la simple lectura de los datos ya requeriría tiempo exponencial.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="fd5ee-116">En el mejor de los casos, podría suponerse el acceso a una unitario de cuadro negro que $O \ket{t}\ket{\psi (0)} = \ket{t}U (t) \ket{\psi (0)} $ resuelve el problema de forma trivial.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="fd5ee-117">Ninguno de estos modelos de entrada es especialmente interesante (el primero, ya que no es mejor que los enfoques clásico, y el último como el negro oculta la complejidad de la puerta primitiva de su implementación, que podría ser exponencial en el número de qubits.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="fd5ee-118">Descripciones de Hamiltonians</span><span class="sxs-lookup"><span data-stu-id="fd5ee-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="fd5ee-119">Por lo tanto, se requieren suposiciones adicionales del formato de la entrada.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="fd5ee-120">Se debe ajustar el equilibrio entre los modelos de entrada que son suficientemente descriptivos para abarcar Hamiltonians interesantes, como los de sistemas físicos realistas o problemas de cálculo interesantes, y los modelos de entrada que son suficientemente restrictivos para ser implementables de forma eficaz en un equipo Quantum.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="fd5ee-121">En la literatura se puede encontrar una variedad de modelos de entrada no triviales y que van desde Quantum hasta el clásico.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="fd5ee-122">Como ejemplos de modelos de entrada Quantum, [la simulación de Hamiltonian basada en muestras](http://www.nature.com/articles/s41534-017-0013-7) presupone el acceso de caja negra a las operaciones Quantum que producen copias de una matriz de densidad $ \rho $, que se toman para ser el Hamiltonian $H $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="fd5ee-123">En el [modelo de acceso a](https://arxiv.org/abs/1202.5822) la unidad, se supone que el Hamiltonian se descompone en una suma de unitaries $ $ \begin{align} H & = \sum ^ {d-1} \_ {j = 0} a \_ j \hat{U} \_ j, \end{align} $ $, donde $a \_ j>$0 son coeficientes y $ \hat{U} \_ j $ son unitaries.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="fd5ee-124">A continuación, se supone que una tiene acceso de caja negra a la unidad unitario de Oracle $V = \sum ^ {d-1} \_ {j = 0} \Ket{j}\bra{j}\otimes \hat{U} \_ j $ que selecciona el $ \hat{U} j $ que se desea. \_ y Oracle $A \ket {0} = \sum ^ {d-1} \_ {j = 0} \sqrt{a \_ j/\ SUM ^ {d-1} \_ {k = 0} \alpha \_ j} \ket{j} $ que crean una codificación de estado de Quantum con estos coeficientes.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="fd5ee-125">En el caso de una [simulación Hamiltonian dispersa](https://arxiv.org/abs/quant-ph/0301023), se supone que Hamiltonian es una matriz dispersa con solo $d = \mathcal{O} (\Text{polylog} (N)) $ elemento distinto de cero en cada fila.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="fd5ee-126">Además, uno asume la existencia de circuitos Quantum eficientes que generan la ubicación de estos elementos distintos de cero, así como sus valores.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="fd5ee-127">La complejidad de los [algoritmos de simulación de Hamiltonian](xref:microsoft.quantum.more-information) se evalúa en cuanto al número de consultas a estas casillas negras, y la complejidad de la puerta primitiva depende en gran medida de la dificultad de implementar estos cuadros negros.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="fd5ee-128">La notación Big-O se usa normalmente para describir el escalado de complejidad de los algoritmos.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="fd5ee-129">Dadas dos funciones reales $f, g $, la expresión $g (x) = \mathcal{O} (f (x)) $ significa que existe una constante positiva absoluta $x \_ 0, c>$0, de modo que $g (x) \le c f (x) $ para todos los $x \ge x \_ $0.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="fd5ee-130">En la mayoría de las aplicaciones prácticas que se implementan en un equipo Quantum, estos cuadros negros deben ser implementables de forma eficaz, es decir, con $ \mathcal{O} (\text{polylog} (N)) $ primitivas de Quantum.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="fd5ee-131">De forma más segura, simulable Hamiltonians debe tener una descripción clásica suficientemente dispersa.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="fd5ee-132">En una de estas fórmulas, se da por supuesto que Hamiltonian se descompone en una suma de las partes de Hermitian $ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="fd5ee-133">\end{align} $ $ además, se supone que cada parte, un Hamiltonian $H \_ j $, es fácil de simular.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="fd5ee-134">Esto significa que la $e unitario ^ {-admitir \_ j t} $ en cualquier momento $t $ puede implementarse exactamente mediante las puertas de Quantum primitivas $ \mathcal{O} (1) $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="fd5ee-135">Por ejemplo, esto es cierto en el caso especial en el que cada $H \_ j $ son operadores de Pauli locales, lo que significa que son de tensores productos de los operadores $ \mathcal{O} (1) $ no Identity Pauli que actúan sobre el cierre espacial de qubits.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="fd5ee-136">Este modelo se aplica especialmente a los sistemas físicos con interacción enlazada y local, ya que el número de términos es $d = \mathcal{O} (\text{polylog} (N)) $ y se puede escribir claramente, es decir, describirse de forma que es en el tiempo Polinómico.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="fd5ee-137">Hamiltonians que se descomponen en una suma de partes se pueden describir mediante la biblioteca de representación de generador dinámica.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="fd5ee-138">Para obtener más información, vea la sección representación dinámica del generador en [estructuras de datos](xref:microsoft.quantum.libraries.data-structures).</span><span class="sxs-lookup"><span data-stu-id="fd5ee-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="fd5ee-139">Algoritmos de simulación</span><span class="sxs-lookup"><span data-stu-id="fd5ee-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="fd5ee-140">Un algoritmo de simulación de Quantum convierte una descripción determinada de un Hamiltonian en una secuencia de las puertas de Quantum primitivas que, en conjunto, se aproxima aproximadamente a la evolución de tiempo por dicho Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="fd5ee-141">En el caso especial en el que Hamiltonian se descomponga en una suma de partes de Hermitian, la descomposición Trotter-Suzuki es un algoritmo especialmente sencillo e intuitivo para simular Hamiltonians que se descomponen en una suma de componentes de Hermitian.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="fd5ee-142">Por ejemplo, un integrador de primer orden de esta familia se aproxima a $ $ \begin{align} U (t) & = \left (e ^ {-admitir \_ 0 t/r} e ^ {-admitir \_ 1 t/r} \cdots e ^ {-admitir \_ {d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \end{align} $ $ mediante un producto de $r d $ terms.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="fd5ee-143">Las aplicaciones del algoritmo de simulación de Trotter-Suzuki se describen en los ejemplos.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="fd5ee-144">Para el modelo Ising usando solo las operaciones intrínsecas proporcionadas por cada equipo de destino, consulte el [ejemplo **SimpleIsing**](https://github.com/microsoft/Quantum/blob/main/samples/simulation/ising/simple).</span><span class="sxs-lookup"><span data-stu-id="fd5ee-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/blob/main/samples/simulation/ising/simple).</span></span>
> <span data-ttu-id="fd5ee-145">Para el modelo Ising que usa la estructura de control de biblioteca Trotter-Suzuki, consulte el [ejemplo **IsingTrotter**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/trotter-evolution).</span><span class="sxs-lookup"><span data-stu-id="fd5ee-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/trotter-evolution).</span></span>
> <span data-ttu-id="fd5ee-146">Para el hidrógeno molecular mediante la estructura de control de la biblioteca de Trotter-Suzuki, consulte el ejemplo de [ **simulación de H2**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line).</span><span class="sxs-lookup"><span data-stu-id="fd5ee-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line).</span></span>

<span data-ttu-id="fd5ee-147">En muchos casos, nos gustaría implementar el algoritmo de simulación, pero no le interesan los detalles de su implementación.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="fd5ee-148">Por ejemplo, el integrador de segundo orden se aproxima a $ $ \begin{align} U (t) & = \left (e ^ {-admitir \_ 0 t/2R} e ^ {-admitir \_ 1 t/2R} \cdots e ^ {-admitir \_ {d-1} t/2R} e ^ {-admitir \_ {d-1} t/2R} \cdots e ^ {-admitir \_ 1 t/2R} e ^ {-admitir \_ 0 t/2R} \right) ^ {r} + \mathcal{O} (d ^ 3 \ max_j \\ | H \_ j \\ | ^ 3 t ^ 3/r ^ 2), \end{align} $ $ mediante un producto de $2rd $ terms.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="fd5ee-149">Los pedidos más grandes implicarán aún más términos y las variantes optimizadas pueden requerir pedidos muy no triviales en el exponencial.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="fd5ee-150">Otros algoritmos avanzados también pueden implicar el uso de ancilla qubits en pasos intermedios.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="fd5ee-151">Por lo tanto, empaquetamos algoritmos de simulación en la Canon como el tipo definido por el usuario.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="fd5ee-152">El primer parámetro `Double` es la hora de la simulación, el segundo parámetro, que se `EvolutionGenerator` describe en la sección representación dinámica del generador de [estructuras de datos](xref:microsoft.quantum.libraries.data-structures), es una descripción clásica de un Hamiltonian independiente del tiempo empaquetado con instrucciones sobre cómo un circuito Quantum puede simular cada término de la Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="fd5ee-153">Los tipos de este formulario se aproximan a la operación unitario $e ^ {-iHt} $ en el tercer parámetro `Qubit[]` , que es el registro que almacena el estado de cuanto del sistema simulado.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="fd5ee-154">De forma similar al caso dependiente del tiempo, se define un tipo definido por el usuario con un `EvolutionSchedule` tipo en su lugar, que es una descripción clásica de un Hamiltonian dependiente del tiempo.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="fd5ee-155">Como ejemplo, se puede llamar a la descomposición de Trotter-Suzuki mediante las siguientes funciones de Canon, con parámetros que `trotterStepSize` modifican la duración de la simulación en cada exponencial y `trotterOrder` el orden del integrador deseado.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: SimulationAlgorithm {
    ...
}

function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="fd5ee-156">Las aplicaciones de la biblioteca de simulación se describen en los ejemplos.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="fd5ee-157">Para la estimación de fase en el modelo Ising con `SimulationAlgorithm` , consulte el [ejemplo **IsingPhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="fd5ee-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>
> <span data-ttu-id="fd5ee-158">Para la preparación del estado de adiabatic en el modelo de Ising con `TimeDependentSimulationAlgorithm` , consulte el [ejemplo **AdiabaticIsing**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="fd5ee-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="fd5ee-159">Preparación del estado de la Adiabatic & estimación de fase</span><span class="sxs-lookup"><span data-stu-id="fd5ee-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="fd5ee-160">Una aplicación común de la simulación de Hamiltonian es la preparación del estado de Adiabatic.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="fd5ee-161">En este caso, se proporciona una con dos $H Hamiltonians \_ {\text{Start}} $ y $H \_ {\text{end}} $, y un Quantum State $ \ket{\psi (0)} $ que es un estado de la base de inicio Hamiltonian $H \_ {\text{Start}} $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="fd5ee-162">Normalmente, \_ se elige $H {\text{Start}} $, de modo que $ \ket{\psi (0)} $ sea fácil de preparar desde un estado de base de cálculo $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="fd5ee-163">Al interpolar entre estos Hamiltonians en el problema de simulación dependiente del tiempo lo suficientemente lentamente, es posible terminar, con alta probabilidad, en el estado de la base de Hamiltonian final $H \_ {\text{end}} $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficiently slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="fd5ee-164">A pesar de que la preparación de las buenas aproximaciones a los Estados de la Hamiltonian puede continuar de esta manera mediante una llamada a en algoritmos de simulación de Hamiltonian dependientes del tiempo como una subrutina, otros enfoques conceptualmente diferentes como eigensolver de Quantum de variación son posibles.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="fd5ee-165">Otra aplicación omnipresente en la química Quantum es estimar la energía de estado de la base de Hamiltonians que representa los pasos intermedios de la reacción química.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="fd5ee-166">Por ejemplo, un esquema de este tipo podría basarse en la preparación del estado de Adiabatic para crear el estado de la base y, a continuación, incorporar la simulación de Hamiltonian independiente del tiempo como subrutina en la caracterización de la fase de estimación para extraer esta energía con un error finito y una probabilidad de éxito.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="fd5ee-167">Abstracción de algoritmos de simulación como tipos definidos por el usuario `SimulationAlgorithm` y `TimeDependentSimulationAlgorithm` nos permite incorporar la funcionalidad de forma cómoda en algoritmos Quantum más sofisticados.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="fd5ee-168">Esto nos motiva a hacer lo mismo para estas subrutinas de uso frecuente.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="fd5ee-169">Por lo tanto, definimos la función adecuada</span><span class="sxs-lookup"><span data-stu-id="fd5ee-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime : Double, 
        evolutionGeneratorStart : EvolutionGenerator,
        evolutionGeneratorEnd : EvolutionGenerator,
        timeDependentSimulationAlgorithm : TimeDependentSimulationAlgorithm)
: (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="fd5ee-170">Esto devuelve una operación de unitario que implementa todos los pasos de preparación del estado de Adiabatic.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="fd5ee-171">El primer parámetro `interpolatedTime` define el tiempo durante el que se interpolará linealmente entre el Hamiltonian de inicio descrito por el segundo parámetro `evolutionGeneratorStart` y el Hamiltonian final descrito por el tercer parámetro `evolutionGeneratorEnd` .</span><span class="sxs-lookup"><span data-stu-id="fd5ee-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="fd5ee-172">El cuarto parámetro `timeDependentSimulationAlgorithm` es donde uno hace la elección del algoritmo de simulación.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="fd5ee-173">Tenga en cuenta que si el `interpolatedTime` valor de es lo suficientemente largo, un estado de la base inicial sigue siendo un estado de conexión de la Hamiltonian en toda la duración de la simulación dependiente del tiempo y, por tanto, finaliza en el estado de conexión de la Hamiltonian final.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="fd5ee-174">También se define una operación útil que realiza automáticamente todos los pasos de un experimento de química de Quantum típico.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="fd5ee-175">Por ejemplo, tenemos lo siguiente, que devuelve una estimación de energía del estado producido por la preparación del estado de Adiabatic:</span><span class="sxs-lookup"><span data-stu-id="fd5ee-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation EstimateAdiabaticStateEnergy(
    nQubits : Int,
    statePrepUnitary : (Qubit[] => Unit),
    adiabaticUnitary : (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double {
...
}
```

<span data-ttu-id="fd5ee-176">`nQubits` es el número de qubits que se usa para codificar el estado de cuanto inicial.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="fd5ee-177">`statePrepUnitary` prepara el estado de inicio de la base de cálculo $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="fd5ee-178">`adiabaticUnitary` es la operación unitario que implementa la preparación del estado de Adiabatic, como la generada por la  `InterpolatedEvolution` función.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="fd5ee-179">`qpeUnitary` es la operación unitario que se utiliza para realizar una estimación de la fase en el estado de cuanto resultante.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="fd5ee-180">`phaseEstAlgorithm` es nuestra elección del algoritmo de estimación de fase.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="fd5ee-181">Las aplicaciones de preparación del estado de Adiabatic se describen en los ejemplos.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="fd5ee-182">Para el modelo Ising mediante una implementación manual de la preparación del estado de adiabatic en lugar de usar la `AdiabaticEvolution` función, consulte el [ejemplo **AdiabaticIsing**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="fd5ee-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span></span>
> <span data-ttu-id="fd5ee-183">Para la estimación de la fase y la preparación del estado de adiabatic en el modelo Ising, consulte el [ejemplo **IsingPhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="fd5ee-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>

> [!TIP]
> <span data-ttu-id="fd5ee-184">La [simulación de hidrógeno molecular](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) es un ejemplo interesante y breve.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-184">The [simulation of molecular Hydrogen](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) is an interesting and brief sample.</span></span> <span data-ttu-id="fd5ee-185">El modelo y los resultados experimentales que se muestran en [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span><span class="sxs-lookup"><span data-stu-id="fd5ee-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="fd5ee-186">solo requiere matrices Pauli y tiene el formato $ \hat H = g \_ {0} I \_ 0I \_ 1 + g \_ 1 {z \_ 0} + g \_ 2 {Z \_ 1} + g \_ 3 {z \_ 0} {z \_ 1} + g \_ 4 {Y \_ 0} {y \_ 1} + g \_ 5 {x \_ 0} {x \_ 1} $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="fd5ee-187">Se trata de un Hamiltonian efectivo que solo requiere 2 qubits, donde las constantes $g $ se calculan a partir de la distancia $R $ entre los dos átomos de hidrógeno.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="fd5ee-188">Con las funciones de Canon, Paulis se convierte en unitaries y, a continuación, evolucionó durante breves períodos de tiempo mediante el Trotter-Suzuki la descomposición.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="fd5ee-189">Se puede crear una buena aproximación a la $H _2 $ de la alimentación sin usar la preparación del estado de Adiabatic y, por tanto, la energía del estado de la base se puede encontrar directamente mediante la estimación de fase de la Canon.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="fd5ee-190">Algoritmo de Shor</span><span class="sxs-lookup"><span data-stu-id="fd5ee-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="fd5ee-191">El algoritmo de mé sigue siendo uno de los progresos más importantes de la informática Quantum porque mostró que los equipos Quantum podrían usarse para resolver problemas importantes, que actualmente se pueden deducir.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="fd5ee-192">El algoritmo de mé proporciona una manera rápida de factorizar números grandes mediante un equipo Quantum, un problema llamado *factorización*.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring*.</span></span>
<span data-ttu-id="fd5ee-193">La seguridad de muchos cryptosystems de día presentes se basa en la suposición de que no existe ningún algoritmo rápido para la factorización.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="fd5ee-194">Por lo tanto, el algoritmo de mé ha tenido un impacto profundo en cómo pensamos en la seguridad en un mundo posterior al Quantum.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="fd5ee-195">El algoritmo de mé puede considerarse un algoritmo híbrido.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="fd5ee-196">El equipo Quantum se usa para llevar a cabo una tarea computacionalmente difícil conocida como búsqueda de períodos.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="fd5ee-197">Los resultados del período de búsqueda se procesan entonces de forma que se calculan los factores.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="fd5ee-198">Estos dos pasos se revisan a continuación.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="fd5ee-199">Búsqueda de períodos</span><span class="sxs-lookup"><span data-stu-id="fd5ee-199">Period Finding</span></span> ###

<span data-ttu-id="fd5ee-200">Después de ver cómo funciona la transformación de Fourier y la fase de estimación de las fases (consulte [algoritmos Quantum](xref:microsoft.quantum.libraries.standard.algorithms)), podemos usar estas herramientas para resolver un problema de cálculo de clase difícilmente llamado *período de búsqueda*.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding*.</span></span>  <span data-ttu-id="fd5ee-201">En la siguiente sección, veremos cómo aplicar el período de búsqueda a la factorización.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="fd5ee-202">Dados dos enteros $a $ y $N $, donde $a<N $, el objetivo de la búsqueda del período, también denominado búsqueda de pedidos, es encontrar el _orden_ $r $ de $a $ módulo $N $, donde $r $ se define como el entero menos positivo, de modo que $a ^ r \equiv 1 \text{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="fd5ee-203">Para encontrar el pedido mediante un equipo Quantum, podemos usar el algoritmo de estimación de fase que se aplica al siguiente Operador unitario $U _a $: $ $ U_a \ket{x} \equiv \ket{(AX) \text{mod} N}. $ $ vectores propios de $U _a $ son para el entero $s $ y $0 \ Leq s \leq r-$1, $ $ \ket{x_s} \equiv 1/\sqrt{r} \sum \_ {k = 0} ^ {r-1} e ^ {\frac{-2\pi i SK} {r}} \ket{a ^ k\text {mod} N}, $ $ son _eigenstates_ de $U _a $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="fd5ee-204">La vectores propios de $U _a $ son $ $ U \_ a \ket{x \_ s} = e ^ {2 \ Pi i s/r} \ket{x \_ s}.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="fd5ee-205">Por lo tanto, la estimación de fase genera el vectores propios $e ^ {2 \ Pi i s/r} $ desde el que $r $ se puede aprender eficazmente mediante [fracciones continuas](https://en.wikipedia.org/wiki/Continued_fraction) de $s/r $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="fd5ee-206">El diagrama del circuito para buscar el período de Quantum es:</span><span class="sxs-lookup"><span data-stu-id="fd5ee-206">The circuit diagram for quantum period finding is:</span></span>

![Diagrama de circuito para buscar período de Quantum](~/media/QPE.svg)

<span data-ttu-id="fd5ee-208">Aquí $2N $ qubits se inicializan en $ \ket {0} $ y $n $ qubits se inicializan en $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-208">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="fd5ee-209">Es posible que el lector se pregunte por qué el registro de Quantum para contener el eigenstates se inicializa en $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-209">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="fd5ee-210">Como uno no conoce el orden $r $ de antemano, en realidad no se pueden preparar $ \ket{x_s} $ States directamente.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-210">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="fd5ee-211">Afortunadamente, resulta que $1/\ sqrt {r} \sum \_ {s = 0} ^ {r-1} \ket{x \_ s} = \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-211">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="fd5ee-212">En realidad, no es necesario preparar $ \ket{x} $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-212">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="fd5ee-213">Solo se puede preparar un registro de Quantum de $n $ qubits en el estado $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-213">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="fd5ee-214">El circuito contiene el QFT y varias puertas controladas.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-214">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="fd5ee-215">La puerta QFT se ha descrito [anteriormente](xref:microsoft.quantum.libraries.standard.algorithms).</span><span class="sxs-lookup"><span data-stu-id="fd5ee-215">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="fd5ee-216">El $U controlado _a $ Gate asigna $ \ket{x} $ a $ \ket{(AX) \text{mod} N} $ si el control qubit es $ \ket {1} $ y asigna $ \ket{x} $ a $ \ket{x} $ en caso contrario.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-216">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="fd5ee-217">Para lograr $ (a ^ NX) \text{mod} N $, podemos simplemente aplicar el $U controlado _ {a ^ n} $, donde calculamos $a ^ n \text{mod} N $ classly para conectarse al circuito Quantum.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-217">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="fd5ee-218">Los circuitos para lograr este tipo de aritmética modular se han descrito en la [documentación aritmética de Quantum](./algorithms.md#arithmetic), en concreto, se requiere un circuito de exponenciación modular para implementar las operaciones de $U controlada \_ {a ^ i} $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-218">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="fd5ee-219">Aunque el circuito anterior corresponde a la estimación de la [fase de Quantum](xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation) y habilita explícitamente la búsqueda de pedidos, podemos reducir el número de qubits necesarias.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-219">While the circuit above corresponds to [Quantum Phase Estimation](xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="fd5ee-220">Podemos seguir el método de Beauregard para buscar el orden, como se describe [en la página 8 de arXiv: Quant-pH/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), o usar una de las rutinas de estimación de fase disponibles en Microsoft. Quantum. Caracterización.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-220">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Characterization.</span></span> <span data-ttu-id="fd5ee-221">Por ejemplo, la [estimación de fase sólida](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation) también usa un qubit adicional.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-221">For example, [Robust Phase Estimation](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation) also uses one extra qubit.</span></span>

### <a name="factoring"></a><span data-ttu-id="fd5ee-222">Factorización</span><span class="sxs-lookup"><span data-stu-id="fd5ee-222">Factoring</span></span> ###
<span data-ttu-id="fd5ee-223">El objetivo de la factorización es determinar los dos factores primos de entero $N $, donde $N $ es una $n número $-bit.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-223">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="fd5ee-224">La factorización consta de los pasos que se describen a continuación.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-224">Factoring consists of the steps described below.</span></span> <span data-ttu-id="fd5ee-225">Los pasos se dividen en tres partes: una rutina de preprocesamiento clásico (1-4); una rutina de procesamiento de quantums para buscar el orden de $a \text{mod} N $ (5); y una rutina de procesamiento de postprocesamiento clásico para derivar los factores primos del pedido (6-9).</span><span class="sxs-lookup"><span data-stu-id="fd5ee-225">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="fd5ee-226">La rutina de preprocesamiento clásico consta de los siguientes pasos:</span><span class="sxs-lookup"><span data-stu-id="fd5ee-226">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="fd5ee-227">Si $N $ es par, devuelve el factor primo $2 $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-227">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="fd5ee-228">Si $N = p ^ q $ para $p \geq1 $, $q \geq2 $, devuelve el factor primo $p $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-228">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="fd5ee-229">Este paso se realiza de forma de clase.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-229">This step is performed classically.</span></span>
3. <span data-ttu-id="fd5ee-230">Elija un número aleatorio $a $ tal que $1 < un < N-$1.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-230">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="fd5ee-231">Si $ \text{GCD} (a, N) >$1, devuelve el factor primo $ \text{GCD} (a, N) $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-231">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="fd5ee-232">Este paso se calcula mediante el algoritmo de Euclides.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-232">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="fd5ee-233">Si no se ha devuelto ningún factor primo, se pasa a la rutina Quantum:</span><span class="sxs-lookup"><span data-stu-id="fd5ee-233">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="fd5ee-234">Llame al algoritmo de búsqueda de período de Quantum para calcular el orden $r $ de $a \text{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-234">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="fd5ee-235">Use $r $ en la rutina de procesamiento de postprocesamiento clásico para determinar los factores primos:</span><span class="sxs-lookup"><span data-stu-id="fd5ee-235">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="fd5ee-236">Si $r $ es impar, vuelva al paso de preprocesamiento (3).</span><span class="sxs-lookup"><span data-stu-id="fd5ee-236">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="fd5ee-237">Si $r $ es par y $a ^ {r/2} =-1 \ Text {mod} N $, vuelva al paso de preprocesamiento (3).</span><span class="sxs-lookup"><span data-stu-id="fd5ee-237">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="fd5ee-238">Si $ \text{GCD} (a ^ {r/2} + 1, N) $ es un factor no trivial de $N $, devuelve $ \text{GCD} (a ^ {r/2} + 1, N) $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-238">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="fd5ee-239">Si $ \text{GCD} (a ^ {r/2}-1, N) $ es un factor no trivial de $N $, se devuelve $ \text{GCD} (a ^ {r/2}-1, N) $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-239">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="fd5ee-240">El algoritmo de factorización es probabilística: se puede mostrar que con probabilidad al menos una mitad que $r $ será par y $a ^ {r/2} \neq-1 \text{mod} N $, lo que genera un factor primo.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-240">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="fd5ee-241">(Consulte el [documento original de mé](https://doi.org/10.1109/SFCS.1994.365700) para obtener más información o uno de los textos *básicos de cálculo de quantums* en [para obtener más información](xref:microsoft.quantum.more-information)).</span><span class="sxs-lookup"><span data-stu-id="fd5ee-241">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="fd5ee-242">Si no se devuelve un factor primo, simplemente repetiremos el algoritmo del paso (1).</span><span class="sxs-lookup"><span data-stu-id="fd5ee-242">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="fd5ee-243">Después de $n $ intentos, la probabilidad de que se haya producido un error en cada intento es como máximo $2 ^ {-n} $.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-243">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="fd5ee-244">Por lo tanto, después de repetir el algoritmo, se garantiza prácticamente un número pequeño de veces.</span><span class="sxs-lookup"><span data-stu-id="fd5ee-244">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
