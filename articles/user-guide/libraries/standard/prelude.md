---
title: Operaciones intrínsecas y funciones en QDK
description: Obtenga información sobre las operaciones intrínsecas y las funciones de QDK, incluidas las funciones clásicas y las operaciones de unitario, rotación y medición.
author: QuantumWriter
ms.author: martinro
ms.date: 12/11/2017
ms.topic: conceptual
uid: microsoft.quantum.libraries.standard.prelude
no-loc:
- Q#
- $$v
ms.openlocfilehash: 6ed5b1677a204b9425f229a3ea0855bb789f3f75
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/26/2021
ms.locfileid: "98857187"
---
# <a name="the-prelude"></a><span data-ttu-id="a6a73-103">El preparador</span><span class="sxs-lookup"><span data-stu-id="a6a73-103">The Prelude</span></span> #

<span data-ttu-id="a6a73-104">El Q# compilador y las máquinas de destino incluidas en el kit de desarrollo de Quantum proporcionan un conjunto de funciones y operaciones intrínsecas que se pueden usar al escribir programas Quantum en Q# .</span><span class="sxs-lookup"><span data-stu-id="a6a73-104">The Q# compiler and the target machines included with the Quantum Development Kit provide a set of intrinsic functions and operations that can be used when writing quantum programs in Q#.</span></span>

## <a name="intrinsic-operations-and-functions"></a><span data-ttu-id="a6a73-105">Operaciones y funciones intrínsecas</span><span class="sxs-lookup"><span data-stu-id="a6a73-105">Intrinsic Operations and Functions</span></span> ##

<span data-ttu-id="a6a73-106">Las operaciones intrínsecas definidas en la biblioteca estándar se encuentran aproximadamente en una de varias categorías:</span><span class="sxs-lookup"><span data-stu-id="a6a73-106">The intrinsic operations defined in the standard library roughly fall into one of several categories:</span></span>

- <span data-ttu-id="a6a73-107">Funciones clásicas esenciales, recopiladas en el <xref:Microsoft.Quantum.Core> espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="a6a73-107">Essential classical functions, collected in the <xref:Microsoft.Quantum.Core> namespace.</span></span>
- <span data-ttu-id="a6a73-108">Operaciones que representan unitaries formada por [Clifford y $T $ Gates](xref:microsoft.quantum.concepts.qubit).</span><span class="sxs-lookup"><span data-stu-id="a6a73-108">Operations representing unitaries composed of [Clifford and $T$ gates](xref:microsoft.quantum.concepts.qubit).</span></span>
- <span data-ttu-id="a6a73-109">Operaciones que representan rotaciones sobre varios operadores.</span><span class="sxs-lookup"><span data-stu-id="a6a73-109">Operations representing rotations about various operators.</span></span>
- <span data-ttu-id="a6a73-110">Operaciones que implementan medidas.</span><span class="sxs-lookup"><span data-stu-id="a6a73-110">Operations implementing measurements.</span></span>

<span data-ttu-id="a6a73-111">Dado que el conjunto de Clifford + $T $ Gate es [universal](xref:microsoft.quantum.concepts.multiple-qubits) para la informática Quantum, estas operaciones bastan para implementar de forma aproximada cualquier algoritmo Quantum en un error poco significativo.</span><span class="sxs-lookup"><span data-stu-id="a6a73-111">Since the Clifford + $T$ gate set is [universal](xref:microsoft.quantum.concepts.multiple-qubits) for quantum computing, these operations suffice to approximately implement any quantum algorithm within negligibly small error.</span></span>
<span data-ttu-id="a6a73-112">Al proporcionar también giros, permite al Q# programador trabajar en una sola biblioteca de qubit y CNOT.</span><span class="sxs-lookup"><span data-stu-id="a6a73-112">By providing rotations as well, Q# allows the programmer to work within the single qubit unitary and CNOT gate library.</span></span> <span data-ttu-id="a6a73-113">Es mucho más fácil pensar en esta biblioteca porque no requiere que el programador exprese directamente la descomposición Clifford + $T $ y porque existen métodos muy eficaces para compilar una unitaries de qubit única en Clifford y $T $ Gates (vea [aquí](xref:microsoft.quantum.more-information) para obtener más información).</span><span class="sxs-lookup"><span data-stu-id="a6a73-113">This library is much easier to think about because it does not  require the programmer to directly express the Clifford + $T$ decomposition and because highly efficient methods exist for compiling single qubit unitaries into Clifford and $T$ gates (see [here](xref:microsoft.quantum.more-information) for more information).</span></span>

<span data-ttu-id="a6a73-114">Siempre que sea posible, las operaciones definidas en el ejemplo que actúan en qubits permiten aplicar la `Controlled` variante, de modo que el equipo de destino realizará la descomposición adecuada.</span><span class="sxs-lookup"><span data-stu-id="a6a73-114">Where possible, the operations defined in the prelude which act on qubits allow for applying the `Controlled` variant, such that the target machine will perform the appropriate decomposition.</span></span>

<span data-ttu-id="a6a73-115">Muchas de las funciones y operaciones definidas en esta parte del preparado se encuentran en el @"microsoft.quantum.intrinsic" espacio de nombres, de modo que la mayoría de Q# los archivos de código fuente tendrán una `open Microsoft.Quantum.Intrinsic;` Directiva inmediatamente después de la declaración de espacio de nombres inicial.</span><span class="sxs-lookup"><span data-stu-id="a6a73-115">Many of the functions and operations defined in this portion of the prelude are in the @"microsoft.quantum.intrinsic" namespace, such that most Q# source files will have an `open Microsoft.Quantum.Intrinsic;` directive immediately following the initial namespace declaration.</span></span>
<span data-ttu-id="a6a73-116">El <xref:Microsoft.Quantum.Core> espacio de nombres se abre automáticamente, por lo que las funciones como <xref:Microsoft.Quantum.Core.Length> se pueden usar sin una `open` instrucción.</span><span class="sxs-lookup"><span data-stu-id="a6a73-116">The <xref:Microsoft.Quantum.Core> namespace is automatically opened, so that functions such as <xref:Microsoft.Quantum.Core.Length> can be used without an `open` statement at all.</span></span>

### <a name="common-single-qubit-unitary-operations"></a><span data-ttu-id="a6a73-117">Operaciones de unitarios Single-Qubit comunes</span><span class="sxs-lookup"><span data-stu-id="a6a73-117">Common Single-Qubit Unitary Operations</span></span> ###

<span data-ttu-id="a6a73-118">El predefinido también define muchas [operaciones de qubit único](xref:microsoft.quantum.concepts.qubit#single-qubit-operations)comunes.</span><span class="sxs-lookup"><span data-stu-id="a6a73-118">The prelude also defines many common [single-qubit operations](xref:microsoft.quantum.concepts.qubit#single-qubit-operations).</span></span>
<span data-ttu-id="a6a73-119">Todas estas operaciones permiten tanto los `Controlled` como los `Adjoint` funcdores.</span><span class="sxs-lookup"><span data-stu-id="a6a73-119">All of these operations allow both the `Controlled` and `Adjoint` functors.</span></span>

#### <a name="pauli-operators"></a><span data-ttu-id="a6a73-120">Operadores Pauli</span><span class="sxs-lookup"><span data-stu-id="a6a73-120">Pauli Operators</span></span> ####

<span data-ttu-id="a6a73-121">La <xref:Microsoft.Quantum.Intrinsic.X> operación implementa el operador Pauli $X $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-121">The <xref:Microsoft.Quantum.Intrinsic.X> operation implements the Pauli $X$ operator.</span></span>
<span data-ttu-id="a6a73-122">A veces, esto también se conoce como la `NOT` puerta.</span><span class="sxs-lookup"><span data-stu-id="a6a73-122">This is sometimes also known as the `NOT` gate.</span></span>
<span data-ttu-id="a6a73-123">Tiene la firma `(Qubit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-123">It has signature `(Qubit => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="a6a73-124">Corresponde a la unitario de un solo qubit:</span><span class="sxs-lookup"><span data-stu-id="a6a73-124">It corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="a6a73-125">\begin{Equation} \begin{bmatrix} 0 & 1 \\ \\ % FIXME: actualmente utiliza la quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="a6a73-125">\begin{equation} \begin{bmatrix} 0 & 1 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="a6a73-126">1 & 0 \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="a6a73-126">1 & 0 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="a6a73-127">La <xref:Microsoft.Quantum.Intrinsic.Y> operación implementa el operador Pauli $Y $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-127">The <xref:Microsoft.Quantum.Intrinsic.Y> operation implements the Pauli $Y$ operator.</span></span>
<span data-ttu-id="a6a73-128">Tiene la firma `(Qubit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-128">It has signature `(Qubit => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="a6a73-129">Corresponde a la unitario de un solo qubit:</span><span class="sxs-lookup"><span data-stu-id="a6a73-129">It corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="a6a73-130">\begin{Equation} \begin{bmatrix} 0 &-i \\ \\ % FIXME: actualmente usa la quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="a6a73-130">\begin{equation} \begin{bmatrix} 0 & -i \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="a6a73-131">i & 0 \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="a6a73-131">i & 0 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="a6a73-132">La <xref:Microsoft.Quantum.Intrinsic.Z> operación implementa el operador Pauli $Z $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-132">The <xref:Microsoft.Quantum.Intrinsic.Z> operation implements the Pauli $Z$ operator.</span></span>
<span data-ttu-id="a6a73-133">Tiene la firma `(Qubit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-133">It has signature `(Qubit => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="a6a73-134">Corresponde a la unitario de un solo qubit:</span><span class="sxs-lookup"><span data-stu-id="a6a73-134">It corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="a6a73-135">\begin{Equation} \begin{bmatrix} 1 & 0 \\ \\ % FIXME: actualmente usa la quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="a6a73-135">\begin{equation} \begin{bmatrix} 1 & 0 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="a6a73-136">0 &-1 \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="a6a73-136">0 & -1 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="a6a73-137">A continuación se muestran estas transformaciones asignadas a la [esfera Bloch](xref:microsoft.quantum.concepts.qubit#visualizing-qubits-and-transformations-using-the-bloch-sphere) (el eje de giro de cada caso se resalta en rojo):</span><span class="sxs-lookup"><span data-stu-id="a6a73-137">Below we see these transformations mapped to the [Bloch sphere](xref:microsoft.quantum.concepts.qubit#visualizing-qubits-and-transformations-using-the-bloch-sphere) (the rotation axis in each case is highlighted red):</span></span>

![Pauli operaciones asignadas a la esfera Bloch](~/media/prelude_pauliBloch.png)

<span data-ttu-id="a6a73-139">Es importante tener en cuenta que la aplicación de la misma puerta Pauli dos veces al mismo qubit cancela la operación (porque ya ha realizado una rotación completa de 2π (360 °) sobre la superficie en la esfera Bloch, lo que llega al punto inicial).</span><span class="sxs-lookup"><span data-stu-id="a6a73-139">It is important to note that applying the same Pauli gate twice to the same qubit cancels out the operation (because you have now performed a full rotation of 2π (360°) over the surface to the Bloch Sphere, thus arriving back at the starting point).</span></span> <span data-ttu-id="a6a73-140">Esto nos lleva a la siguiente identidad:</span><span class="sxs-lookup"><span data-stu-id="a6a73-140">This brings us to the following identity:</span></span>

<span data-ttu-id="a6a73-141">$ $ X ^ 2 = Y ^ 2 = Z ^ 2 = \boldone $ $</span><span class="sxs-lookup"><span data-stu-id="a6a73-141">$$ X^2=Y^2=Z^2=\boldone $$</span></span>

<span data-ttu-id="a6a73-142">Esto se puede visualizar en la esfera Bloch:</span><span class="sxs-lookup"><span data-stu-id="a6a73-142">This can be visualised on the Bloch sphere:</span></span>

![XX = I](~/media/prelude_blochIdentity.png)

#### <a name="other-single-qubit-cliffords"></a><span data-ttu-id="a6a73-144">Otros Single-Qubit Cliffords</span><span class="sxs-lookup"><span data-stu-id="a6a73-144">Other Single-Qubit Cliffords</span></span> ####

<span data-ttu-id="a6a73-145">La <xref:Microsoft.Quantum.Intrinsic.H> operación implementa la puerta Hadamard.</span><span class="sxs-lookup"><span data-stu-id="a6a73-145">The <xref:Microsoft.Quantum.Intrinsic.H> operation implements the Hadamard gate.</span></span>
<span data-ttu-id="a6a73-146">Esto intercambia los ejes Pauli $X $ y $Z $ del qubit de destino, de modo que $H \ket {0} = \ket{+} \mathrel{: =} (\ket {0} + \ket {1} )/\sqrt {2} $ y $H \ket{+} = \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-146">This interchanges the Pauli $X$ and $Z$ axes of the target qubit, such that $H\ket{0} = \ket{+} \mathrel{:=} (\ket{0} + \ket{1}) / \sqrt{2}$ and $H\ket{+} = \ket{0}$.</span></span>
<span data-ttu-id="a6a73-147">Tiene la firma `(Qubit => Unit is Adj + Ctl)` y corresponde a la unitario de un solo qubit:</span><span class="sxs-lookup"><span data-stu-id="a6a73-147">It has signature `(Qubit => Unit is Adj + Ctl)`, and corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="a6a73-148">\begin{Equation} \frac {1} {\sqrt {2} } \begin{bmatrix} 1 & 1 \\ \\ % FIXME: actualmente usa el quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="a6a73-148">\begin{equation} \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="a6a73-149">1 &-1 \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="a6a73-149">1 & -1 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="a6a73-150">La puerta Hadamard es especialmente importante, ya que se puede usar para crear una superposición de los Estados $ \ket {0} $ y $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-150">The Hadamard gate is particularly important as it can be used to create a superposition of the $\ket{0}$ and $\ket{1}$ states.</span></span> <span data-ttu-id="a6a73-151">En la representación de la esfera Bloch, es más fácil pensar en esto como un giro de $ \ket{\psi} $ alrededor del eje x por $ \pi $ radianes ($ 180 ^ \circ $) seguido de un giro (en el sentido de las agujas del reloj) alrededor del eje y por $ \ pi/2 $ radianes ($ 90 ^ \circ $):</span><span class="sxs-lookup"><span data-stu-id="a6a73-151">In the Bloch sphere representation, it is easiest to think of this as a rotation of $\ket{\psi}$ around the x-axis by $\pi$ radians ($180^\circ$) followed by a (clockwise) rotation around the y-axis by $\pi/2$ radians ($90^\circ$):</span></span>

![Operación Hadamard asignada en la esfera Bloch](~/media/prelude_hadamardBloch.png)

<span data-ttu-id="a6a73-153">La <xref:Microsoft.Quantum.Intrinsic.S> operación implementa la puerta de fase $S $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-153">The <xref:Microsoft.Quantum.Intrinsic.S> operation implements the phase gate $S$.</span></span>
<span data-ttu-id="a6a73-154">Esta es la raíz cuadrada de la matriz de la operación Pauli $Z $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-154">This is the matrix square root of the Pauli $Z$ operation.</span></span>
<span data-ttu-id="a6a73-155">Es decir, $S ^ 2 = Z $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-155">That is, $S^2 = Z$.</span></span>
<span data-ttu-id="a6a73-156">Tiene la firma `(Qubit => Unit is Adj + Ctl)` y corresponde a la unitario de un solo qubit:</span><span class="sxs-lookup"><span data-stu-id="a6a73-156">It has signature `(Qubit => Unit is Adj + Ctl)`, and corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="a6a73-157">\begin{Equation} \begin{bmatrix} 1 & 0 \\ \\ % FIXME: actualmente usa la quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="a6a73-157">\begin{equation} \begin{bmatrix} 1 & 0 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="a6a73-158">0 & \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="a6a73-158">0 & i \end{bmatrix} \end{equation}</span></span>

#### <a name="rotations"></a><span data-ttu-id="a6a73-159">Rotaciones</span><span class="sxs-lookup"><span data-stu-id="a6a73-159">Rotations</span></span> ####

<span data-ttu-id="a6a73-160">Además de las operaciones Pauli y Clifford anteriores, el prepárrafo Q# proporciona diversas formas de expresar los giros.</span><span class="sxs-lookup"><span data-stu-id="a6a73-160">In addition to the Pauli and Clifford operations above, the Q# prelude provides a variety of ways of expressing rotations.</span></span>
<span data-ttu-id="a6a73-161">Tal y como se describe en [operaciones de un solo qubit](xref:microsoft.quantum.concepts.qubit#single-qubit-operations), la capacidad de rotar es fundamental para los algoritmos Quantum.</span><span class="sxs-lookup"><span data-stu-id="a6a73-161">As described in [single-qubit operations](xref:microsoft.quantum.concepts.qubit#single-qubit-operations), the ability to rotate is critical to quantum algorithms.</span></span>

<span data-ttu-id="a6a73-162">Empezamos por volver a llamar a que podemos expresar cualquier operación de un solo qubit con las $H $ y $T $ Gates, donde $H $ es la operación Hadamard y donde \begin{Equation} T \mathrel{: =} \begin{bmatrix} 1 & 0 \\ \\ % FIXME: actualmente utiliza la versión más actualizada de la cuádruple Whack hack.</span><span class="sxs-lookup"><span data-stu-id="a6a73-162">We start by recalling that we can express any single-qubit operation using the $H$ and $T$ gates, where $H$ is the Hadamard operation, and where \begin{equation} T \mathrel{:=} \begin{bmatrix} 1 & 0 \\\\ % FIXME: this currently uses the quad back whack hack.</span></span>
<span data-ttu-id="a6a73-163">0 & e ^ {i \pi/4} \end{bmatrix} \end{Equation} es la raíz cuadrada de la <xref:Microsoft.Quantum.Intrinsic.S> operación, de modo que $T ^ 2 = S $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-163">0 & e^{i \pi / 4} \end{bmatrix} \end{equation} This is the square root of the <xref:Microsoft.Quantum.Intrinsic.S> operation, such that $T^2 = S$.</span></span>
<span data-ttu-id="a6a73-164">A su vez, el $T $ Gate lo implementa la <xref:Microsoft.Quantum.Intrinsic.T> operación y tiene la firma `(Qubit => Unit is Adj + Ctl)` , lo que indica que se trata de una operación unitario en un solo qubit.</span><span class="sxs-lookup"><span data-stu-id="a6a73-164">The $T$ gate is in turn implemented by the <xref:Microsoft.Quantum.Intrinsic.T> operation, and has signature `(Qubit => Unit is Adj + Ctl)`, indicating that it is a unitary operation on a single-qubit.</span></span>

<span data-ttu-id="a6a73-165">Aunque esto es lo más adecuado para describir cualquier operación de un solo qubit arbitrario, las diferentes máquinas de destino pueden tener representaciones más eficaces para las rotaciones sobre los operadores de Pauli, de modo que el predicho incluye diversas maneras de convienently expresar tales giros.</span><span class="sxs-lookup"><span data-stu-id="a6a73-165">Even though this is in principle sufficient to describe any arbitrary single-qubit operation, different target machines may have more efficient representations for rotations about Pauli operators, such that the prelude includes a variety of ways to convienently express such rotations.</span></span>
<span data-ttu-id="a6a73-166">La más básica de esto es la <xref:Microsoft.Quantum.Intrinsic.R> operación, que implementa una rotación alrededor de un eje Pauli especificado, \Begin{Equation} R (\sigma, \phi) \mathrel{: =} \exp (-i \phi \sigma/2), \end{Equation} donde $ \sigma $ es un operador Pauli, $ \phi $ es un ángulo y donde $ \exp $ representa la matriz exponencial.</span><span class="sxs-lookup"><span data-stu-id="a6a73-166">The most basic of these is the <xref:Microsoft.Quantum.Intrinsic.R> operation, which implements a rotation around a specified Pauli axis, \begin{equation} R(\sigma, \phi) \mathrel{:=} \exp(-i \phi \sigma / 2), \end{equation} where $\sigma$ is a Pauli operator, $\phi$ is an angle, and where $\exp$ represents the matrix exponential.</span></span>
<span data-ttu-id="a6a73-167">Tiene una firma `((Pauli, Double, Qubit) => Unit is Adj + Ctl)` , donde las dos primeras partes de la entrada representan los argumentos clásicos $ \sigma $ y $ \phi $ necesarios para especificar el operador unitario $R (\sigma, \phi) $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-167">It has signature `((Pauli, Double, Qubit) => Unit is Adj + Ctl)`, where the first two parts of the input represent the classical arguments $\sigma$ and $\phi$ needed to specify the unitary operator $R(\sigma, \phi)$.</span></span>
<span data-ttu-id="a6a73-168">Podemos aplicar parcialmente $ \sigma $ y $ \phi $ para obtener una operación cuyo tipo sea el de una sola qubit unitario.</span><span class="sxs-lookup"><span data-stu-id="a6a73-168">We can partially apply $\sigma$ and $\phi$ to obtain an operation whose type is that of a single-qubit unitary.</span></span>
<span data-ttu-id="a6a73-169">Por ejemplo, `R(PauliZ, PI() / 4, _)` tiene el tipo `(Qubit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-169">For example, `R(PauliZ, PI() / 4, _)` has type `(Qubit => Unit is Adj + Ctl)`.</span></span>

> [!NOTE]
> <span data-ttu-id="a6a73-170">La <xref:Microsoft.Quantum.Intrinsic.R> operación divide el ángulo de entrada en 2 y lo multiplica por-1.</span><span class="sxs-lookup"><span data-stu-id="a6a73-170">The <xref:Microsoft.Quantum.Intrinsic.R> operation divides the input angle by 2 and multiplies it by -1.</span></span>
> <span data-ttu-id="a6a73-171">En el caso de los giros de $Z $, esto significa que $ \ket {0} $ eigenstate está girado por $-\phi/$2 y $ \ket {1} $ eigenstate se gira en $ \phi/$2, de modo que $ \ket $ {1} eigenstate gira en relación con $ \phi $ {0} \ket.</span><span class="sxs-lookup"><span data-stu-id="a6a73-171">For $Z$ rotations, this means that the $\ket{0}$ eigenstate is rotated by $-\phi / 2$ and the $\ket{1}$ eigenstate is rotated by $\phi / 2$, so that the $\ket{1}$ eigenstate is rotated by $\phi$ relative to the $\ket{0}$ eigenstate.</span></span>
>
> <span data-ttu-id="a6a73-172">En concreto, esto significa que `T` y `R(PauliZ, PI() / 8, _)` solo difieren en una [fase global](xref:microsoft.quantum.glossary#global-phase)irrelevante.</span><span class="sxs-lookup"><span data-stu-id="a6a73-172">In particular, this means that `T` and `R(PauliZ, PI() / 8, _)` differ only by an irrelevant [global phase](xref:microsoft.quantum.glossary#global-phase).</span></span>
> <span data-ttu-id="a6a73-173">Por esta razón, a veces $T $ se conoce como $ \frac{\pi} {8} $-Gate.</span><span class="sxs-lookup"><span data-stu-id="a6a73-173">For this reason, $T$ is sometimes known as the $\frac{\pi}{8}$-gate.</span></span>
>
> <span data-ttu-id="a6a73-174">Tenga en cuenta también que `PauliI` la rotación solo aplica una fase global de $ \phi/$2.</span><span class="sxs-lookup"><span data-stu-id="a6a73-174">Note also that rotating around `PauliI` simply applies a global phase of $\phi / 2$.</span></span> <span data-ttu-id="a6a73-175">Aunque estas fases son irrelevantes, como se argumenta en [los documentos conceptuales](xref:microsoft.quantum.concepts.qubit), son relevantes para las `PauliI` rotaciones controladas.</span><span class="sxs-lookup"><span data-stu-id="a6a73-175">While such phases are irrelevant, as argued in [the conceptual documents](xref:microsoft.quantum.concepts.qubit), they are relevant for controlled `PauliI` rotations.</span></span>

<span data-ttu-id="a6a73-176">Dentro de los algoritmos Quantum, a menudo resulta útil expresar giros como fracciones de Dyadic, como $ \phi = \pi k/2 ^ n $ para algunos $k \en \mathbb{Z} $ y $n \en \mathbb{N} $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-176">Within quantum algorithms, it is often useful to express rotations as dyadic fractions, such that $\phi = \pi k / 2^n$ for some $k \in \mathbb{Z}$ and $n \in \mathbb{N}$.</span></span>
<span data-ttu-id="a6a73-177">La <xref:Microsoft.Quantum.Intrinsic.RFrac> operación implementa una rotación alrededor de un eje Pauli especificado mediante esta Convención.</span><span class="sxs-lookup"><span data-stu-id="a6a73-177">The <xref:Microsoft.Quantum.Intrinsic.RFrac> operation implements a rotation around a specified Pauli axis using this convention.</span></span>
<span data-ttu-id="a6a73-178">Se diferencia de <xref:Microsoft.Quantum.Intrinsic.R> en que el ángulo de rotación se especifica como dos entradas de tipo `Int` , que se interpretan como una fracción Dyadic.</span><span class="sxs-lookup"><span data-stu-id="a6a73-178">It differs from <xref:Microsoft.Quantum.Intrinsic.R> in that the rotation angle is specified as two inputs of type `Int`, interpreted as a dyadic fraction.</span></span>
<span data-ttu-id="a6a73-179">Por lo tanto, `RFrac` tiene Signature `((Pauli, Int, Int, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-179">Thus, `RFrac` has signature `((Pauli, Int, Int, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="a6a73-180">Implementa el qubit unitario $ \exp (i \pi k \sigma/2 ^ n) $, donde $ \sigma $ es la matriz de Pauli correspondiente al primer argumento, $k $ es el segundo argumento y $n $ es el tercer argumento.</span><span class="sxs-lookup"><span data-stu-id="a6a73-180">It implements the single-qubit unitary $\exp(i \pi k \sigma / 2^n)$, where $\sigma$ is the Pauli matrix corresponding to the first argument, $k$ is the second argument, and $n$ is the third argument.</span></span>
<span data-ttu-id="a6a73-181">`RFrac(_,k,n,_)` es igual que `R(_,-πk/2^n,_)` ; tenga en cuenta que el ángulo es el *negativo* de la fracción.</span><span class="sxs-lookup"><span data-stu-id="a6a73-181">`RFrac(_,k,n,_)` is the same as `R(_,-πk/2^n,_)`; note that the angle is the *negative* of the fraction.</span></span>

<span data-ttu-id="a6a73-182">La <xref:Microsoft.Quantum.Intrinsic.Rx> operación implementa un giro alrededor del Pauli $X $ Axis.</span><span class="sxs-lookup"><span data-stu-id="a6a73-182">The <xref:Microsoft.Quantum.Intrinsic.Rx> operation implements a rotation around the Pauli $X$ axis.</span></span>
<span data-ttu-id="a6a73-183">Tiene la firma `((Double, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-183">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="a6a73-184">`Rx(_, _)` es igual que `R(PauliX, _, _)`.</span><span class="sxs-lookup"><span data-stu-id="a6a73-184">`Rx(_, _)` is the same as `R(PauliX, _, _)`.</span></span>

<span data-ttu-id="a6a73-185">La <xref:Microsoft.Quantum.Intrinsic.Ry> operación implementa un giro alrededor del Pauli $Y $ Axis.</span><span class="sxs-lookup"><span data-stu-id="a6a73-185">The <xref:Microsoft.Quantum.Intrinsic.Ry> operation implements a rotation around the Pauli $Y$ axis.</span></span>
<span data-ttu-id="a6a73-186">Tiene la firma `((Double, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-186">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="a6a73-187">`Ry(_, _)` es igual que `R(PauliY,_ , _)`.</span><span class="sxs-lookup"><span data-stu-id="a6a73-187">`Ry(_, _)` is the same as `R(PauliY,_ , _)`.</span></span>

<span data-ttu-id="a6a73-188">La <xref:Microsoft.Quantum.Intrinsic.Rz> operación implementa un giro alrededor del Pauli $Z $ axis.</span><span class="sxs-lookup"><span data-stu-id="a6a73-188">The <xref:Microsoft.Quantum.Intrinsic.Rz> operation implements a rotation around the Pauli $Z$ axis.</span></span>
<span data-ttu-id="a6a73-189">Tiene la firma `((Double, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-189">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="a6a73-190">`Rz(_, _)` es igual que `R(PauliZ, _, _)`.</span><span class="sxs-lookup"><span data-stu-id="a6a73-190">`Rz(_, _)` is the same as `R(PauliZ, _, _)`.</span></span>

<span data-ttu-id="a6a73-191">La <xref:Microsoft.Quantum.Intrinsic.R1> operación implementa una rotación en la cantidad determinada alrededor de $ \ket {1} $, el eigenstate de $-$1 de $Z $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-191">The <xref:Microsoft.Quantum.Intrinsic.R1> operation implements a rotation by the given amount around $\ket{1}$, the $-1$ eigenstate of $Z$.</span></span>
<span data-ttu-id="a6a73-192">Tiene la firma `((Double, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-192">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="a6a73-193">`R1(phi,_)` es igual que `R(PauliZ,phi,_)` seguido de `R(PauliI,-phi,_)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-193">`R1(phi,_)` is the same as `R(PauliZ,phi,_)` followed by `R(PauliI,-phi,_)`.</span></span>

<span data-ttu-id="a6a73-194">La <xref:Microsoft.Quantum.Intrinsic.R1Frac> operación implementa una rotación fraccionaria en la cantidad determinada alrededor de la Z = 1 eigenstate.</span><span class="sxs-lookup"><span data-stu-id="a6a73-194">The <xref:Microsoft.Quantum.Intrinsic.R1Frac> operation implements a fractional rotation by the given amount around the Z=1 eigenstate.</span></span>
<span data-ttu-id="a6a73-195">Tiene la firma `((Int,Int, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-195">It has signature `((Int,Int, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="a6a73-196">`R1Frac(k,n,_)` es igual que `RFrac(PauliZ,-k.n+1,_)` seguido de `RFrac(PauliI,k,n+1,_)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-196">`R1Frac(k,n,_)` is the same as `RFrac(PauliZ,-k.n+1,_)` followed by `RFrac(PauliI,k,n+1,_)`.</span></span>

<span data-ttu-id="a6a73-197">A continuación se muestra un ejemplo de una operación de giro (alrededor del Pauli $Z $ axis, en esta instancia) asignada en la esfera Bloch:</span><span class="sxs-lookup"><span data-stu-id="a6a73-197">An example of a rotation operation (around the Pauli $Z$ axis, in this instance) mapped onto the Bloch sphere is shown below:</span></span>

![Operación de rotación asignada en la esfera Bloch](~/media/prelude_rotationBloch.png)

#### <a name="multi-qubit-operations"></a><span data-ttu-id="a6a73-199">Operaciones de qubit múltiple</span><span class="sxs-lookup"><span data-stu-id="a6a73-199">Multi-Qubit Operations</span></span> ####

<span data-ttu-id="a6a73-200">Además de las operaciones de un solo qubit, el predicho también define varias operaciones de varios qubit.</span><span class="sxs-lookup"><span data-stu-id="a6a73-200">In addition to the single-qubit operations above, the prelude also defines several multi-qubit operations.</span></span>

<span data-ttu-id="a6a73-201">En primer lugar, la <xref:Microsoft.Quantum.Intrinsic.CNOT> operación realiza una puerta controlada estándar `NOT` , \begin{Equation} \operatorname{CNOT} \mathrel{: =} \begin{bmatrix} 1 & 0 & 0 & 0 \\ \\ 0 & 1 & 0 & 0 \\ \\ 0 & 0 & 0 & 1 \\ \\ 0 & 0 & 1 & 0 \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="a6a73-201">First, the <xref:Microsoft.Quantum.Intrinsic.CNOT> operation performs a standard controlled-`NOT` gate, \begin{equation} \operatorname{CNOT} \mathrel{:=} \begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 0 \end{bmatrix}.</span></span>
<span data-ttu-id="a6a73-202">\end{Equation} tiene una firma `((Qubit, Qubit) => Unit is Adj + Ctl)` que representa que $ \operatorname{CNOT} $ actúa unitarily en dos qubits individuales.</span><span class="sxs-lookup"><span data-stu-id="a6a73-202">\end{equation} It has signature `((Qubit, Qubit) => Unit is Adj + Ctl)`, representing that $\operatorname{CNOT}$ acts unitarily on two individual qubits.</span></span>
<span data-ttu-id="a6a73-203">`CNOT(q1, q2)` es igual que `(Controlled X)([q1], q2)`.</span><span class="sxs-lookup"><span data-stu-id="a6a73-203">`CNOT(q1, q2)` is the same as `(Controlled X)([q1], q2)`.</span></span>
<span data-ttu-id="a6a73-204">Dado que el `Controlled` functor permite controlar en un registro, usamos el literal de matriz `[q1]` para indicar que queremos solo el control.</span><span class="sxs-lookup"><span data-stu-id="a6a73-204">Since the `Controlled` functor allows for controlling on a register, we use the array literal `[q1]` to indicate that we want only the one control.</span></span>

<span data-ttu-id="a6a73-205">La <xref:Microsoft.Quantum.Intrinsic.CCNOT> operación realiza un control no controlado de doble control, a veces también conocido como la puerta Toffoli.</span><span class="sxs-lookup"><span data-stu-id="a6a73-205">The <xref:Microsoft.Quantum.Intrinsic.CCNOT> operation performs doubly-controlled NOT gate, sometimes also known as the Toffoli gate.</span></span>
<span data-ttu-id="a6a73-206">Tiene la firma `((Qubit, Qubit, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-206">It has signature `((Qubit, Qubit, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="a6a73-207">`CCNOT(q1, q2, q3)` es igual que `(Controlled X)([q1, q2], q3)`.</span><span class="sxs-lookup"><span data-stu-id="a6a73-207">`CCNOT(q1, q2, q3)` is the same as `(Controlled X)([q1, q2], q3)`.</span></span>

<span data-ttu-id="a6a73-208">La <xref:Microsoft.Quantum.Intrinsic.SWAP> operación intercambia los Estados de Quantum de dos qubits.</span><span class="sxs-lookup"><span data-stu-id="a6a73-208">The <xref:Microsoft.Quantum.Intrinsic.SWAP> operation swaps the quantum states of two qubits.</span></span>
<span data-ttu-id="a6a73-209">Es decir, implementa la matriz unitario \begin{Equation} \operatorname{SWAP} \mathrel{: =} \begin{bmatrix} 1 & 0 & 0 & 0 \\ \\ 0 & 0 & 1 & 0 \\ \\ 0 & 1 & 0 & 0 \\ \\ 0 & 0 & 0 & 1 \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="a6a73-209">That is, it implements the unitary matrix \begin{equation} \operatorname{SWAP} \mathrel{:=} \begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \end{bmatrix}.</span></span>
<span data-ttu-id="a6a73-210">\end{Equation} tiene una firma `((Qubit, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-210">\end{equation} It has signature `((Qubit, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="a6a73-211">`SWAP(q1,q2)` es equivalente a `CNOT(q1, q2)` seguido de `CNOT(q2, q1)` y después de `CNOT(q1, q2)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-211">`SWAP(q1,q2)` is equivalent to `CNOT(q1, q2)` followed by `CNOT(q2, q1)` and then `CNOT(q1, q2)`.</span></span>

> [!NOTE]
> <span data-ttu-id="a6a73-212">La puerta de intercambio *no* es lo mismo que reorganizar los elementos de una variable con el tipo `Qubit[]` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-212">The SWAP gate is *not* the same as rearranging the elements of a variable with type `Qubit[]`.</span></span>
> <span data-ttu-id="a6a73-213">La aplicación `SWAP(q1, q2)` de produce un cambio en el estado de qubits al que hace referencia `q1` y `q2` , mientras que `let swappedRegister = [q2, q1];` solo afecta a cómo hacemos referencia a esos qubits.</span><span class="sxs-lookup"><span data-stu-id="a6a73-213">Applying `SWAP(q1, q2)` causes a change to the state of the qubits referred to by `q1` and `q2`, while `let swappedRegister = [q2, q1];` only affects how we refer to those qubits.</span></span>
> <span data-ttu-id="a6a73-214">Además, `(Controlled SWAP)([q0], (q1, q2))` permite `SWAP` que se ordene en el estado de un tercer qubit, que no se puede representar mediante la reorganización de los elementos.</span><span class="sxs-lookup"><span data-stu-id="a6a73-214">Moreover, `(Controlled SWAP)([q0], (q1, q2))` allows for `SWAP` to be conditioned on the state of a third qubit, which we cannot represent by rearranging elements.</span></span>
> <span data-ttu-id="a6a73-215">La puerta de intercambio controlado, también conocida como la puerta Fredkin, es lo suficientemente eficaz como para incluir todo el cálculo clásico.</span><span class="sxs-lookup"><span data-stu-id="a6a73-215">The controlled-SWAP gate, also known as the Fredkin gate, is powerful enough to include all classical computation.</span></span>

<span data-ttu-id="a6a73-216">Por último, el predicho proporciona dos operaciones para representar los exponenciales de los operadores de Pauli de varios qubit.</span><span class="sxs-lookup"><span data-stu-id="a6a73-216">Finally, the prelude provides two operations for representing exponentials of multi-qubit Pauli operators.</span></span>
<span data-ttu-id="a6a73-217">La <xref:Microsoft.Quantum.Intrinsic.Exp> operación realiza una rotación basada en un producto tensores de matrices Pauli, tal como se representa en la qubit unitario \Begin{Equation} \operatorname{exp} (\vec{\sigma}, \phi) \mathrel{: =} \exp\left (i \phi \ sigma_0 \otimes \ sigma_1 \otimes \cdots \otimes \ sigma_n \right), \end{Equation} donde $ \vec{\sigma} = (\ sigma_0, \ sigma_1, \dots, \ sigma_n) $ es una secuencia de operadores qubit de Pauli y donde $ \phi $ es un ángulo.</span><span class="sxs-lookup"><span data-stu-id="a6a73-217">The <xref:Microsoft.Quantum.Intrinsic.Exp> operation performs a rotation based on a tensor product of Pauli matrices, as represented by the multi-qubit unitary \begin{equation} \operatorname{Exp}(\vec{\sigma}, \phi) \mathrel{:=} \exp\left(i \phi \sigma_0 \otimes \sigma_1 \otimes \cdots \otimes \sigma_n \right), \end{equation} where $\vec{\sigma} = (\sigma_0, \sigma_1, \dots, \sigma_n)$ is a sequence of single-qubit Pauli operators, and where $\phi$ is an angle.</span></span>
<span data-ttu-id="a6a73-218">La `Exp` rotación representa $ \vec{\sigma} $ como una matriz de `Pauli` elementos, de modo que tiene la firma `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-218">The `Exp` rotation represents $\vec{\sigma}$ as an array of `Pauli` elements, such that it has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span>

<span data-ttu-id="a6a73-219">La <xref:Microsoft.Quantum.Intrinsic.ExpFrac> operación realiza la misma rotación mediante la notación de fracción Dyadic descrita anteriormente.</span><span class="sxs-lookup"><span data-stu-id="a6a73-219">The <xref:Microsoft.Quantum.Intrinsic.ExpFrac> operation performs the same rotation, using the dyadic fraction notation discussed above.</span></span>
<span data-ttu-id="a6a73-220">Tiene la firma `((Pauli[], Int, Int, Qubit[]) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-220">It has signature `((Pauli[], Int, Int, Qubit[]) => Unit is Adj + Ctl)`.</span></span>

> [!WARNING]
> <span data-ttu-id="a6a73-221">Los exponenciales del producto tensores de los operadores Pauli no son los mismos que los de tensores los de los operadores exponencial de Pauli.</span><span class="sxs-lookup"><span data-stu-id="a6a73-221">Exponentials of the tensor product of Pauli operators are not the same as tensor products of the exponentials of Pauli operators.</span></span>
> <span data-ttu-id="a6a73-222">Es decir, $e ^ {i (Z \otimes Z) \phi} \ne e ^ {i Z \phi} \otimes e ^ {i Z \phi} $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-222">That is, $e^{i (Z \otimes Z) \phi} \ne e^{i Z \phi} \otimes e^{i Z \phi}$.</span></span>

### <a name="measurements"></a><span data-ttu-id="a6a73-223">Medidas</span><span class="sxs-lookup"><span data-stu-id="a6a73-223">Measurements</span></span> ###

<span data-ttu-id="a6a73-224">Al medir, el eigenvalue + 1 del operador que se está midiendo corresponde a un `Zero` resultado y el-1 eigenvalue a un `One` resultado.</span><span class="sxs-lookup"><span data-stu-id="a6a73-224">When measuring, the +1 eigenvalue of the operator being measured corresponds to a `Zero` result, and the -1 eigenvalue to a `One` result.</span></span>

> [!NOTE]
> <span data-ttu-id="a6a73-225">Aunque esta Convención podría parecer extraña, tiene dos ventajas muy ventajosas.</span><span class="sxs-lookup"><span data-stu-id="a6a73-225">While this convention might seem odd, it has two very nice advantages.</span></span>
> <span data-ttu-id="a6a73-226">En primer lugar, la observación del resultado $ \ket {0} $ se representa mediante el `Result` valor `Zero` , mientras que la observación de $ \ket {1} $ corresponde a `One` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-226">First, observing the outcome $\ket{0}$ is represented by the `Result` value `Zero`, while observing $\ket{1}$ corresponds to `One`.</span></span>
> <span data-ttu-id="a6a73-227">En segundo lugar, podemos escribir que el eigenvalue $ \lambda $ correspondiente a un resultado $r $ es $ \lambda = (-1) ^ r $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-227">Second, we can write out that the eigenvalue $\lambda$ corresponding to a result $r$ is $\lambda = (-1)^r$.</span></span>

<span data-ttu-id="a6a73-228">Las operaciones de medición no admiten `Adjoint` ni el `Controlled` functor.</span><span class="sxs-lookup"><span data-stu-id="a6a73-228">Measurement operations support neither the `Adjoint` nor the `Controlled` functor.</span></span>

<span data-ttu-id="a6a73-229">La <xref:Microsoft.Quantum.Intrinsic.Measure> operación realiza una medición conjunta de uno o más qubits en el producto especificado de los operadores Pauli.</span><span class="sxs-lookup"><span data-stu-id="a6a73-229">The <xref:Microsoft.Quantum.Intrinsic.Measure> operation performs a joint measurement of one or more qubits in the specified product of Pauli operators.</span></span>
<span data-ttu-id="a6a73-230">Si la matriz Pauli y la matriz qubit tienen longitudes diferentes, se produce un error en la operación.</span><span class="sxs-lookup"><span data-stu-id="a6a73-230">If the Pauli array and qubit array are different lengths, then the operation fails.</span></span>
<span data-ttu-id="a6a73-231">`Measure` tiene una firma `((Pauli[], Qubit[]) => Result)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-231">`Measure` has signature `((Pauli[], Qubit[]) => Result)`.</span></span>

<span data-ttu-id="a6a73-232">Tenga en cuenta que una medida conjunta no es lo mismo que medir cada qubit individualmente.</span><span class="sxs-lookup"><span data-stu-id="a6a73-232">Note that a joint measurement is not the same as measuring each qubit individually.</span></span>
<span data-ttu-id="a6a73-233">Por ejemplo, considere el estado $ \ket {11} = \ket {1} \otimes \Ket {1} = X\otimes X \ket {00} $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-233">For example, consider the state $\ket{11} = \ket{1} \otimes \ket{1} = X\otimes X \ket{00}$.</span></span>
<span data-ttu-id="a6a73-234">Al medir $Z _0 $ y $Z _ 1 _ cada uno individualmente, obtenemos los resultados $r _0 = $1 y $r _ 1 = $1.</span><span class="sxs-lookup"><span data-stu-id="a6a73-234">Measuring $Z_0$ and $Z_1$ each individually, we get the results $r_0 = 1$ and $r_1 = 1$.</span></span>
<span data-ttu-id="a6a73-235">Al medir $Z _0 Z_1 $, se obtiene el resultado único $r _ {\textrm{Joint}} = $0, que representa que la pareja de $ \ket {11} $ es positiva.</span><span class="sxs-lookup"><span data-stu-id="a6a73-235">Measuring $Z_0 Z_1$, however, we get the single result $r_{\textrm{joint}} = 0$, representing that the pairity of $\ket{11}$ is positive.</span></span>
<span data-ttu-id="a6a73-236">Se colocan de forma diferente, $ (-1) ^ {r_0 + r_1} = (-1) ^ r_ {\textrm{Joint}}) $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-236">Put differently, $(-1)^{r_0 + r_1} = (-1)^r_{\textrm{joint}})$.</span></span>
<span data-ttu-id="a6a73-237">De forma crítica, dado que *solo* se aprende la paridad a partir de esta medida, se conserva toda la información de Quantum representada en la superposición entre los Estados 2 2-qubit de paridad positiva, $ \ket {00} $ y $ \ket {11} $.</span><span class="sxs-lookup"><span data-stu-id="a6a73-237">Critically, since we *only* learn the parity from this measurement, any quantum information represented in the superposition between the two two-qubit states of positive parity, $\ket{00}$ and $\ket{11}$, is preserved.</span></span>
<span data-ttu-id="a6a73-238">Esta propiedad será esencial más adelante, ya que se describe la corrección de errores.</span><span class="sxs-lookup"><span data-stu-id="a6a73-238">This property will be essential later, as we discuss error correction.</span></span>

<span data-ttu-id="a6a73-239">Para mayor comodidad, el predicho también proporciona otras dos operaciones para medir qubits.</span><span class="sxs-lookup"><span data-stu-id="a6a73-239">For convenience, the prelude also provides two other operations for measuring qubits.</span></span>
<span data-ttu-id="a6a73-240">En primer lugar, dado que la realización de medidas de un solo qubit es bastante común, el pre define una abreviatura para este caso.</span><span class="sxs-lookup"><span data-stu-id="a6a73-240">First, since performing single-qubit measurements is quite common, the prelude defines a shorthand for this case.</span></span>
<span data-ttu-id="a6a73-241">La <xref:Microsoft.Quantum.Intrinsic.M> operación mide el operador Pauli $Z $ en un solo qubit y tiene Signature `(Qubit => Result)` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-241">The <xref:Microsoft.Quantum.Intrinsic.M> operation measures the Pauli $Z$ operator on a single qubit, and has signature `(Qubit => Result)`.</span></span>
<span data-ttu-id="a6a73-242">`M(q)` equivale a `Measure([PauliZ], [q])`.</span><span class="sxs-lookup"><span data-stu-id="a6a73-242">`M(q)` is equivalent to `Measure([PauliZ], [q])`.</span></span>

<span data-ttu-id="a6a73-243"><xref:Microsoft.Quantum.Measurement.MultiM>Mide el operador Pauli $Z $ *por separado* en cada una de las matrices de qubits, devolviendo la *matriz* de `Result` valores obtenidos para cada qubit.</span><span class="sxs-lookup"><span data-stu-id="a6a73-243">The <xref:Microsoft.Quantum.Measurement.MultiM> measures the Pauli $Z$ operator *separately* on each of an array of qubits, returning the *array* of `Result` values obtained for each qubit.</span></span>
<span data-ttu-id="a6a73-244">En algunos casos, esto se puede optimizar.</span><span class="sxs-lookup"><span data-stu-id="a6a73-244">In some cases this can be optimized.</span></span> <span data-ttu-id="a6a73-245">Tiene Signature ( `Qubit[] => Result[])` .</span><span class="sxs-lookup"><span data-stu-id="a6a73-245">It has signature (`Qubit[] => Result[])`.</span></span>
<span data-ttu-id="a6a73-246">`MultiM(qs)` es equivalente a:</span><span class="sxs-lookup"><span data-stu-id="a6a73-246">`MultiM(qs)` is equivalent to:</span></span>

```qsharp
mutable rs = new Result[Length(qs)];
for (index in 0..Length(qs)-1)
{
    set rs[index] = M(qs[index]);
}
return rs;
```

## <a name="extension-functions-and-operations"></a><span data-ttu-id="a6a73-247">Funciones y operaciones de extensión</span><span class="sxs-lookup"><span data-stu-id="a6a73-247">Extension Functions and Operations</span></span> ##

<span data-ttu-id="a6a73-248">Además, el pretexto define un amplio conjunto de funciones matemáticas y de conversión de tipos en el nivel de .NET para su uso en el Q# código.</span><span class="sxs-lookup"><span data-stu-id="a6a73-248">In addition, the prelude defines a rich set of mathematical and type conversion functions at the .NET level for use within Q# code.</span></span>
<span data-ttu-id="a6a73-249">Por ejemplo, el <xref:Microsoft.Quantum.Math> espacio de nombres define operaciones útiles como <xref:Microsoft.Quantum.Math.Sin> y <xref:Microsoft.Quantum.Math.Log> .</span><span class="sxs-lookup"><span data-stu-id="a6a73-249">For instance, the <xref:Microsoft.Quantum.Math> namespace defines useful operations such as <xref:Microsoft.Quantum.Math.Sin> and <xref:Microsoft.Quantum.Math.Log>.</span></span>
<span data-ttu-id="a6a73-250">La implementación proporcionada por el kit de desarrollo de Quantum usa la biblioteca de clases base de .NET clásica y, por lo tanto, puede implicar un viaje de ida y vuelta de comunicaciones adicional entre programas Quantum y sus controladores clásico.</span><span class="sxs-lookup"><span data-stu-id="a6a73-250">The implementation provided by the Quantum Development Kit uses the classical .NET base class library, and thus may involve an additional communications round trip between quantum programs and their classical drivers.</span></span>
<span data-ttu-id="a6a73-251">Aunque esto no presenta un problema para un simulador local, puede tratarse de un problema de rendimiento al usar un simulador remoto o un hardware real como equipo de destino.</span><span class="sxs-lookup"><span data-stu-id="a6a73-251">While this does not present a problem for a local simulator, this can be a performance issue when using a remote simulator or actual hardware as a target machine.</span></span>
<span data-ttu-id="a6a73-252">Dicho esto, una máquina de destino individual puede mitigar este impacto en el rendimiento invalidando estas operaciones con versiones más eficaces para ese sistema en particular.</span><span class="sxs-lookup"><span data-stu-id="a6a73-252">That said, an individual target machine may mitigate this performance impact by overriding these operations with versions that are more efficient for that particular system.</span></span>

### <a name="math"></a><span data-ttu-id="a6a73-253">Matemáticas</span><span class="sxs-lookup"><span data-stu-id="a6a73-253">Math</span></span> ###

<span data-ttu-id="a6a73-254">El <xref:Microsoft.Quantum.Math> espacio de nombres proporciona muchas funciones útiles de la [ `System.Math` clase](https://docs.microsoft.com/dotnet/api/system.math?view=netframework-4.7.1&preserve-view=true)de la biblioteca de clases base de .net.</span><span class="sxs-lookup"><span data-stu-id="a6a73-254">The <xref:Microsoft.Quantum.Math> namespace provides many useful functions from the .NET base class library's [`System.Math` class](https://docs.microsoft.com/dotnet/api/system.math?view=netframework-4.7.1&preserve-view=true).</span></span>
<span data-ttu-id="a6a73-255">Estas funciones se pueden usar de la misma manera que cualquier otra Q# función:</span><span class="sxs-lookup"><span data-stu-id="a6a73-255">These functions can be used in the same manner as any other Q# functions:</span></span>

```qsharp
open Microsoft.Quantum.Math;
// ...
let y = Sin(theta);
```

<span data-ttu-id="a6a73-256">Cuando un método estático de .NET se ha sobrecargado según el tipo de sus argumentos, la Q# función correspondiente se anota con un sufijo que indica el tipo de su entrada:</span><span class="sxs-lookup"><span data-stu-id="a6a73-256">Where a .NET static method has been overloaded based on the type of its arguments, the corresponding Q# function is annotated with a suffix indicating the type of its input:</span></span>

```qsharp
let x = AbsI(-3); // x : Int = 3
let y = AbsD(-PI()); // y : Double = 3.1415...
```


### <a name="bitwise-operations"></a><span data-ttu-id="a6a73-257">Operaciones bit a bit</span><span class="sxs-lookup"><span data-stu-id="a6a73-257">Bitwise Operations</span></span> ###

<span data-ttu-id="a6a73-258">Por último, el <xref:Microsoft.Quantum.Bitwise> espacio de nombres proporciona varias funciones útiles para manipular enteros a través de operadores bit a bit.</span><span class="sxs-lookup"><span data-stu-id="a6a73-258">Finally, the <xref:Microsoft.Quantum.Bitwise> namespace provides several useful functions for manipulating integers through bitwise operators.</span></span>
<span data-ttu-id="a6a73-259">Por ejemplo, <xref:Microsoft.Quantum.Bitwise.Parity> devuelve la paridad bit a bit de un entero como otro entero.</span><span class="sxs-lookup"><span data-stu-id="a6a73-259">For instance, <xref:Microsoft.Quantum.Bitwise.Parity> returns the bitwise parity of an integer as another integer.</span></span>
