---
title: Caracterización y estadísticas de Quantum
description: Obtenga información sobre cómo se usan las estadísticas de medida de las estimaciones de fase para calcular los valores de resultado en la programación de Quantum.
author: bradben
uid: microsoft.quantum.libraries.characterization
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- Q#
- $$v
ms.openlocfilehash: 72af3f5517b272d6d8159b158103b5af91d266b5
ms.sourcegitcommit: c48cdafccb3487bf93d67fa80cdc64768445b691
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/06/2021
ms.locfileid: "97940893"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="02227-103">Caracterización y estadísticas de Quantum</span><span class="sxs-lookup"><span data-stu-id="02227-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="02227-104">Es fundamental poder caracterizar los efectos de las operaciones para desarrollar algoritmos Quantum útiles.</span><span class="sxs-lookup"><span data-stu-id="02227-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="02227-105">Esto supone un reto porque cada medida de un sistema Quantum produce como máximo un bit de información.</span><span class="sxs-lookup"><span data-stu-id="02227-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="02227-106">Con el fin de aprender un eigenvalue, es decir, un estado Quantum, los resultados de muchas medidas se deben unir para que el usuario pueda recopilar los numerosos bits de información necesarios para representar estos conceptos.</span><span class="sxs-lookup"><span data-stu-id="02227-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="02227-107">Los Estados de Quantum son especialmente vexing porque el [teorema sin clonación](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) indica que no hay ninguna manera de aprender un estado de Quantum arbitrario desde una sola copia del estado, ya que esto le permitirá realizar copias del estado.</span><span class="sxs-lookup"><span data-stu-id="02227-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="02227-108">Esta ofuscación del estado de cuanto del usuario se refleja en el hecho de que Q# no expone ni incluso define lo que *es* un estado para los programas Quantum.</span><span class="sxs-lookup"><span data-stu-id="02227-108">This obfuscation of the quantum state from the user is reflected in the fact that Q# does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="02227-109">Por tanto, el enfoque de la caracterización de Quantum consiste en tratar las operaciones y los Estados como Black-Box. Este enfoque comparte mucho en común con la práctica experimental de caracterización, comprobación y validación de Quantum (QCVV).</span><span class="sxs-lookup"><span data-stu-id="02227-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="02227-110">La caracterización es distinta de muchas de las otras bibliotecas descritas anteriormente.</span><span class="sxs-lookup"><span data-stu-id="02227-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="02227-111">El objetivo aquí es menos aprender información clásica sobre el sistema, en lugar de realizar una transformación de unitarios en un vector de estado.</span><span class="sxs-lookup"><span data-stu-id="02227-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="02227-112">Por lo tanto, estas bibliotecas deben mezclar el procesamiento de la información clásica y Quantum.</span><span class="sxs-lookup"><span data-stu-id="02227-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="02227-113">Estimación de fases iterativas</span><span class="sxs-lookup"><span data-stu-id="02227-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="02227-114">La visualización de la programación Quantum en términos de caracterización de Quantum sugiere una alternativa útil a la estimación de la fase Quantum.</span><span class="sxs-lookup"><span data-stu-id="02227-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="02227-115">Es decir, en lugar de preparar una $n registro $-qubit para que contenga una representación binaria de la fase como en la estimación de la fase Quantum, podemos ver la estimación de la fase como el proceso por el que un agente *clásico* aprende las propiedades de un sistema Quantum a través de las mediciones.</span><span class="sxs-lookup"><span data-stu-id="02227-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="02227-116">Continuaremos como en el caso de Quantum mediante la fase Kickback para convertir las aplicaciones de una operación de caja negra en rotaciones por un ángulo desconocido, pero medirá el qubit de ancilla que giramos en cada paso inmediatamente después de la rotación.</span><span class="sxs-lookup"><span data-stu-id="02227-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="02227-117">Esto tiene la ventaja de que solo se requiere una sola qubit adicional para realizar la fase Kickback que se describe en el caso de Quantum, ya que a continuación se aprende la fase de los resultados de la medición en cada paso de forma iterativa.</span><span class="sxs-lookup"><span data-stu-id="02227-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="02227-118">Cada uno de los métodos que se propone a continuación usa una estrategia diferente para diseñar experimentos y métodos de procesamiento de datos diferentes para aprender la fase.</span><span class="sxs-lookup"><span data-stu-id="02227-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="02227-119">Cada una de ellas tiene una ventaja exclusiva que abarca desde la existencia de rigurosos límites de errores hasta la capacidad de incorporar información anterior, tolerar errores o ejecutarse en la memoria limitted los equipos clásico.</span><span class="sxs-lookup"><span data-stu-id="02227-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="02227-120">En la explicación de la estimación de la fase iterativa, se considerará una $U unitario $ como una operación de caja negra.</span><span class="sxs-lookup"><span data-stu-id="02227-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="02227-121">Como se describe en la sección sobre Oracle en las [estructuras de datos](xref:microsoft.quantum.libraries.data-structures), los modelos de Canon, Q# tales como las operaciones, por el <xref:Microsoft.Quantum.Oracles.DiscreteOracle> tipo definido por el usuario, definidas por el tipo de tupla `((Int, Qubit[]) => Unit : Adjoint, Controlled)` .</span><span class="sxs-lookup"><span data-stu-id="02227-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the Q# canon models such operations by the <xref:Microsoft.Quantum.Oracles.DiscreteOracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="02227-122">Concretamente, si es `U : DiscreteOracle` , `U(m)` implementa $U ^ m $ para `m : Int` .</span><span class="sxs-lookup"><span data-stu-id="02227-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="02227-123">Con esta definición en su lugar, cada paso de la estimación de la fase iterativa continúa mediante la preparación de un qubit auxiliar en el estado $ \ket{+} $ junto con el estado inicial $ \ket{\phi} $ que asumimos es un [Eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) de $U (m) $, es decir, $U (m) \ket{\phi} = e ^ {im\phi} \ les {\ Phi} $.</span><span class="sxs-lookup"><span data-stu-id="02227-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxiliary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="02227-124">`U(m)`Después, se usa una aplicación controlada de que prepara el estado $ \left (R \_ 1 (m \phi) \ket{+} \right) \ket{\phi} $.</span><span class="sxs-lookup"><span data-stu-id="02227-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="02227-125">Como en el caso de Quantum, el efecto de una aplicación controlada de Oracle `U(m)` es exactamente el mismo que el efecto de aplicar $R _ 1 _ 1 para la fase desconocida en $ \ket{+} $, de modo que podamos describir los efectos de $U $ en este modo más sencillo.</span><span class="sxs-lookup"><span data-stu-id="02227-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="02227-126">Opcionalmente, el algoritmo rota el qubit de control aplicando $R _ 1 (-m\theta) $ para obtener un estado $ \ket{\psi} = \left (R \_ 1 (m [\phi-\theta]) \ket{+} \right) \ket{\phi} $ $.</span><span class="sxs-lookup"><span data-stu-id="02227-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="02227-127">El qubit auxiliar que se usa como control para `U(m)` se mide en el $X $ Basis para obtener un único clásico `Result` .</span><span class="sxs-lookup"><span data-stu-id="02227-127">The auxiliary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="02227-128">En este momento, reconstruir la fase de los `Result` valores obtenidos a través de la estimación de la fase iterativa es un problema de inferencia estadística clásico.</span><span class="sxs-lookup"><span data-stu-id="02227-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="02227-129">La búsqueda del valor de $m $ que maximiza la información obtenida, dado un método de inferencia fijo, es simplemente un problema en las estadísticas.</span><span class="sxs-lookup"><span data-stu-id="02227-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="02227-130">Resaltamos esto describiendo brevemente la estimación de fases iterativas en un nivel teórico en el parámetro Bayesiano estimación de formalismo antes de continuar con la descripción de los algoritmos estadísticos que se proporcionan en Q# Canon para resolver este problema de inferencia clásica.</span><span class="sxs-lookup"><span data-stu-id="02227-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the Q# canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="02227-131">Estimación de fase iterativa sin Eigenstates</span><span class="sxs-lookup"><span data-stu-id="02227-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="02227-132">Si se proporciona un estado de entrada que no es un eigenstate, lo que significa que si $U (m) \ket{\phi \_ j} = e ^ {im\phi \_ j} $, el proceso de estimación de fase no guía de manera no determinista el estado de Quantum hacia un único eigenstate de energía.</span><span class="sxs-lookup"><span data-stu-id="02227-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="02227-133">En última instancia, eigenstate converge en es el eigenstate que es más probable que produzca el observado `Result` .</span><span class="sxs-lookup"><span data-stu-id="02227-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="02227-134">En concreto, un único paso de PE realiza la siguiente transformación no unitario en un estado \begin{align} \ sum_j \sqrt{\Pr (\phi \_ j)} \ket{\phi \_ j} \mapsto \sum \_ j\frac {\ sqrt {\ PR (\phi \_ j)} \sqrt{\Pr (\text{result} | \phi \_ j)} \Ket{\phi \_ j}} {\sqrt{\Pr (\phi \_ j) \sum \_ k \Pr (\text{result} | \phi \_ k)}}.</span><span class="sxs-lookup"><span data-stu-id="02227-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_k \Pr(\text{Result}|\phi\_k)}}.</span></span>
<span data-ttu-id="02227-135">\end{align} como este proceso se repite en varios `Result` valores, eigenstates que no tienen los valores máximos de $ \ prod_k \pr (\text{result} \_ k | \phi \_ j) $ se suprimirán de forma exponencial.</span><span class="sxs-lookup"><span data-stu-id="02227-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="02227-136">Como resultado, el proceso de inferencia tiende a converger en los Estados con un solo eigenvalue si los experimentos se eligen correctamente.</span><span class="sxs-lookup"><span data-stu-id="02227-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="02227-137">El teorema de Bayes sugiere además que el estado resultante de la estimación de la fase se escribe con el formato \begin{align} \frac{\sqrt{\Pr (\phi \_ j)} \sqrt{\Pr (\text{result} | \phi \_ j)} \ket{\phi \_ j}} {\sqrt{\Pr (\phi \_ j) \Sum \_ j \Pr (\text{result} | \phi \_ j)}} = \ sum_j \sqrt{\Pr (\phi \_ j | \text{result})} \ket{\phi \_ j}.</span><span class="sxs-lookup"><span data-stu-id="02227-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="02227-138">\end{align} aquí $ \Pr (\phi \_ j | \text{result}) $ puede interpretarse como la probabilidad de que se asignara a cada hipótesis sobre el eigenstates dado:</span><span class="sxs-lookup"><span data-stu-id="02227-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="02227-139">conocimiento del estado de cuanto antes de la medición.</span><span class="sxs-lookup"><span data-stu-id="02227-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="02227-140">conocimiento del eigenstates de $U $ y,</span><span class="sxs-lookup"><span data-stu-id="02227-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="02227-141">conocimiento del vectores propios de la $U $.</span><span class="sxs-lookup"><span data-stu-id="02227-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="02227-142">Aprender estas tres cosas suele ser exponencialmente difícil en un equipo clásico.</span><span class="sxs-lookup"><span data-stu-id="02227-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="02227-143">La utilidad de estimación de la fase se produce, sin tener en cuenta, por el hecho de que puede realizar este tipo de tarea de aprendizaje de Quantum sin conocer ninguno de ellos.</span><span class="sxs-lookup"><span data-stu-id="02227-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="02227-144">La estimación de fase por este motivo aparece dentro de varios algoritmos Quantum que proporcionan velocidad exponencial.</span><span class="sxs-lookup"><span data-stu-id="02227-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="02227-145">Estimación de la fase bayesiana</span><span class="sxs-lookup"><span data-stu-id="02227-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="02227-146">Para obtener más información sobre la estimación de la fase bayesiana en la práctica, consulte el ejemplo de [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) .</span><span class="sxs-lookup"><span data-stu-id="02227-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="02227-147">La idea de la estimación de la fase bayesiana es sencilla.</span><span class="sxs-lookup"><span data-stu-id="02227-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="02227-148">Se recopilan estadísticas de medidas del Protocolo de estimación de fase y, a continuación, se procesan los resultados mediante la inferencia bayesiana y se proporciona una estimación del parámetro.</span><span class="sxs-lookup"><span data-stu-id="02227-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="02227-149">Este procesamiento ofrece una estimación de los eigenvalue y la incertidumbre de esa estimación.</span><span class="sxs-lookup"><span data-stu-id="02227-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="02227-150">También permite realizar experimentos adaptables y utilizar información anterior.</span><span class="sxs-lookup"><span data-stu-id="02227-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="02227-151">El principal inconveniente de los métodos es que exige la informática.</span><span class="sxs-lookup"><span data-stu-id="02227-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="02227-152">Para entender cómo funciona este proceso de inferencia bayesiana, considere el caso del procesamiento de un único `Zero` resultado.</span><span class="sxs-lookup"><span data-stu-id="02227-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="02227-153">Tenga en cuenta que $X = \ket{+} \bra{+}-\ket {-} \bra {-} $, de modo que $ \ket{+} $ es el único eigenstate positivo de $X $ correspondiente a `Zero` .</span><span class="sxs-lookup"><span data-stu-id="02227-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="02227-154">La probabilidad de observar `Zero` una [ `PauliX` medida](xref:microsoft.quantum.concepts.pauli) en el primer qubit dado un estado de entrada $ \ket{\psi}\ket{\phi} $ es, por lo tanto, \begin{Equation} \Pr (\texttt{Zero} | \psi) = \left | \braket{+ | \psi} \right | ^ 2.</span><span class="sxs-lookup"><span data-stu-id="02227-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="02227-155">\end{Equation} en el caso de la estimación de la fase iterativa, tenemos $ \ket{\psi} = R_1 (m [\phi-\theta]) \ket{+} $, de modo que \begin{align} \Pr (\texttt{Zero} | \phi; m, \theta) & = \left | \braket{+ | R_1 (m [\phi-\theta]) | +} \right | ^ 2 \\ \\ & = \left | \frac12 \left (\bra {0} + \bra {1} \right) \left (\ket {0} + e ^ {i m [\phi-\theta]} \ket {1} \right) \right | ^ 2 \\ \\ & = \left | \frac{1 + e ^ {i m [\phi-\theta]}} {2} \right | ^ 2 \\ \\ & = \cos ^ 2 (m [\phi-\theta]/2) \tag{★} \label{EQ: fase-Estimado-probabilidad}.</span><span class="sxs-lookup"><span data-stu-id="02227-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="02227-156">\end{Align} es decir, la estimación de la fase iterativa consiste en conocer la frecuencia de oscilación de una función sinusoidal, dada la capacidad de voltear una moneda con un sesgo dado por ese sinusoidal.</span><span class="sxs-lookup"><span data-stu-id="02227-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="02227-157">Después de la terminología clásica tradicional, llamamos a $ \eqref{EQ: Phase-est-probabilidad} $ la *función de probabilidad* para la estimación de fases iterativas.</span><span class="sxs-lookup"><span data-stu-id="02227-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="02227-158">Tras observar un `Result` de la función de probabilidad de estimación de fase iterativa, podemos usar la regla de Bayes para prescribir lo que creemos que la fase debe seguir esa observación.</span><span class="sxs-lookup"><span data-stu-id="02227-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="02227-159">Concretamente, \begin{Equation} \Pr (\phi | d) = \frac{\Pr (d | \phi) \Pr (\phi)} {\int \Pr (d | \phi) \Pr (\phi) {\mathrm d} \phi} \Pr (\phi), \end{Equation} donde $d \en \\ {\texttt{Zero}, \texttt{One} \\ } $ es a y `Result` donde $ \Pr (\phi) $ describe nuestras creencias anteriores sobre $ \phi $.</span><span class="sxs-lookup"><span data-stu-id="02227-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="02227-160">Esto hace que la naturaleza iterativa de la estimación de fase iterativa sea explícita, ya que la distribución posterior $ \Pr (\phi | d) $ describe nuestras creencias inmediatamente antes de la observación de la siguiente `Result` .</span><span class="sxs-lookup"><span data-stu-id="02227-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceding our observation of the next `Result`.</span></span>

<span data-ttu-id="02227-161">En cualquier momento durante este procedimiento, podemos informar de la fase $ \hat{\phi} $ inferido por el controlador clásico como \begin{Equation} \hat{\phi} \mathrel{: =} \expect [\phi | \text{Data}] = \int \phi \Pr (\phi | \text{Data}) {\mathrm d} \phi, \end{Equation} donde $ \text{Data} $ representa todo el registro de todos `Result` los valores obtenidos.</span><span class="sxs-lookup"><span data-stu-id="02227-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="02227-162">La inferencia bayesiana exacta es inestable.</span><span class="sxs-lookup"><span data-stu-id="02227-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="02227-163">Para ver este Imagine, queremos obtener información sobre una variable de $-bit $n $x $.</span><span class="sxs-lookup"><span data-stu-id="02227-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="02227-164">La distribución anterior $ \Pr (x) $ admite más de $2 ^ n $ valores hipotéticos de $x $.</span><span class="sxs-lookup"><span data-stu-id="02227-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="02227-165">Esto significa que, si necesitamos una estimación muy precisa de $x $, la estimación de la fase bayesiana puede requerir memoria y tiempo de procesamiento prohibidos.</span><span class="sxs-lookup"><span data-stu-id="02227-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="02227-166">En el caso de algunas aplicaciones, como la simulación de Quantum, la precisión limitted requerida no impide que otros métodos, como el algoritmo de mé, no puedan usar la inferencia de Bayesiano exacta en el paso de estimación de fase.</span><span class="sxs-lookup"><span data-stu-id="02227-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="02227-167">Por esta razón, también proporcionamos implementaciones para los métodos bayesiana aproximados, como la [estimación de fases de recorrido aleatorio (RWPE)](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) y los enfoques no Bayesiana, como la [sólida estimación de fase](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation).</span><span class="sxs-lookup"><span data-stu-id="02227-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) and also non-Bayesian approaches such as [robust phase estimation](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="02227-168">Estimación de fase sólida</span><span class="sxs-lookup"><span data-stu-id="02227-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="02227-169">En el peor de los casos, un valor máximo de *una* reconstrucción exgresivo de una fase de la estimación de la fase de los resultados de la medición es exponencialmente fuerte.</span><span class="sxs-lookup"><span data-stu-id="02227-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="02227-170">Por lo tanto, la mayoría de los algoritmos de estimación de fase práctica sacrifican cierta calidad en la reconstrucción, a cambio de una cantidad de procesamiento posterior clásico que, en su lugar, se escala polinomiales con el número de medidas realizadas.</span><span class="sxs-lookup"><span data-stu-id="02227-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="02227-171">Un ejemplo de este tipo con un paso de procesamiento posterior más eficaz es el [algoritmo de estimación de fase sólida](https://arxiv.org/abs/1502.02677), con su firma y sus entradas mencionadas anteriormente.</span><span class="sxs-lookup"><span data-stu-id="02227-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="02227-172">Se supone que los cuadros de color unitarios de entrada $U $ se empaquetan como `DiscreteOracle` tipo y, por lo tanto, solo consulta las potencias enteras de controled-$U $.</span><span class="sxs-lookup"><span data-stu-id="02227-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="02227-173">Si el estado de entrada del `Qubit[]` registro es eigenstate $U \ket{\psi} = e ^ {i\phi} \ les {\ PSI} $, el algoritmo de estimación de fase sólida devuelve una estimación $ \hat{\phi}\in [-\pi, \pi) $ de $ \phi $ como `Double` .</span><span class="sxs-lookup"><span data-stu-id="02227-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="02227-174">La característica más importante de una estimación de fase sólida, que se comparte con la mayoría de las otras variantes útiles, es que la calidad de reconstrucción de $ \hat{\phi} $ está en cierto sentido Heisenberg-Limited.</span><span class="sxs-lookup"><span data-stu-id="02227-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="02227-175">Esto significa que si la desviación de $ \hat{\phi} $ del valor true es $ \sigma $, $ \sigma $ se escala inversamente proporcionalmente al número total de consultas $Q $ realizado en controled-$U $, es decir, $ \sigma = \mathcal{O} (1/Q) $.</span><span class="sxs-lookup"><span data-stu-id="02227-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="02227-176">Ahora, la definición de la desviación varía entre distintos algoritmos de estimación.</span><span class="sxs-lookup"><span data-stu-id="02227-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="02227-177">En algunos casos, puede significar que, al menos $ \mathcal{O} (1) $ probability, el error de estimación $ | \hat{\phi}-\phi | \_ \circ\le \sigma $ en algunas medidas circulares $ \circ $.</span><span class="sxs-lookup"><span data-stu-id="02227-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="02227-178">Para una estimación de fase sólida, la desviación es precisamente la varianza $ \sigma ^ 2 = \mathbb{E} \_ \hat{\phi} [(\mod \_ {2 \ PI} (\hat{\phi}-\phi + \pi)-\pi) ^ 2] $ si desencapsulamos las fases periódicas en un único intervalo finito $ (-\pi, \pi] $.</span><span class="sxs-lookup"><span data-stu-id="02227-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="02227-179">Más concretamente, la desviación estándar en una estimación de fase sólida satisface las desigualdades $ $ \begin{align} 2,0 \pi/Q \le \sigma \le 2 \ pi/2 ^ {n} \le 10.7 \ PI/Q, \end{align} $ $ donde se alcanza el límite inferior en el límite de asymptotically grande $Q $ y se garantiza el límite superior incluso para tamaños de ejemplo pequeños.</span><span class="sxs-lookup"><span data-stu-id="02227-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="02227-180">Tenga en cuenta que $n $ seleccionado por la `bitsPrecision` entrada, que define implícitamente $Q $.</span><span class="sxs-lookup"><span data-stu-id="02227-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="02227-181">Otros detalles relevantes incluyen, por ejemplo, la sobrecarga de espacio pequeña de solo $1 $ ancilla qubit, o que el procedimiento no es adaptable, lo que significa que la secuencia requerida de experimentos de Quantum es independiente de los resultados de la medida intermedia.</span><span class="sxs-lookup"><span data-stu-id="02227-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="02227-182">En este y en los próximos ejemplos en los que la elección del algoritmo de estimación de fase es importante, uno debería hacer referencia a la documentación como @"microsoft.quantum.characterization.robustphaseestimation" y a las publicaciones a las que se hace referencia para obtener más información y para su implementación.</span><span class="sxs-lookup"><span data-stu-id="02227-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.characterization.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="02227-183">Hay muchos ejemplos en los que se usa una estimación de fase sólida.</span><span class="sxs-lookup"><span data-stu-id="02227-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="02227-184">Para estimar la fase en la extracción de la energía de estado de la alimentación de varios sistemas físicos, consulte el ejemplo de [ **simulación de H2**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), el [ejemplo **SimpleIsing**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple)y el ejemplo de [ **Modelo Hubbard**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard).</span><span class="sxs-lookup"><span data-stu-id="02227-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="02227-185">Oracle continuos</span><span class="sxs-lookup"><span data-stu-id="02227-185">Continuous Oracles</span></span> ###

<span data-ttu-id="02227-186">También se puede generalizar a partir del modelo de Oracle que se ha usado anteriormente para permitir Oracle en tiempo continuo, modelado por el tipo Canon <xref:Microsoft.Quantum.Oracles.ContinuousOracle> .</span><span class="sxs-lookup"><span data-stu-id="02227-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:Microsoft.Quantum.Oracles.ContinuousOracle>.</span></span>
<span data-ttu-id="02227-187">Tenga en cuenta que en lugar de un único operador unitario $U $, tenemos una familia de operadores unitarios $U (t) $ para $t \en \mathbb{R} $, que $U (t) U (s) $ = $U (t + s) $.</span><span class="sxs-lookup"><span data-stu-id="02227-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="02227-188">Se trata de una instrucción más débil que en el caso discreto, ya que podemos crear un <xref:Microsoft.Quantum.Oracles.DiscreteOracle> mediante la restricción de $t = m \, \delta t $ para algún $ \delta t $ fijo.</span><span class="sxs-lookup"><span data-stu-id="02227-188">This is a weaker statement than in the discrete case, since we can construct a <xref:Microsoft.Quantum.Oracles.DiscreteOracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="02227-189">Por [teorema](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U (t) = \exp (i H t) $ para algún operador $H $, donde $ \exp $ es la matriz exponencial tal y como se describe en [matrices avanzadas](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="02227-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="02227-190">Un eigenstate $ \ket{\phi} $ de $H $ de modo que $H \ket{\phi} = \phi \ket{\phi} $ es también un eigenstate de $U (t) $ para todos los $t $, \begin{Equation} U (t) \ket{\phi} = e ^ {i \phi t} \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="02227-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="02227-191">\end{equation}</span><span class="sxs-lookup"><span data-stu-id="02227-191">\end{equation}</span></span>

<span data-ttu-id="02227-192">Se puede aplicar el mismo análisis exacto descrito para la estimación de la [fase bayesiana](#bayesian-phase-estimation) y la función de probabilidad es exactamente la misma para este modelo de Oracle más general: $ $ \Pr (\texttt{Zero} | \phi; t, \theta) = \cos ^ 2 \ Left (\frac{t [\phi-\theta]} {2} \right).</span><span class="sxs-lookup"><span data-stu-id="02227-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="02227-193">$ $ Además, si $U $ es una simulación de un generador dinámico, como es el caso de la [simulación de Hamiltonian](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), se interpreta $ \phi $ como una energía.</span><span class="sxs-lookup"><span data-stu-id="02227-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="02227-194">Por lo tanto, el uso de la estimación de fase con consultas continuas nos permite aprender el [espectro energético simulado de moléculas](https://arxiv.org/abs/quant-ph/0604193), [materiales](https://arxiv.org/abs/1510.03859) o [teorías de campo](https://arxiv.org/abs/1111.3633v2) sin tener que poner en peligro nuestra elección de experimentos al requerir que $t $ sea un entero.</span><span class="sxs-lookup"><span data-stu-id="02227-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="02227-195">Estimación de fase de recorrido aleatorio</span><span class="sxs-lookup"><span data-stu-id="02227-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="02227-196">Q# proporciona una aproximación útil de la estimación de la fase bayesiana diseñada para el uso de dispositivos cercanos a Quantum que funcionan mediante el acondicionamiento de un recorrido aleatorio en el registro de datos Obtenido de la estimación de la fase iterativa.</span><span class="sxs-lookup"><span data-stu-id="02227-196">Q# provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="02227-197">Este método es tanto adaptable como completamente determinista, lo que permite un escalado casi óptimo de errores en la fase estimada $ \hat{\phi} $ con sobrecargas de memoria muy bajas.</span><span class="sxs-lookup"><span data-stu-id="02227-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="02227-198">El protocolo utiliza un método de inferencia Bayesiano aproximado que supone que la distribución anterior es Gaussiano.</span><span class="sxs-lookup"><span data-stu-id="02227-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="02227-199">Esta suposición gaussiano nos permite usar una fórmula analítica para el experimento que minimiza la desviación posterior.</span><span class="sxs-lookup"><span data-stu-id="02227-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="02227-200">Después, el algoritmo, en función del resultado de ese experimento, desplaza la estimación de $ \phi $ a la izquierda o a la derecha en una cantidad predeterminada y reduce la varianza en una cantidad determinada previamente.</span><span class="sxs-lookup"><span data-stu-id="02227-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="02227-201">Esta media y desviación proporcionan toda la información necesaria para especificar un gaussiano anterior a $ \phi $ para el siguiente experimento.</span><span class="sxs-lookup"><span data-stu-id="02227-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="02227-202">Los errores de medición inesperados, o el resultado verdadero en las colas del inicial anterior, pueden hacer que este método produzca un error.</span><span class="sxs-lookup"><span data-stu-id="02227-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="02227-203">Se recupera de un error realizando experimentos para probar si la media y la desviación estándar actuales son adecuadas para el sistema.</span><span class="sxs-lookup"><span data-stu-id="02227-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="02227-204">Si no es así, el algoritmo realiza un paso inverso del recorrido y el proceso continúa.</span><span class="sxs-lookup"><span data-stu-id="02227-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="02227-205">La capacidad de desplazarse hacia atrás también permite que el algoritmo Aprenda incluso si la desviación estándar anterior inicial es inapropriately pequeña.</span><span class="sxs-lookup"><span data-stu-id="02227-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="02227-206">Algoritmos de estimación de fase de llamada</span><span class="sxs-lookup"><span data-stu-id="02227-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="02227-207">Cada operación de estimación de fase que se proporciona con el Q# Canon toma un conjunto diferente de entradas que parametrizan la calidad que demandamos de la estimación final $ \hat{\phi} $.</span><span class="sxs-lookup"><span data-stu-id="02227-207">Each phase estimation operation provided with the Q# canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="02227-208">Sin embargo, estas diversas entradas comparten varias entradas en común, de modo que la aplicación parcial a través de los parámetros de calidad da como resultado una firma común.</span><span class="sxs-lookup"><span data-stu-id="02227-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="02227-209">Por ejemplo, la <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> operación que se describe en la siguiente sección tiene la firma siguiente:</span><span class="sxs-lookup"><span data-stu-id="02227-209">For example, the <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="02227-210">La `bitsPrecision` entrada es única en `RobustPhaseEstimation` , mientras que `oracle` y `eigenstate` están en común.</span><span class="sxs-lookup"><span data-stu-id="02227-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="02227-211">Por lo tanto, como se aprecia en **H2Sample**, una operación puede aceptar un algoritmo de estimación de fase iterativa con una entrada del formulario `(DiscreteOracle, Qubit[]) => Unit` para permitir que un usuario especifique algoritmos de estimación de fase arbitrarios:</span><span class="sxs-lookup"><span data-stu-id="02227-211">Thus, as seen in **H2Sample**, an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

<span data-ttu-id="02227-212">Estos pocos algoritmos de estimación de fase están optimizados para las distintas propiedades y parámetros de entrada, que deben entenderse para que sea la mejor opción para la aplicación de destino.</span><span class="sxs-lookup"><span data-stu-id="02227-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="02227-213">Por ejemplo, algunos algoritmos de estimación de fase son adaptables, lo que significa que los pasos futuros se controlan de forma controlada por los resultados de la medición de los pasos anteriores.</span><span class="sxs-lookup"><span data-stu-id="02227-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="02227-214">Algunos requieren la capacidad de exponentiater su unitario de cuadro negro de Oracle por poderes reales arbitrarios, y otros solo requieren potencias enteras, pero solo pueden resolver un módulo de estimación de fase $2 \ PI $.</span><span class="sxs-lookup"><span data-stu-id="02227-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="02227-215">Algunos requieren muchos qubits auxiliares y otros solo requieren uno.</span><span class="sxs-lookup"><span data-stu-id="02227-215">Some require many auxiliary qubits, and others require only one.</span></span>

<span data-ttu-id="02227-216">Del mismo modo, el uso de la estimación de fases de recorrido aleatorios se realiza de forma muy similar a la de otros algoritmos que se proporcionan con Canon:</span><span class="sxs-lookup"><span data-stu-id="02227-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
