---
title: Q#Conceptos básicos
description: Conceptos básicos deQ#
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
no-loc:
- Q#
- $$v
ms.openlocfilehash: 4f4a75cdaaa070fd763d7f75429b7c39357d25a5
ms.sourcegitcommit: 6bf99d93590d6aa80490e88f2fd74dbbee8e0371
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/06/2020
ms.locfileid: "87869654"
---
# <a name="no-locq-basics"></a><span data-ttu-id="2f637-103">Q#Conceptos básicos</span><span class="sxs-lookup"><span data-stu-id="2f637-103">Q# Basics</span></span>

<span data-ttu-id="2f637-104">En este artículo se presenta una breve introducción a los bloques de creación básicos de Q# .</span><span class="sxs-lookup"><span data-stu-id="2f637-104">This article presents a brief introduction to the basic building blocks of Q#.</span></span>

<span data-ttu-id="2f637-105">Para obtener información general sobre qué Q# es y dónde encaja como componente fundamental del kit de desarrollo de Quantum, vea [¿Qué es Q# ?](xref:microsoft.quantum.overview.q-sharp).</span><span class="sxs-lookup"><span data-stu-id="2f637-105">For an overview of what Q# is and where it fits in as a fundamental component of the Quantum Development Kit, see [What is Q#?](xref:microsoft.quantum.overview.q-sharp).</span></span> 

## <a name="what-is-a-quantum-program"></a><span data-ttu-id="2f637-106">¿Qué es un programa Quantum?</span><span class="sxs-lookup"><span data-stu-id="2f637-106">What is a quantum program?</span></span>

<span data-ttu-id="2f637-107">Desde una perspectiva técnica, un programa Quantum es un conjunto determinado de subrutinas clásicas que, cuando se llama, realizan ciertas operaciones en un sistema Quantum.</span><span class="sxs-lookup"><span data-stu-id="2f637-107">From a technical perspective, a quantum program is a particular set of classical subroutines which, when called, perform certain operations on a quantum system.</span></span>
<span data-ttu-id="2f637-108">Una consecuencia importante de esa vista es que un Q# programa no modela directamente qubits, sino que describe el modo en que un equipo controlado por clases interactúa con esos qubits.</span><span class="sxs-lookup"><span data-stu-id="2f637-108">An important consequence of that view is that a Q# program does not directly model qubits themselves, but rather describes how a classically controlled computer interacts with those qubits.</span></span>
<span data-ttu-id="2f637-109">Por diseño, no Q# define los Estados Quantum u otras propiedades de la mecánica de Quantum directamente.</span><span class="sxs-lookup"><span data-stu-id="2f637-109">By design, Q# does not define quantum states or other properties of quantum mechanics directly.</span></span>
<span data-ttu-id="2f637-110">Por ejemplo, tenga en cuenta el estado $ \ket{+} = \left (\ket {0} + \ket {1} \right)/\sqrt {2} $ descrito en la guía de [conceptos de procesamiento de Quantum](xref:microsoft.quantum.concepts.intro) .</span><span class="sxs-lookup"><span data-stu-id="2f637-110">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="2f637-111">Para preparar este estado en Q# , comience con los hechos que los qubits se inicializan en el estado $ \ket {0} $ y que $ \ket{+} = H\ket {0} $, donde $H $ es la [transformación Hadamard](xref:microsoft.quantum.glossary#hadamard), implementada por la [ `H` operación](xref:microsoft.quantum.intrinsic.h).</span><span class="sxs-lookup"><span data-stu-id="2f637-111">To prepare this state in Q#, start with the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the [Hadamard transform](xref:microsoft.quantum.glossary#hadamard), implemented by the [`H` operation](xref:microsoft.quantum.intrinsic.h).</span></span> <span data-ttu-id="2f637-112">El Q# código básico para inicializar y transformar un qubit, a continuación, tiene el siguiente aspecto:</span><span class="sxs-lookup"><span data-stu-id="2f637-112">The basic Q# code to initialize and transform a qubit, then, looks like this:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, the qubit is in the state |0⟩.
    H(qubit);
    // H is now applied, such that the qubit is in H|0⟩ = |+⟩, as desired.
}
```
<span data-ttu-id="2f637-113">Para obtener más información sobre cómo inicializar, o *asignar*, qubits, consulte [trabajar con qubits](xref:microsoft.quantum.guide.qubits).</span><span class="sxs-lookup"><span data-stu-id="2f637-113">For more information on initializing, or *allocating*, qubits, see [Working with qubits](xref:microsoft.quantum.guide.qubits).</span></span>

## <a name="quantum-states-in-no-locq"></a><span data-ttu-id="2f637-114">Estados de Quantum enQ#</span><span class="sxs-lookup"><span data-stu-id="2f637-114">Quantum states in Q#</span></span>

<span data-ttu-id="2f637-115">Lo importante es que el programa anterior no hace referencia explícitamente al estado en, Q# pero describe cómo el programa *transformó* el estado.</span><span class="sxs-lookup"><span data-stu-id="2f637-115">Importantly, the previous program does not explicitly refer to the state within Q# but described how our program *transformed* the state.</span></span>
<span data-ttu-id="2f637-116">Con este enfoque, puede ser totalmente independiente de lo que *es* un estado de Quantum incluso en cada máquina de destino, lo que puede tener interpretaciones diferentes en función del equipo.</span><span class="sxs-lookup"><span data-stu-id="2f637-116">With this approach, you can be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="2f637-117">Un Q# programa no puede Introspect en el estado de un qubit.</span><span class="sxs-lookup"><span data-stu-id="2f637-117">A Q# program cannot introspect into the state of a qubit.</span></span>
<span data-ttu-id="2f637-118">En su lugar, un programa puede llamar a operaciones como [`Measure`](xref:microsoft.quantum.intrinsic.measure) para obtener información de un qubit y llamar a operaciones como [`X`](xref:microsoft.quantum.intrinsic.x) y [`H`](xref:microsoft.quantum.intrinsic.h) para que actúen en el estado de un qubit.</span><span class="sxs-lookup"><span data-stu-id="2f637-118">Instead, a program can call operations such as [`Measure`](xref:microsoft.quantum.intrinsic.measure) to learn information from a qubit, and call operations such as [`X`](xref:microsoft.quantum.intrinsic.x) and [`H`](xref:microsoft.quantum.intrinsic.h) to act on the state of a qubit.</span></span>
<span data-ttu-id="2f637-119">Lo que realmente *hacen* estas operaciones solo se convierte en concreto por el equipo de destino que se usa para ejecutar el programa en particular Q# .</span><span class="sxs-lookup"><span data-stu-id="2f637-119">What these operations actually *do* is only made concrete by the target machine used to run the particular Q# program.</span></span>
<span data-ttu-id="2f637-120">Por ejemplo, si se ejecuta el programa en el [simulador de estado completo](xref:microsoft.quantum.machines.full-state-simulator), el simulador realiza las operaciones matemáticas correspondientes en el sistema Quantum simulado.</span><span class="sxs-lookup"><span data-stu-id="2f637-120">For example, if running the program on our [full-state simulator](xref:microsoft.quantum.machines.full-state-simulator), the simulator performs the corresponding mathematical operations to the simulated quantum system.</span></span>
<span data-ttu-id="2f637-121">Pero en el futuro, cuando el equipo de destino es un equipo Quantum real, llamar a tales operaciones en Q# dirige el equipo Quantum para realizar las operaciones *reales* correspondientes en el sistema Quantum *real* , por ejemplo, con precisión de impulsos de láser.</span><span class="sxs-lookup"><span data-stu-id="2f637-121">But looking toward the future, when the target machine is a real quantum computer, calling such operations in Q# directs the quantum computer to perform the corresponding *real* operations on the *real* quantum system, for example, precisely timed laser pulses).</span></span>

<span data-ttu-id="2f637-122">Un Q# programa vuelve a combinar estas operaciones definidas por un equipo de destino para crear nuevas operaciones de nivel superior para expresar el cálculo de Quantum.</span><span class="sxs-lookup"><span data-stu-id="2f637-122">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="2f637-123">De esta manera, facilita Q# la rápida expresión de Quantum subyacente de la lógica y los algoritmos de Quantum híbridos, mientras que también es general con respecto a la estructura de un equipo o simulador de destino.</span><span class="sxs-lookup"><span data-stu-id="2f637-123">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum–classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="no-locq-operations-and-functions"></a><span data-ttu-id="2f637-124">Q#operaciones y funciones</span><span class="sxs-lookup"><span data-stu-id="2f637-124">Q# operations and functions</span></span>

<span data-ttu-id="2f637-125">Concretamente, un Q# programa consta de *operaciones*, *funciones*y cualquier tipo definido por el usuario.</span><span class="sxs-lookup"><span data-stu-id="2f637-125">Concretely, a Q# program comprises *operations*, *functions*, and any user-defined types.</span></span> 

<span data-ttu-id="2f637-126">Las operaciones se utilizan para describir las transformaciones de los sistemas Quantum y son el bloque de creación más importante de los Q# programas.</span><span class="sxs-lookup"><span data-stu-id="2f637-126">Operations are used to describe the transformations of quantum systems and are the most fundamental building block of Q# programs.</span></span> <span data-ttu-id="2f637-127">Cada operación definida en Q# puede llamar a cualquier número de otras operaciones.</span><span class="sxs-lookup"><span data-stu-id="2f637-127">Each operation defined in Q# may then call any number of other operations.</span></span>

<span data-ttu-id="2f637-128">A diferencia de las operaciones, las funciones se usan para describir el comportamiento clásico puramente *determinista* y no tienen ningún efecto aparte de la informática de los valores clásico.</span><span class="sxs-lookup"><span data-stu-id="2f637-128">In contrast to operations, functions are used to describe purely *deterministic* classical behavior and do not have any effects besides computing classical values.</span></span> <span data-ttu-id="2f637-129">Por ejemplo, supongamos que desea medir el qubits al final de un programa y agregar los resultados de la medida a una matriz.</span><span class="sxs-lookup"><span data-stu-id="2f637-129">For example, suppose you want to measure the qubits at the end of a program and add the measurement results to an array.</span></span>
<span data-ttu-id="2f637-130">En este caso, `Measure` es una *operación* que indica al equipo de destino que realice una medida en el qubits (real o simulado).</span><span class="sxs-lookup"><span data-stu-id="2f637-130">In this case, `Measure` is an *operation* that instructs the target machine to perform a measurement on the (real or simulated) qubits.</span></span> <span data-ttu-id="2f637-131">Al mismo tiempo, *las funciones* controlan el proceso clásico de agregar los resultados devueltos a una matriz.</span><span class="sxs-lookup"><span data-stu-id="2f637-131">At the same time, *functions* handle the classical process of adding the returned results to an array.</span></span>

<span data-ttu-id="2f637-132">Juntas, las operaciones y las funciones se conocen como *Invocables*.</span><span class="sxs-lookup"><span data-stu-id="2f637-132">Together, operations and functions are known as *callables*.</span></span> <span data-ttu-id="2f637-133">La estructura y el comportamiento subyacentes se presentan y detallan en [operaciones y funciones en Q# ](xref:microsoft.quantum.guide.operationsfunctions).</span><span class="sxs-lookup"><span data-stu-id="2f637-133">Their underlying structure and behavior are introduced and detailed in [Operations and Functions in Q#](xref:microsoft.quantum.guide.operationsfunctions).</span></span>


## <a name="no-locq-syntax-overview"></a><span data-ttu-id="2f637-134">Q#Información general sobre la sintaxis</span><span class="sxs-lookup"><span data-stu-id="2f637-134">Q# syntax overview</span></span>

<span data-ttu-id="2f637-135">En la sintaxis de un lenguaje se describen las distintas combinaciones de símbolos que forman un programa sintácticamente correcto.</span><span class="sxs-lookup"><span data-stu-id="2f637-135">The syntax of a language describes the different combinations of symbols that form a syntactically correct program.</span></span>
<span data-ttu-id="2f637-136">En Q# , los elementos de sintaxis se clasifican en tres grupos distintos: tipos, expresiones e instrucciones.</span><span class="sxs-lookup"><span data-stu-id="2f637-136">In Q#, syntax elements are classified into three different groups: types, expressions, and statements.</span></span>

### <a name="types"></a><span data-ttu-id="2f637-137">Tipos</span><span class="sxs-lookup"><span data-stu-id="2f637-137">Types</span></span>
<span data-ttu-id="2f637-138">Q#es un lenguaje fuertemente tipado, de modo que el uso cuidadoso de los tipos puede ayudar al compilador a proporcionar garantías seguras sobre los Q# programas en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="2f637-138">Q# is a strongly-typed language, such that careful use of types can help the compiler provide strong guarantees about Q# programs at compile time.</span></span>
<span data-ttu-id="2f637-139">Además de los tipos primitivos estándar y específicos de Quantum, como, por ejemplo,,, `Int` `Bool` `Qubit` y `Result` , proporciona compatibilidad con los Q# tipos definidos por el usuario.</span><span class="sxs-lookup"><span data-stu-id="2f637-139">In addition to standard and quantum-specific built-in primitive types, for example, `Int`, `Bool`, `Qubit`, and `Result`, Q# provides support for user-defined types.</span></span>

<span data-ttu-id="2f637-140">Para obtener descripciones de todos los tipos primitivos, detalles de tipos de matriz y tupla, y pasos para definir nuevos tipos dentro de un Q# archivo, vea [tipos en Q# ](xref:microsoft.quantum.guide.types).</span><span class="sxs-lookup"><span data-stu-id="2f637-140">For descriptions of all the primitive types, details for array and tuple types, and steps to define new types within a Q# file, see [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

### <a name="expressions"></a><span data-ttu-id="2f637-141">Expresiones</span><span class="sxs-lookup"><span data-stu-id="2f637-141">Expressions</span></span>
<span data-ttu-id="2f637-142">Una expresión en un lenguaje de programación es una combinación de una o más constantes, variables, operadores y funciones que el lenguaje de programación interpreta y evalúa como un valor específico.</span><span class="sxs-lookup"><span data-stu-id="2f637-142">An expression in a programming language is a combination of one or more constants, variables, operators, and functions that the programming language interprets and evaluates to a specific value.</span></span>
<span data-ttu-id="2f637-143">En la mayoría de los tipos de un lenguaje, las expresiones de ese tipo pueden ser *literales* o símbolos enlazados a un valor de ese tipo.</span><span class="sxs-lookup"><span data-stu-id="2f637-143">Most simply, for every type in a language, expressions of that type can be either *literals* or symbols bound to a value of that type.</span></span>
<span data-ttu-id="2f637-144">Por ejemplo, `5` es un `Int` literal (por lo tanto, una expresión de tipo `Int` ) y si el símbolo `count` se enlaza al valor entero `5` , entonces `count` también es una expresión de tipo entero.</span><span class="sxs-lookup"><span data-stu-id="2f637-144">For example, `5` is an `Int` literal (thus also an expression of type `Int`), and if the symbol `count` is bound to the integer value `5`, then `count` is also an integer expression.</span></span>

<span data-ttu-id="2f637-145">Además, una expresión puede constar de otras expresiones combinadas por ciertos operadores.</span><span class="sxs-lookup"><span data-stu-id="2f637-145">Additionally, an expression can consist of other expressions combined by certain operators.</span></span>
<span data-ttu-id="2f637-146">Por ejemplo, otra `Int` expresión que se evalúa como `5` es `2+3` .</span><span class="sxs-lookup"><span data-stu-id="2f637-146">For example, another `Int` expression that evaluates to `5` is `2+3`.</span></span>

<span data-ttu-id="2f637-147">Para obtener más información sobre las expresiones y los operadores compatibles en Q# , vea [expresiones de tipo en Q# ](xref:microsoft.quantum.guide.expressions).</span><span class="sxs-lookup"><span data-stu-id="2f637-147">For more information about expressions and compatible operators in Q#, see [Type Expressions in Q#](xref:microsoft.quantum.guide.expressions).</span></span> 

### <a name="statements"></a><span data-ttu-id="2f637-148">Instrucciones</span><span class="sxs-lookup"><span data-stu-id="2f637-148">Statements</span></span> 
<span data-ttu-id="2f637-149">Una instrucción es una unidad sintáctica de un lenguaje de programación imperativo que expresa alguna acción que se va a llevar a cabo. Las instrucciones que contrastan con las expresiones en las instrucciones no devuelven resultados y se ejecutan únicamente para sus efectos secundarios.</span><span class="sxs-lookup"><span data-stu-id="2f637-149">A statement is a syntactic unit of an imperative programming language that expresses some action to carry out. Statements contrast with expressions in that statements do not return results and are executed solely for their side effects.</span></span> <span data-ttu-id="2f637-150">Sin embargo, las expresiones siempre devuelven un resultado y, a menudo, no tienen efectos secundarios.</span><span class="sxs-lookup"><span data-stu-id="2f637-150">Expressions, however, always return a result and often do not have side effects at all.</span></span> <span data-ttu-id="2f637-151">En Resumen, las Q# instrucciones se ejecutan, mientras que las expresiones se evalúan.</span><span class="sxs-lookup"><span data-stu-id="2f637-151">In short, Q# statements are executed, while expressions are evaluated.</span></span>

<span data-ttu-id="2f637-152">Un ejemplo sencillo de una instrucción en Q# es la asignación de un símbolo a una expresión:</span><span class="sxs-lookup"><span data-stu-id="2f637-152">A simple example of a statement in Q# is assigning a symbol to an expression:</span></span>
```qsharp
let count = 5;
```

<span data-ttu-id="2f637-153">Un ejemplo más interesante es la `for` instrucción que admite la iteración e incluye un *bloque de instrucciones*.</span><span class="sxs-lookup"><span data-stu-id="2f637-153">A more interesting example is the `for` statement which supports iteration and includes a *statement block*.</span></span>
<span data-ttu-id="2f637-154">Supongamos `qubits` que el símbolo se enlaza a un registro de qubits (técnicamente de tipo `Qubit[]` , o una matriz de `Qubit` tipos).</span><span class="sxs-lookup"><span data-stu-id="2f637-154">Suppose `qubits` is the symbol bound to a register of qubits (technically of type `Qubit[]`, or an array of `Qubit` types).</span></span> <span data-ttu-id="2f637-155">Entonces</span><span class="sxs-lookup"><span data-stu-id="2f637-155">Then</span></span>
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
<span data-ttu-id="2f637-156">es una instrucción que recorre en iteración cada qubit del registro y realiza la `H` operación en cada uno de ellos.</span><span class="sxs-lookup"><span data-stu-id="2f637-156">is a statement that iterates over each qubit in the register, performing the `H` operation on each one.</span></span> <span data-ttu-id="2f637-157">Tenga en cuenta que `H(qubit);` también es una instrucción propiamente dicha.</span><span class="sxs-lookup"><span data-stu-id="2f637-157">Note that `H(qubit);` is a statement in itself as well.</span></span>

<span data-ttu-id="2f637-158">Puede usar cualquier expresión de llamada de tipo `Unit` (un `Unit` tipo no devuelve ninguna información) como una instrucción.</span><span class="sxs-lookup"><span data-stu-id="2f637-158">You can use any call expression of type `Unit` (a `Unit` type does not return any information) as a statement.</span></span>
<span data-ttu-id="2f637-159">Este tipo de expresión es útil cuando se llama a operaciones en qubits que devuelven `Unit` porque el propósito de la instrucción es modificar el estado de Quantum implícito.</span><span class="sxs-lookup"><span data-stu-id="2f637-159">This type of expression is useful when calling operations on qubits that return `Unit` because the purpose of the statement is to modify the implicit quantum state.</span></span>
<span data-ttu-id="2f637-160">Las instrucciones de evaluación de expresiones requieren un punto y coma de finalización.</span><span class="sxs-lookup"><span data-stu-id="2f637-160">Expression evaluation statements require a terminating semicolon.</span></span>

<span data-ttu-id="2f637-161">Las instrucciones se usan para compilar casi todos los aspectos de un Q# programa, y ninguna página única puede incluir toda la información relacionada con ellas.</span><span class="sxs-lookup"><span data-stu-id="2f637-161">You use statements to build nearly every aspect of a Q# program, and no single page could encompass all the information relating to them.</span></span>
<span data-ttu-id="2f637-162">Para obtener más información sobre la estructura léxica y el formato, vea [ Q# estructura de archivos](xref:microsoft.quantum.guide.filestructure); para obtener información sobre la asignación y el ámbito de los símbolos, vea [variables en Q# ](xref:microsoft.quantum.guide.variables)y, en el caso de bucles de flujo de control como `for` , vea [flujo de control en Q# ](xref:microsoft.quantum.guide.controlflow).</span><span class="sxs-lookup"><span data-stu-id="2f637-162">For more information about their lexical structure and formatting, see [Q# File Structure](xref:microsoft.quantum.guide.filestructure); for symbol binding assignment and scope, see [Variables in Q#](xref:microsoft.quantum.guide.variables); and for control flow loops such as `for`, see [Control Flow in Q#](xref:microsoft.quantum.guide.controlflow).</span></span>

## <a name="next-steps"></a><span data-ttu-id="2f637-163">Pasos siguientes</span><span class="sxs-lookup"><span data-stu-id="2f637-163">Next steps</span></span>

<span data-ttu-id="2f637-164">Comience a obtener información sobre los [tipos en Q# ](xref:microsoft.quantum.guide.types).</span><span class="sxs-lookup"><span data-stu-id="2f637-164">Start learning about [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

<span data-ttu-id="2f637-165">Para obtener más información sobre las bases y la motivación Q# , consulte [¿por qué necesitamos Q# ?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span><span class="sxs-lookup"><span data-stu-id="2f637-165">For more background about the foundations and motivation behind Q#, see [Why do we need Q#?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span></span>
