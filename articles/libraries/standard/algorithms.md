---
title: 'Bibliotecas de Q # Standard: algoritmos | Microsoft Docs'
description: Bibliotecas estándar de preguntas y respuestas
author: QuantumWriter
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
ms.openlocfilehash: 61efddb9e7199543370ffd66d08f78ec013f4f79
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 10/29/2019
ms.locfileid: "73185705"
---
# <a name="quantum-algorithms"></a><span data-ttu-id="bb67b-103">Algoritmos Quantum</span><span class="sxs-lookup"><span data-stu-id="bb67b-103">Quantum Algorithms</span></span> #

## <a name="amplitude-amplification"></a><span data-ttu-id="bb67b-104">Amplificación de amplitud</span><span class="sxs-lookup"><span data-stu-id="bb67b-104">Amplitude Amplification</span></span> ##

<span data-ttu-id="bb67b-105">La *amplificación de amplitud* es una de las herramientas fundamentales de la informática Quantum.</span><span class="sxs-lookup"><span data-stu-id="bb67b-105">*Amplitude Amplification* is one of the fundamental tools of Quantum Computing.</span></span> <span data-ttu-id="bb67b-106">Es la idea fundamental que subyace en la búsqueda de Grover, la estimación de amplitudes y muchos algoritmos Quantum de aprendizaje automático.</span><span class="sxs-lookup"><span data-stu-id="bb67b-106">It is the fundamental idea that underlies Grover's search, amplitude estimation and many quantum machine learning algorithms.</span></span>  <span data-ttu-id="bb67b-107">Hay muchas variantes y en Q # se proporciona una versión general basada en la amplificación de amplitud desconocen con reflexiones parciales para permitir el área más amplia de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="bb67b-107">There are many variants, and in Q# we provide a general version based on Oblivious Amplitude Amplification with Partial Reflections to allow for the widest area of application.</span></span>

<span data-ttu-id="bb67b-108">La idea central detrás de la amplificación de amplitud es ampliar la probabilidad de que se produzca un resultado deseado mediante la realización de una secuencia de reflejos.</span><span class="sxs-lookup"><span data-stu-id="bb67b-108">The central idea behind amplitude amplification is to amplify the probability of a desired outcome occurring by performing a sequence of reflections.</span></span>  <span data-ttu-id="bb67b-109">Estas reflexiones giran el estado inicial más cerca de un estado de destino deseado, a menudo denominado estado marcado.</span><span class="sxs-lookup"><span data-stu-id="bb67b-109">These reflections rotate the initial state closer towards a desired target state, often called a marked state.</span></span>  <span data-ttu-id="bb67b-110">En concreto, si la probabilidad de medir el estado inicial en un estado marcado es $ \sin ^ 2 (\theta) $ después de aplicar la amplificación de amplitud $m $ veces, la probabilidad de éxito se convierte en $ \sin ^ 2 ((2m + 1) \theta) $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-110">Specifically, if the probability of measuring the initial state to be in a marked state is $\sin^2(\theta)$ then after applying amplitude amplification $m$ times the probability of success becomes $\sin^2((2m+1)\theta)$.</span></span>  <span data-ttu-id="bb67b-111">Esto significa que si $ \theta = \ PI/[2 (2n + 1)] $ para algún valor de $n $, la amplificación de amplitud es capaz de aumentar la probabilidad de éxito hasta $100\\% $ después de $n $ iteraciones de amplificación de amplitud.</span><span class="sxs-lookup"><span data-stu-id="bb67b-111">This means that if $\theta = \pi/[2(2n+1)]$ for some value of $n$ then amplitude amplification is capable of boosting the probability of success to $100\\%$ after $n$ iterations of amplitude amplification.</span></span>  <span data-ttu-id="bb67b-112">Dado que $ \theta = \sin ^{-1}(\sqrt{\Pr (Success)}) $ esto significa que el número de iteraciones necesarias para obtener un resultado correcto es cuadráticamente inferior al número esperado necesario para encontrar un estado marcado de forma no determinista mediante random muestra.</span><span class="sxs-lookup"><span data-stu-id="bb67b-112">Since $\theta = \sin^{-1}(\sqrt{\Pr(success)})$ this means that the number of iterations needed to obtain a success deterministically is quadratically lower than the expected number needed to find a marked state non-deterministically using random sampling.</span></span>

<span data-ttu-id="bb67b-113">Cada iteración de amplificación de amplitud requiere que se especifiquen dos operadores de reflexión.</span><span class="sxs-lookup"><span data-stu-id="bb67b-113">Each iteration of Amplitude amplification requires that two reflection operators be specified.</span></span> <span data-ttu-id="bb67b-114">En concreto, si $Q $ es la iteración de amplificación de amplitud y $P _0 $ es un operador de proyector en el subespacio inicial y $P _ _ 1 es el proyector en el subespacio marcado y $Q =-(\boldone-2P_0) (\boldone-2P_1) $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-114">Specifically, if $Q$ is the amplitude amplification iterate and $P_0$ is a projector operator onto the initial subspace and $P_1$ is the projector onto the marked subspace then $Q=-(\boldone-2P_0)(\boldone -2P_1)$.</span></span>  <span data-ttu-id="bb67b-115">Recuerde que un proyector es un operador de Hermitian que tiene vectores propios $ + $1 y $0 $ y como resultado $ (\boldone-2P_0) $ es unitario porque tiene vectores propios que son raíces de Unity (en este caso $ \pm $1).</span><span class="sxs-lookup"><span data-stu-id="bb67b-115">Recall that a projector is a Hermitian operator that has eigenvalues $+1$ and $0$ and as a result $(\boldone -2P_0)$ is unitary because it has eigenvalues that are roots of unity (in this case $\pm 1$).</span></span> <span data-ttu-id="bb67b-116">Como ejemplo, considere el caso de la búsqueda de Grover con el estado inicial $H ^ {\otimes n} \ket{0}$ y el estado marcado $ \ket{m} $, $P _0 = H ^ {\otimes n} \ket{0}\bra{0}H ^ {\otimes n} $ y $P _ 1 = \ket{m}\bra{m} $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-116">As an example, consider the case of Grover's search with initial state $H^{\otimes n} \ket{0}$ and marked state $\ket{m}$, $P_0 = H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}$ and $P_1= \ket{m}\bra{m}$.</span></span>  <span data-ttu-id="bb67b-117">En la mayoría de las aplicaciones de amplificación de amplitud $P _0 $ será un proyector en un estado inicial, lo que significa que $P _0 = \boldone-2 \ les {\ PSI} \ Bra {\ PSI} $ para algún vector $ \ket{\psi} $; sin embargo, para la amplitud desconocen amplication $P _0 $ se proyectará normalmente en muchos Estados Quantum (es decir, la multiplicidad de $ + $1 eigenvalue de $P _0 $ es mayor que $1 $).</span><span class="sxs-lookup"><span data-stu-id="bb67b-117">In most applications of amplitude amplification $P_0$ will be a projector onto an initial state meaning that $P_0 = \boldone -2\ket{\psi}\bra{\psi}$ for some vector $\ket{\psi}$; however, for oblivious amplitude amplication $P_0$ will typically project onto many quantum states (i.e. the multiplicity of the $+1$ eigenvalue of $P_0$ is greater than $1$).</span></span>

<span data-ttu-id="bb67b-118">La lógica que subyace a la amplificación de amplitud sigue directamente desde la propios-descomposición de $Q $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-118">The logic behind amplitude amplification follows directly from the eigen-decomposition of $Q$.</span></span>  <span data-ttu-id="bb67b-119">En concreto, el vectores propios de $Q $ que tiene el estado inicial es una compatibilidad distinta de cero que se puede mostrar como una combinación lineal de $ + $1 vectores propios de $P _0 $ y $P _ 1 $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-119">Specifically, the eigenvectors of $Q$ that the initial state has non-zero support over can be shown to be linear combinations of the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="bb67b-120">En concreto, el estado inicial de amplificación de amplitud (suponiendo que es un Eigenvector de $ + $1 de $P _0 $) se puede escribir como $ $ \ket{\psi} = \frac{-i}{\sqrt{2}} \left (e ^ {i\theta} \ les {\ psi_ +} + e ^ {-i\theta} \ les {\ psi_-} \ derecha), $ $ where $ \ket{\psi_\pm } $ son vectores propios de $Q $ con vectores propios $e ^ {\pm 2i \ Theta} $ y solo tienen compatibilidad con la vectores propios de $ + $1 de $P _0 $ y $P _ 1 $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-120">Specifically, the initial state for amplitude amplification (assuming it is a $+1$ eigenvector of $P_0$) can be written as $$ \ket{\psi}=\frac{-i}{\sqrt{2}}\left(e^{i\theta}\ket{\psi_+} + e^{-i\theta}\ket{\psi_-}\right), $$ where $\ket{\psi_\pm}$ are eigenvectors of $Q$ with eigenvalues $e^{\pm  2i\theta}$ and only have support on the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="bb67b-121">El hecho de que los vectores propios se $e ^ {\pm i \theta} $ implica que el operador $Q $ realiza una rotación en un subespacio bidimensional especificado por los dos proyectores y el estado inicial en el que el ángulo de rotación es $2 \ Theta $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-121">The fact that the eigenvalues are $e^{\pm i \theta}$ implies that the operator $Q$ performs a rotation in a two-dimensional subspace specified by the two projectors and the initial state where the rotation angle is $2\theta$.</span></span>  <span data-ttu-id="bb67b-122">Por este motivo, después de $m $ ITERATIONS de $Q $, la probabilidad de éxito es $ \sin ^ 2 ([2m + 1] \theta) $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-122">This is why after $m$ iterations of $Q$ the success probability is $\sin^2([2m+1]\theta)$.</span></span>

<span data-ttu-id="bb67b-123">Otra propiedad útil que sale de esto es que eigenvalue $ \theta $ está directamente relacionado con la probabilidad de que el estado inicial se marcara (en el caso de que $P _0 $ sea un proyector solo en el estado inicial).</span><span class="sxs-lookup"><span data-stu-id="bb67b-123">Another useful property that comes out of this is that the eigenvalue $\theta$ is directly related to probability that the initial state would be marked (in the case where $P_0$ is a projector onto only the initial state).</span></span>  <span data-ttu-id="bb67b-124">Dado que el eigenphases de $Q $ son $2 \ Theta = 2 \ sin ^{-1}(\sqrt{\Pr (Success)}) $, después, si aplicamos la estimación de fase a $Q $, podremos conocer la probabilidad de éxito de un procedimiento de Quantum unitario.</span><span class="sxs-lookup"><span data-stu-id="bb67b-124">Since the eigenphases of $Q$ are $2\theta = 2\sin^{-1}(\sqrt{\Pr(success)})$ it then follows that if we apply phase estimation to $Q$ then we can learn the probability of success for a unitary quantum procedure.</span></span>  <span data-ttu-id="bb67b-125">Esto resulta útil porque requiere menos aplicaciones del procedimiento Quantum de forma cuadrática para conocer la probabilidad de éxito que, de lo contrario, sería necesaria.</span><span class="sxs-lookup"><span data-stu-id="bb67b-125">This is useful because it requires quadratically fewer applications of the quantum procedure to learn the success probability than would otherwise be needed.</span></span>

<span data-ttu-id="bb67b-126">Q # presenta la amplificación de amplitud como una especialización de amplificación de amplitud desconocen.</span><span class="sxs-lookup"><span data-stu-id="bb67b-126">Q# introduces amplitude amplification as a specialization of oblivious amplitude amplification.</span></span>  <span data-ttu-id="bb67b-127">La amplificación de amplitud desconocen gana este moniker porque el proyector en el eigenspace inicial no debe ser un proyector en el estado inicial.</span><span class="sxs-lookup"><span data-stu-id="bb67b-127">Oblivious amplitude amplification earns this moniker because the projector onto the initial eigenspace need not be a projector onto the initial state.</span></span>  <span data-ttu-id="bb67b-128">En este sentido, el protocolo se desconocen al estado inicial.</span><span class="sxs-lookup"><span data-stu-id="bb67b-128">In this sense, the protocol is oblivious to the initial state.</span></span>  <span data-ttu-id="bb67b-129">La aplicación clave de la amplificación de amplitud de desconocen es en determinadas *combinaciones lineales de métodos de simulación de Hamiltonian unitarios* , donde el estado inicial es desconocido, pero se pone inactiva con un registro ancilla en el protocolo de simulación.</span><span class="sxs-lookup"><span data-stu-id="bb67b-129">The key application of oblivious amplitude amplification is in certain *linear combinations of unitary* Hamiltonian simulation methods, wherein the initial state is unknown but becomes entangled with an ancilla register in the simulation protocol.</span></span>  <span data-ttu-id="bb67b-130">Si este registro ancilla se mediera como un valor fijo, por ejemplo, $0 $, estos métodos de simulación aplican la transformación unitario deseada al Qubits restante (denominado registro del sistema).</span><span class="sxs-lookup"><span data-stu-id="bb67b-130">If this ancilla register were to be measured to be a fixed value, say $0$, then such simulation methods apply the desired unitary transformation to the remaining qubits (called the system register).</span></span>  <span data-ttu-id="bb67b-131">Sin embargo, el resto de los resultados de medición conducen a errores.</span><span class="sxs-lookup"><span data-stu-id="bb67b-131">All other measurement outcomes lead to failure however.</span></span>  <span data-ttu-id="bb67b-132">La amplificación de amplitud desconocen permite aumentar la probabilidad de éxito de esta medida hasta $100\\% $ mediante el razonamiento anterior.</span><span class="sxs-lookup"><span data-stu-id="bb67b-132">Oblivious amplitude amplification allows the probability of success of this measurement to be boosted to $100\\%$ using the above reasoning.</span></span>  <span data-ttu-id="bb67b-133">Además, la amplificación de amplitud normal se corresponde con el caso en el que el registro del sistema está vacío.</span><span class="sxs-lookup"><span data-stu-id="bb67b-133">Further, ordinary amplitude amplification corresponds to the case where the system register is empty.</span></span>  <span data-ttu-id="bb67b-134">Este es el motivo por el que Q # usa la amplificación de amplitud desconocen como subrutina de amplificación de amplitud fundamental.</span><span class="sxs-lookup"><span data-stu-id="bb67b-134">This is why Q# uses oblivious amplitude amplification as its fundamental amplitude amplification subroutine.</span></span>

<span data-ttu-id="bb67b-135">La rutina general (`AmpAmpObliviousByReflectionPhases`) tiene dos registros a los que llamamos `ancillaRegister` y `systemRegister`.</span><span class="sxs-lookup"><span data-stu-id="bb67b-135">The general routine (`AmpAmpObliviousByReflectionPhases`) has two registers that we call `ancillaRegister` and `systemRegister`.</span></span> <span data-ttu-id="bb67b-136">También acepta dos Oracle para las reflexiones necesarias.</span><span class="sxs-lookup"><span data-stu-id="bb67b-136">It also accepts two oracles for the necessary reflections.</span></span> <span data-ttu-id="bb67b-137">El `ReflectionOracle` actúa solo en el `ancillaRegister` mientras que el `ObliviousOracle` actúa conjuntamente en ambos registros.</span><span class="sxs-lookup"><span data-stu-id="bb67b-137">The `ReflectionOracle` acts only on the `ancillaRegister` while the `ObliviousOracle` acts jointly on both registers.</span></span> <span data-ttu-id="bb67b-138">La entrada a `ancillaRegister` se debe inicializar en un eigenstate-1 del primer operador de reflexión $ \boldone-2P_1 $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-138">The input to `ancillaRegister` must be initialized to a -1 eigenstate of the first reflection operator $\boldone -2P_1$.</span></span>

<span data-ttu-id="bb67b-139">Normalmente, Oracle prepara el estado en la base de cálculo $ \ket{0...0} $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-139">Typically, the oracle prepares the state in the computational basis $\ket{0...0}$.</span></span> <span data-ttu-id="bb67b-140">En nuestra implementación, la `ancillaRegister` consta de un qubit (`flagQubit`) que controla el `stateOracle` y el resto de los ancillas deseados.</span><span class="sxs-lookup"><span data-stu-id="bb67b-140">In our implementation, the `ancillaRegister` consistes of one qubit (`flagQubit`) that controls the `stateOracle` and the rest of the desired ancillas.</span></span> <span data-ttu-id="bb67b-141">El `stateOracle` se aplica cuando el `flagQubit` es $ \ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="bb67b-141">The `stateOracle` is applied when the `flagQubit` is $\ket{1}$.</span></span>

<span data-ttu-id="bb67b-142">También puede proporcionar a Oracle `StateOracle` y `ObliviousOracle` en lugar de reflexiones a través de una llamada a `AmpAmpObliviousByOraclePhases`.</span><span class="sxs-lookup"><span data-stu-id="bb67b-142">One may also provide oracles `StateOracle` and `ObliviousOracle` instead of reflections via a call to `AmpAmpObliviousByOraclePhases`.</span></span>

<span data-ttu-id="bb67b-143">Como se mencionó, la amplificación de amplitud tradicional es simplemente un caso especial de estas rutinas donde `ObliviousOracle` es el operador de identidad y no hay ningún qubits del sistema (es decir, `systemRegister` está vacío).</span><span class="sxs-lookup"><span data-stu-id="bb67b-143">As mentioned, traditional Amplitude Amplification is just a special case of these routines where `ObliviousOracle` is the identity operator and there are no system qubits (i.e., `systemRegister` is empty).</span></span> <span data-ttu-id="bb67b-144">Si desea obtener fases para las reflexiones parciales (por ejemplo, para la búsqueda de Grover), la función `AmpAmpPhasesStandard` está disponible.</span><span class="sxs-lookup"><span data-stu-id="bb67b-144">If you wish to obtain phases for partial reflections (e.g., for Grover search), the function `AmpAmpPhasesStandard` is available.</span></span> <span data-ttu-id="bb67b-145">Consulte `DatabaseSearch.qs` para obtener una implementación de ejemplo del algoritmo de Grover.</span><span class="sxs-lookup"><span data-stu-id="bb67b-145">Please refer to `DatabaseSearch.qs` for a sample implementation of Grover's algorithm.</span></span>

<span data-ttu-id="bb67b-146">Se relacionan las fases de rotación de un solo qubit con las fases del operador de reflexión tal y como se describe en el documento [G.H. Low, i. L. Chuang](https://arxiv.org/abs/1707.05391).</span><span class="sxs-lookup"><span data-stu-id="bb67b-146">We relate the single-qubit rotation phases to the reflection operator phases as described in the paper by [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span></span> <span data-ttu-id="bb67b-147">Las fases de punto fijo que se usan se detallan en [Yoder, Low y Chuang](https://arxiv.org/abs/1409.3305) junto con las fases en [Low, Yoder y Chuang](https://arxiv.org/abs/1603.03996).</span><span class="sxs-lookup"><span data-stu-id="bb67b-147">The fixed point phases that are used are detailed in [Yoder, Low and Chuang](https://arxiv.org/abs/1409.3305) along with the phases in [Low, Yoder and Chuang](https://arxiv.org/abs/1603.03996).</span></span>

<span data-ttu-id="bb67b-148">Para el fondo, puede empezar a partir de la [amplificación de amplitud estándar](https://arxiv.org/abs/quant-ph/0005055) y pasar a una introducción a la [amplificación de amplitud desconocen](https://arxiv.org/abs/1312.1414) y, por último, generalizaciones presentadas en [Low y Chuang](https://arxiv.org/abs/1610.06546).</span><span class="sxs-lookup"><span data-stu-id="bb67b-148">For background, you could start from [Standard Amplitude Amplification](https://arxiv.org/abs/quant-ph/0005055) then move to an introduction to [Oblivious Amplitude Amplification](https://arxiv.org/abs/1312.1414) and finally generalizations presented in [Low and Chuang](https://arxiv.org/abs/1610.06546).</span></span> <span data-ttu-id="bb67b-149">[Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf)proporcionó una presentación de información general interesante de todo este área (en relación con la simulación de Hamiltonian).</span><span class="sxs-lookup"><span data-stu-id="bb67b-149">A nice overview presentation of this entire area (as it relates to Hamiltonian Simulation) was given by [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span></span>

## <a name="quantum-fourier-transform"></a><span data-ttu-id="bb67b-150">Transformación de Fourier de Quantum</span><span class="sxs-lookup"><span data-stu-id="bb67b-150">Quantum Fourier Transform</span></span> ##

<span data-ttu-id="bb67b-151">La transformación de Fourier es una herramienta fundamental del análisis clásico y es tan importante para los cálculos de Quantum.</span><span class="sxs-lookup"><span data-stu-id="bb67b-151">The Fourier transform is a fundamental tool of classical analysis and is just as important for quantum computations.</span></span>
<span data-ttu-id="bb67b-152">Además, la eficacia de la *transformación de Fourier de Quantum* (QFT) supera en última medida lo que es posible en un equipo clásico que la convierte en una de las primeras herramientas que se pueden elegir al diseñar un algoritmo Quantum.</span><span class="sxs-lookup"><span data-stu-id="bb67b-152">In addition, the efficiency of the *quantum Fourier transform* (QFT) far surpasses what is possible on a classical machine making it one of the first tools of choice when designing a quantum algorithm.</span></span>

<span data-ttu-id="bb67b-153">Como generalización aproximada de QFT, proporcionamos la <xref:microsoft.quantum.canon.approximateqft> operación que permite más optimizaciones mediante la eliminación de las rotaciones que no son estrictamente necesarias para la precisión algorítmica deseada.</span><span class="sxs-lookup"><span data-stu-id="bb67b-153">As an approximate generalization of the QFT, we provide the <xref:microsoft.quantum.canon.approximateqft> operation that allows for further optimizations by pruning rotations that aren't strictly necessary for the desired algorithmic accuracy.</span></span>
<span data-ttu-id="bb67b-154">El QFT aproximado requiere la operación Dyadic $Z $-Rotation <xref:microsoft.quantum.primitive.rfrac> así como la operación <xref:microsoft.quantum.intrinsic.h>.</span><span class="sxs-lookup"><span data-stu-id="bb67b-154">The approximate QFT requires the dyadic $Z$-rotation operation <xref:microsoft.quantum.primitive.rfrac> as well as the <xref:microsoft.quantum.intrinsic.h> operation.</span></span>
<span data-ttu-id="bb67b-155">Se supone que la entrada y la salida se codifican en big endian codificación (el bit más bajo/qubit está a la izquierda, igual que la [notación les](xref:microsoft.quantum.concepts.dirac)).</span><span class="sxs-lookup"><span data-stu-id="bb67b-155">The input and output are assumed to be encoded in big endian encoding (lowest bit/qubit is on the left, same as [ket notation](xref:microsoft.quantum.concepts.dirac)).</span></span>
<span data-ttu-id="bb67b-156">El parámetro de aproximación $a $ determina el nivel de eliminación de los $Z $-rotations, es decir, $a \en [0.. n] $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-156">The approximation parameter $a$ determines the pruning level of the $Z$-rotations, i.e., $a \in [0..n]$.</span></span>
<span data-ttu-id="bb67b-157">En este caso, todos los $Z los giros $2 \ pi/2 ^ k $, donde $k > se quita un $ del circuito QFT.</span><span class="sxs-lookup"><span data-stu-id="bb67b-157">In this case all $Z$-rotations $2\pi/2^k$ where $k > a$ are removed from the QFT circuit.</span></span>
<span data-ttu-id="bb67b-158">Se sabe que para $k \ge \log_2 (n) + \log_2 (1/\epsilon) + $3.</span><span class="sxs-lookup"><span data-stu-id="bb67b-158">It is known that for $k \ge \log_2(n) + \log_2(1 / \epsilon) + 3$.</span></span> <span data-ttu-id="bb67b-159">uno puede enlazar $\\| \operatorname{QFT}-\operatorname{AQFT} \\| < \epsilon $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-159">one can bound $\\| \operatorname{QFT} - \operatorname{AQFT} \\| < \epsilon$.</span></span>
<span data-ttu-id="bb67b-160">Aquí $\\| \cdot\\| $ es la norma de operador, que en este caso es la raíz cuadrada de la [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) mayor de $ (\Operatorname{QFT}-\operatorname{AQFT}) (\Operatorname{QFT}-\operatorname{AQFT}) ^ \dagger $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-160">Here $\\|\cdot\\|$ is the operator norm which in this case is the square root of the largest [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) of $(\operatorname{QFT} - \operatorname{AQFT})(\operatorname{QFT} - \operatorname{AQFT})^\dagger$.</span></span>

## <a name="arithmetic"></a><span data-ttu-id="bb67b-161">Aritméticos</span><span class="sxs-lookup"><span data-stu-id="bb67b-161">Arithmetic</span></span> ##

<span data-ttu-id="bb67b-162">Al igual que las operaciones aritméticas desempeñan un papel fundamental en la informática clásica, también es indispensable en la informática Quantum.</span><span class="sxs-lookup"><span data-stu-id="bb67b-162">Just as arithmetic plays a central role in classical computing, it is also indispensible in quantum computing.</span></span>  <span data-ttu-id="bb67b-163">Los algoritmos como el algoritmo de factorización de mé, los métodos de simulación Quantum y muchos algoritmos Oracular se basan en operaciones aritméticas coherentes.</span><span class="sxs-lookup"><span data-stu-id="bb67b-163">Algorithms such as Shor's factoring algorithm, quantum simulation methods as well as many oracular algorithms rely upon coherent arithmetic operations.</span></span>  <span data-ttu-id="bb67b-164">La mayoría de los enfoques a la compilación aritmética sobre los circuitos de agregación de Quantum.</span><span class="sxs-lookup"><span data-stu-id="bb67b-164">Most approaches to arithmetic build upon quantum adder circuits.</span></span>  <span data-ttu-id="bb67b-165">El agregador más sencillo toma una entrada clásica $b $ y agrega el valor a un estado Quantum que contiene un entero $ \ket{a} $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-165">The simplest adder takes a classical input $b$ and adds the value to a quantum state holding an integer $\ket{a}$.</span></span>  <span data-ttu-id="bb67b-166">Matemáticamente, el agregador (que denotamos $ \operatorname{Add} (b) $ para la entrada clásica $b $) tiene la propiedad que</span><span class="sxs-lookup"><span data-stu-id="bb67b-166">Mathematically, the adder (which we denote $\operatorname{Add}(b)$ for classical input $b$) has the property that</span></span>

<span data-ttu-id="bb67b-167">$ $ \operatorname{Add} (b) \ket{a} = \ket{a + b}.</span><span class="sxs-lookup"><span data-stu-id="bb67b-167">$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.</span></span>
<span data-ttu-id="bb67b-168">$ $ Este circuito de agregación básica es más un incrementador que un agregador.</span><span class="sxs-lookup"><span data-stu-id="bb67b-168">$$ This basic adder circuit is more of an incrementer than an adder.</span></span>
<span data-ttu-id="bb67b-169">Se puede convertir en un agregador que tiene dos entradas Quantum a través de $ $ \operatorname{Add}\ket{a}\ket{b} = \ket{a}\ket{a + b}, $ $ usando $n $ aplicaciones controladas de los agregadores con el formato \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left (\operatorname{Add} (1) \right) \Lambda\_{a\_1} \left (\operatorname{Add} (2) \right) \Lambda\_{a\_2} \left (\operatorname{Add} (4) \right) \cdots \Lambda\_{a\_{n-1}} \left (\ operatorname {Add} ({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} para $n enteros de $-bit $a $ y $b $ y el módulo de suma $2 ^ n $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-169">It can be converted into an adder that has two quantum inputs via $$ \operatorname{Add}\ket{a}\ket{b}=\ket{a}\ket{a+b}, $$ using $n$ controlled applications of adders of the form \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left(\operatorname{Add}(1) \right) \Lambda\_{a\_1} \left(\operatorname{Add}(2) \right) \Lambda\_{a\_2} \left(\operatorname{Add}(4) \right) \cdots \Lambda\_{a\_{n-1}} \left(\operatorname{Add}({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} for $n$-bit integers $a$ and $b$ and addition modulo $2^n$.</span></span>  <span data-ttu-id="bb67b-170">Recuerde que la notación $ \Lambda\_x (A) $ hace referencia, para cualquier operación $A $, a la versión controlada de esa operación con el control qubit $x $ as.</span><span class="sxs-lookup"><span data-stu-id="bb67b-170">Recall that the notation $\Lambda\_x(A)$ refers, for any operation $A$, to the controlled version of that operation with the qubit $x$ as control.</span></span>

<span data-ttu-id="bb67b-171">Del mismo modo, la multiplicación controlada por clases (una forma modular de que es esencial para el algoritmo de factorización de mé) se puede realizar mediante una serie similar de adiciones controladas: \begin{align} \operatorname{Mult} (a) \ket{x}\ket{b} & = \Lambda\_{x\_0} \left (\operatorname{Add} (2 ^ 0 a) \right) \Lambda\_{a\_1} \left (\operatorname{Add} (2 ^ 1A) \right) \Lambda\_{a\_2} \left (\operatorname{Add} (2 ^ 2 a) \right) \cdots \Lambda\_{x\_{ n-1}} \left (\operatorname{Add} ({2 ^ {n-1}} a) \right) \ket{x}\ket{b} \\\\ & = \ket{x}\ket{b + AX}.</span><span class="sxs-lookup"><span data-stu-id="bb67b-171">Similarly, classically controlled multiplication (a modular form of which is essential for Shor's factoring algorithm) can be performed by using a similar series of controlled  additions: \begin{align} \operatorname{Mult}(a)\ket{x}\ket{b} & = \Lambda\_{x\_0}\left(\operatorname{Add}(2^0 a)\right) \Lambda\_{a\_1}\left(\operatorname{Add}(2^1a)\right) \Lambda\_{a\_2}\left(\operatorname{Add}(2^2 a)\right) \cdots \Lambda\_{x\_{n-1}} \left(\operatorname{Add}({2^{n-1}}a) \right)\ket{x}\ket{b} \\\\ & = \ket{x}\ket{b+ax}.</span></span>
<span data-ttu-id="bb67b-172">\end{align} hay un sutileza con la multiplicación en los equipos Quantum que puede observar a partir de la definición de $ \operatorname{Mult} $ anterior.</span><span class="sxs-lookup"><span data-stu-id="bb67b-172">\end{align} There is a subtlety with multiplication on quantum computers that you may notice from the definition of $\operatorname{Mult}$ above.</span></span>  <span data-ttu-id="bb67b-173">A diferencia de la adición, la versión Quantum de este circuito almacena el producto de las entradas en un registro auxiliar en lugar de en el registro de entrada.</span><span class="sxs-lookup"><span data-stu-id="bb67b-173">Unlike addition, the quantum version of this circuit stores the product of the inputs in an ancillary register rather than in the input register.</span></span>  <span data-ttu-id="bb67b-174">En este ejemplo, el registro se inicializa con el valor $b $, pero normalmente empezará a contener el valor cero.</span><span class="sxs-lookup"><span data-stu-id="bb67b-174">In this example, the register is initialized with the value $b$, but typically it will start holding the value zero.</span></span>  <span data-ttu-id="bb67b-175">Esto es necesario en porque, en general, no hay un inverso multiplicativo para el $a general $ y $x $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-175">This is needed in because in general there is not a multiplicative inverse for general $a$ and $x$.</span></span>  <span data-ttu-id="bb67b-176">Dado que todas las operaciones Quantum, Save Measurement, son reversibles, es necesario mantener suficiente información para invertir la multiplicación.</span><span class="sxs-lookup"><span data-stu-id="bb67b-176">Since all quantum operations, save measurement, are reversible we need to keep enough information around to invert the multiplication.</span></span>  <span data-ttu-id="bb67b-177">Por esta razón, el resultado se almacena en una matriz independiente.</span><span class="sxs-lookup"><span data-stu-id="bb67b-177">For this reason the result is stored in a separate array.</span></span>  <span data-ttu-id="bb67b-178">Este truco para guardar la salida de una operación irreversible, como la multiplicación, en un registro independiente se conoce como "Bennett" después de Carlos Bennett y es una herramienta fundamental en la informática reversible y Quantum.</span><span class="sxs-lookup"><span data-stu-id="bb67b-178">This trick of saving the output of an irreversible operation, like multiplication, in a separate register is known as the "Bennett trick" after Charlie Bennett and is a fundamental tool in both reversible and quantum computing.</span></span>

<span data-ttu-id="bb67b-179">Muchos circuitos Quantum se han propuesto para su adición y cada uno de ellos explora un equilibrio diferente en cuanto al número de qubits (espacio) y el número de operaciones de puerta (tiempo) necesarias.</span><span class="sxs-lookup"><span data-stu-id="bb67b-179">Many quantum circuits have been proposed for addition and each explores a different tradeoff in terms of the number of qubits (space) and the number of gate operations (time) required.</span></span>  <span data-ttu-id="bb67b-180">Revisamos dos agregadores eficientes de gran espacio que se indican a continuación, que se conocen como el agregador de Draper y el agregador de Beauregard.</span><span class="sxs-lookup"><span data-stu-id="bb67b-180">We review two highly space efficient adders below known as the Draper adder and the Beauregard adder.</span></span>

### <a name="draper-adder"></a><span data-ttu-id="bb67b-181">Agregador de Draper</span><span class="sxs-lookup"><span data-stu-id="bb67b-181">Draper Adder</span></span> ###

<span data-ttu-id="bb67b-182">El agregador de Draper es posiblemente uno de los agregadores de Quantum más elegantes, ya que invoca directamente las propiedades Quantum para realizar la adición.</span><span class="sxs-lookup"><span data-stu-id="bb67b-182">The Draper adder is arguably one of the most elegant quantum adders, as it directly invokes quantum properties to perform addition.</span></span>  <span data-ttu-id="bb67b-183">La información que se encuentra detrás del agregador de Draper es que la transformación de Fourier se puede usar para traducir los turnos de fase en un desplazamiento de bits.</span><span class="sxs-lookup"><span data-stu-id="bb67b-183">The insight behind the Draper adder is that the Fourier transform can be used to translate phase shifts into a bit shift.</span></span>  <span data-ttu-id="bb67b-184">Después, después de aplicar una transformación de Fourier, aplicar los turnos de fase adecuados y, a continuación, deshacer la transformación de Fourier, puede implementar un agregador.</span><span class="sxs-lookup"><span data-stu-id="bb67b-184">It then follows that by applying a Fourier transform, applying appropriate phase shifts, and then undoing the Fourier transform you can implement an adder.</span></span>  <span data-ttu-id="bb67b-185">A diferencia de muchos otros agregadores propuestos, el agregador de Draper usa explícitamente los efectos de Quantum introducidos a través de la transformación de Fourier de Quantum.</span><span class="sxs-lookup"><span data-stu-id="bb67b-185">Unlike many other adders that have been proposed, the Draper adder explicitly uses quantum effects introduced through the quantum Fourier transform.</span></span>  <span data-ttu-id="bb67b-186">No tiene un homólogo natural natural.</span><span class="sxs-lookup"><span data-stu-id="bb67b-186">It does not have a natural classical counterpart.</span></span>  <span data-ttu-id="bb67b-187">A continuación se proporcionan los pasos específicos del agregador de Draper.</span><span class="sxs-lookup"><span data-stu-id="bb67b-187">The specific steps of the Draper adder are given below.</span></span>

<span data-ttu-id="bb67b-188">Supongamos que tiene dos $n qubit $-bit registra el almacenamiento de los enteros $a $ y $b $, para todos los $a $ $ $ \operatorname{QFT}\ket{a} = \frac{1}{\sqrt{2 ^ n}} \sum\_{j = 0} ^ {2 ^ n-1} e ^ {i2\pi (AJ)/2 ^ n} \ket{j}.</span><span class="sxs-lookup"><span data-stu-id="bb67b-188">Assume that you have two $n$-bit qubit registers storing the integers $a$ and $b$ then for all $a$ $$ \operatorname{QFT}\ket{a}= \frac{1}{\sqrt{2^n}}\sum\_{j=0}^{2^n-1} e^{i2\pi(aj)/2^n} \ket{j}.</span></span>
<span data-ttu-id="bb67b-189">$ $ Si definimos $ $ \ket{\phi\_k (a)} = \frac{1}{\sqrt{2}} \left (\ket{0} + e ^ {i2\pi a/2 ^ k} \ket{1} \right), $ $ después de algún álgebra puede ver que $ $ \operatorname{QFT}\ket{a} = \ket{\phi\_1 (a)} \otimes \cdots \ otimes \ket{\phi\_n (a)}.</span><span class="sxs-lookup"><span data-stu-id="bb67b-189">$$ If we define $$ \ket{\phi\_k(a)} = \frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi a /2^k}\ket{1} \right), $$ then after some algebra you can see that $$ \operatorname{QFT}\ket{a}=\ket{\phi\_1(a)}\otimes \cdots \otimes \ket{\phi\_n(a)}.</span></span>
<span data-ttu-id="bb67b-190">$ $ La ruta de acceso para realizar un agregador se queda clara después de observar que la suma de las entradas se puede escribir como $ $ \ket{a + b} = \operatorname{QFT} ^{-1}\ket{\phi\_1 (a + b)} \otimes \cdots \otimes \ket{\phi\_n (a + b)}.</span><span class="sxs-lookup"><span data-stu-id="bb67b-190">$$ The path towards performing an adder then becomes clear after observing that the sum of the inputs can be written as $$ \ket{a+b}=\operatorname{QFT}^{-1}\ket{\phi\_1(a+b)}\otimes \cdots \otimes \ket{\phi\_n(a+b)}.</span></span>
<span data-ttu-id="bb67b-191">$ $ Los enteros $b $ y $a $ se pueden agregar al realizar una rotación de fase controlada en cada una de las qubits de la descomposición usando los bits de los controles $b $ as.</span><span class="sxs-lookup"><span data-stu-id="bb67b-191">$$ The integers $b$ and $a$ can then be added by performing controlled-phase rotation on each of the qubits in the decomposition using the bits of $b$ as controls.</span></span>

<span data-ttu-id="bb67b-192">Esta expansión se puede simplificar aún más indicando que para cualquier entero $j $ y el número real $x $, $e ^ {i2\pi (x + j)} = e ^ {i2\pi x} $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-192">This expansion can be further simplified by noting that for any integer $j$ and real number $x$, $e^{i2\pi(x+j)}=e^{i2\pi x}$.</span></span>  <span data-ttu-id="bb67b-193">Esto se debe a que si gira $360 ^ {\circ} $ degrees ($ 2 \ PI $ radianes) en un círculo, acabará exactamente donde comenzó.</span><span class="sxs-lookup"><span data-stu-id="bb67b-193">This is because if you rotate $360^{\circ}$ degrees ($2\pi$ radians) in a circle then you end up precisely where you started.</span></span>  <span data-ttu-id="bb67b-194">La única parte importante de $x $ para $e ^ {i2\pi x} $ es, por lo tanto, la parte fraccionaria de $x $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-194">The only important part of $x$ for $e^{i2\pi x}$ is therefore the fractional part of $x$.</span></span>  <span data-ttu-id="bb67b-195">En concreto, si tenemos una expansión binaria con el formato $x = y +0. x\_0x\_2 \ ldots x\_n $ $e ^ {i2\pi x} = e ^ {i2\pi (0. x\_0x\_2 \ ldots x\_{n-1})} $ y, por tanto, $ $ \ket{\ Phi\_k (a + b)} = \frac{1}{\sqrt{2}} \left (\ket{0} + e ^ {i2\pi [a/2 ^ k +0. b\_k\ldots b\_1]} \ket{1} \right). $ $ Esto significa que si realizamos la adición incrementando cada una de las tensores factores en la expansión de la transformación de Fourier de $ \ket{a} $, el número de giros se reduce como $k $ reduce.</span><span class="sxs-lookup"><span data-stu-id="bb67b-195">Specifically, if we have a binary expansion of the form $x=y+0.x\_0x\_2\ldots x\_n$ then $e^{i2\pi x}=e^{i2\pi (0.x\_0x\_2\ldots x\_{n-1})}$ and hence $$\ket{\phi\_k(a+b)}=\frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi [a/2^k+0.b\_k\ldots b\_1]}\ket{1} \right).$$ This means that if we perform addition by incrementing each of the tensor factors in the expansion of the Fourier transform of $\ket{a}$ then the number of rotations shrinks as $k$ decreases.</span></span>  <span data-ttu-id="bb67b-196">Esto reduce considerablemente el número de puertas de Quantum necesarias en el agregador.</span><span class="sxs-lookup"><span data-stu-id="bb67b-196">This substantially reduces the number of quantum gates needed in the adder.</span></span>  <span data-ttu-id="bb67b-197">Denotamos los pasos transformación de Fourier, adición de fase y transformación de Fourier inversos que forman el agregador de Draper como $ \operatorname{QFT} ^{-1} \left (\phi\\\!\operatorname{ADD}\right) \operatorname{QFT} $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-197">We denote the Fourier transform, phase addition and the inverse Fourier transform steps that comprise the Draper adder as $\operatorname{QFT}^{-1} \left(\phi\\\!\operatorname{ADD}\right) \operatorname{QFT}$.</span></span> <span data-ttu-id="bb67b-198">A continuación, se puede observar un circuito de Quantum que usa esta simplificación para implementar todo el proceso.</span><span class="sxs-lookup"><span data-stu-id="bb67b-198">A quantum circuit that uses this simplification to implement the entire process can be seen below.</span></span>

![El agregador de Draper se muestra como diagrama de circuito](~/media/draper.png)

<span data-ttu-id="bb67b-200">Cada puerta controlada $e ^ {I2 \ PI/k} $ del circuito hace referencia a una puerta de fase controlada.</span><span class="sxs-lookup"><span data-stu-id="bb67b-200">Each controlled $e^{i2\pi/k}$ gate in the circuit refers to a controlled-phase gate.</span></span>  <span data-ttu-id="bb67b-201">Estas puertas tienen la propiedad que en el par de qubits en el que actúan, $ \ket{00}\mapsto \ket{00}$ pero $ \ket{11}\mapsto e ^ {I2 \ PI/k} \ les{11}$.</span><span class="sxs-lookup"><span data-stu-id="bb67b-201">Such gates have the property that on the pair of qubits on which they act, $\ket{00}\mapsto \ket{00}$ but $\ket{11}\mapsto e^{i2\pi/k}\ket{11}$.</span></span>  <span data-ttu-id="bb67b-202">Este circuito nos permite realizar adiciones sin qubits adicionales, aparte de las necesarias para almacenar las entradas y las salidas.</span><span class="sxs-lookup"><span data-stu-id="bb67b-202">This circuit allows us to perform addition using no additional qubits apart from those needed to store the inputs and the outputs.</span></span>

### <a name="beauregard-adder"></a><span data-ttu-id="bb67b-203">Agregador de Beauregard</span><span class="sxs-lookup"><span data-stu-id="bb67b-203">Beauregard Adder</span></span> ###

<span data-ttu-id="bb67b-204">El agregador de Beauregard es un agregador modular de Quantum que usa el agregador de Draper para realizar el módulo de suma $N $ para un entero positivo de valor arbitrario $N $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-204">The Beauregard adder is a quantum modular adder that uses the Draper adder in order to perform addition modulo $N$ for an arbitrary value positive integer $N$.</span></span>  <span data-ttu-id="bb67b-205">La importancia de los agregados modulares Quantum, como el agregador de Beauregard, se deriva en gran medida de su uso en el paso de exponenciación modular dentro del algoritmo de mé para la factorización.</span><span class="sxs-lookup"><span data-stu-id="bb67b-205">The significance of quantum modular adders, such as the Beauregard adder, stems to a large extent from their use in the modular exponentiation step within Shor's algorithm for factoring.</span></span>  <span data-ttu-id="bb67b-206">Un agregador modular Quantum tiene la siguiente acción para la entrada Quantum $ \ket{b} $ y la entrada clásica $a $, donde $a $ y $b $ se promete que sean enteros mod $N $, lo que significa que se encuentran en el intervalo $ [0, \ldots, N-1] $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-206">A quantum modular adder has the following action for quantum input $\ket{b}$ and classical input $a$ where $a$ and $b$ are promised to be integers mod $N$, meaning that they are in the interval $[0,\ldots, N-1]$.</span></span>

<span data-ttu-id="bb67b-207">$ $ \ket{b}\rightarrow \ket{b + a \text{mod} N} = \begin{Cases} \ket{b + a}, & b + a < N\\\\ \ket{b + a-N}, & (b + a) \ge N \end{cases}.</span><span class="sxs-lookup"><span data-stu-id="bb67b-207">$$ \ket{b}\rightarrow \ket{b+a \text{ mod }N}=\begin{cases} \ket{b+a},& b+a < N\\\\ \ket{b+a-N},& (b+a)\ge N \end{cases}.</span></span>
$$

<span data-ttu-id="bb67b-208">El agregador de Beauregard usa el agregador de Draper, o más específicamente $ \phi\\\!\operatorname{ADD} $, para agregar $a $ y $b $ en la fase.</span><span class="sxs-lookup"><span data-stu-id="bb67b-208">The Beauregard adder uses the Draper adder, or more specifically $\phi\\\!\operatorname{ADD}$, to add $a$ and $b$ in phase.</span></span>  <span data-ttu-id="bb67b-209">A continuación, usa la misma operación para identificar si $a + b < N $ restando $N $ y prueba si $a + b-N < 0 $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-209">It then uses the same operation to identify whether $a+b <N$ by subtracting $N$ and testing if $a+b-N<0$.</span></span>  <span data-ttu-id="bb67b-210">El circuito almacena esta información en un qubit auxiliar y, a continuación, agrega $N $ al registro si $a + b < N $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-210">The circuit stores this information in an ancillary qubit and then adds $N$ back the register if $a+b<N$.</span></span>  <span data-ttu-id="bb67b-211">A continuación, concluye descalculando este bit auxiliar (este paso es necesario para asegurarse de que se puede anular la asignación de ancilla después de llamar al agregador).</span><span class="sxs-lookup"><span data-stu-id="bb67b-211">It then concludes by uncomputing this ancillary bit (this step is needed to ensure that the ancilla can be de-allocated after calling the adder).</span></span>  <span data-ttu-id="bb67b-212">A continuación se proporciona el circuito del agregador de Beauregard.</span><span class="sxs-lookup"><span data-stu-id="bb67b-212">The circuit for the Beauregard adder is given below.</span></span>

![El agregador de Beauregard se muestra como diagrama de circuito](~/media/beau.png)

<span data-ttu-id="bb67b-214">Aquí, la puerta $ \Phi\\\!\operatorname{ADD} $ tiene el mismo formato que $ \Phi\\\!\operatorname{ADD} $, salvo que en este contexto la entrada es clásica en lugar de Quantum.</span><span class="sxs-lookup"><span data-stu-id="bb67b-214">Here the gate $\Phi\\\!\operatorname{ADD}$ takes the same form as $\phi\\\!\operatorname{ADD}$ except that in this context the input is classical rather than quantum.</span></span>  <span data-ttu-id="bb67b-215">Esto permite que las fases controladas en $ \Phi\\\!\operatorname{ADD} $ se reemplacen con las puertas de fase que se pueden compilar en menos operaciones para reducir el número de qubits y el número de puertas necesarias para el agregador.</span><span class="sxs-lookup"><span data-stu-id="bb67b-215">This allows the controlled phases in $\Phi\\\!\operatorname{ADD}$ to be replaced with phase gates that can then be compiled together into fewer operations to reduce both the number of qubits and number of gates needed for the adder.</span></span>

<span data-ttu-id="bb67b-216">Para obtener más información, consulte [M. Roetteler, TH. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) y [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span><span class="sxs-lookup"><span data-stu-id="bb67b-216">For more details, please refer to [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) and [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span></span>

### <a name="quantum-phase-estimation"></a><span data-ttu-id="bb67b-217">Estimación de fase Quantum</span><span class="sxs-lookup"><span data-stu-id="bb67b-217">Quantum Phase Estimation</span></span> ###

<span data-ttu-id="bb67b-218">Una aplicación especialmente importante de la transformación de Fourier de Quantum es obtener información sobre los vectores propios de los operadores unitarios, un problema conocido como *estimación de fase*.</span><span class="sxs-lookup"><span data-stu-id="bb67b-218">One particularly important application of the quantum Fourier transform is to learn the eigenvalues of unitary operators, a problem known as *phase estimation*.</span></span>
<span data-ttu-id="bb67b-219">Considere la posibilidad de una $U unitario $ y un estado $ \ket{\phi} $, de modo que $ \ket{\phi} $ sea un eigenstate de $U $ con Unknown eigenvalue $ \phi $, \begin{Equation} U\ket {\ Phi} = \phi\ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="bb67b-219">Consider a unitary $U$ and a state $\ket{\phi}$ such that $\ket{\phi}$ is an eigenstate of $U$ with unknown eigenvalue $\phi$, \begin{equation} U\ket{\phi} = \phi\ket{\phi}.</span></span>
<span data-ttu-id="bb67b-220">\end{Equation} si solo tenemos acceso a $U $ como Oracle, podremos obtener información sobre la fase $ \phi $ mediante el uso de que $Z $ rotaciones aplicadas al destino de una operación controlada se propagan de nuevo al control.</span><span class="sxs-lookup"><span data-stu-id="bb67b-220">\end{equation} If we only have access to $U$ as an oracle, then we can learn the phase $\phi$ by utilizing that $Z$ rotations applied to the target of a controlled operation propagate back onto the control.</span></span>

<span data-ttu-id="bb67b-221">Supongamos que $V $ es una aplicación controlada de $U $, de modo que \begin{align} V (\ket{0} \otimes \ket{\phi}) & = \ket{0} \otimes \ket{\phi} \\\\ \textrm{y} V (\ket{1} \otimes \ket{\phi}) & = e ^ {i \phi} \ket{1}  \otimes \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="bb67b-221">Suppose that $V$ is a controlled application of $U$, such that \begin{align} V (\ket{0} \otimes \ket{\phi}) & =            \ket{0} \otimes \ket{\phi} \\\\ \textrm{ and } V (\ket{1} \otimes \ket{\phi}) & = e^{i \phi} \ket{1} \otimes \ket{\phi}.</span></span>
<span data-ttu-id="bb67b-222">\end{align}, por linearity, \begin{align} V (\ket{+} \otimes \ket{\phi}) & = \frac{(\ket{0} \otimes \ket{\phi}) + e ^ {i \phi} (\ket{1} \otimes \ket{\phi})} {\sqrt{2}}.</span><span class="sxs-lookup"><span data-stu-id="bb67b-222">\end{align} Then, by linearity, \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{ (\ket{0} \otimes \ket{\phi}) + e^{i \phi} (\ket{1} \otimes \ket{\phi}) }{\sqrt{2}}.</span></span>
<span data-ttu-id="bb67b-223">\end{align} podemos recopilar términos para encontrar que \begin{align} V (\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e ^ {i \phi} \ket{1}} {\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1 (\phi) \ket{+}) \otimes \ket{\phi} , \end{align} donde $R _ 1 _ es la unitario aplicada por la operación de <xref:microsoft.quantum.intrinsic.r1>.</span><span class="sxs-lookup"><span data-stu-id="bb67b-223">\end{align} We can collect terms to find that \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e^{i \phi} \ket{1}}{\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1(\phi) \ket{+}) \otimes \ket{\phi}, \end{align} where $R_1$ is the unitary applied by the <xref:microsoft.quantum.intrinsic.r1> operation.</span></span>
<span data-ttu-id="bb67b-224">Y se colocan de forma diferente, el efecto de aplicar $V $ es precisamente el mismo que aplicar $R _ 1 _ 1 con un ángulo desconocido, aunque solo se tiene acceso a $V $ como Oracle.</span><span class="sxs-lookup"><span data-stu-id="bb67b-224">Put differently, the effect of applying $V$ is precisely the same as applying $R_1$ with an unknown angle, even though we only have access to $V$ as an oracle.</span></span>
<span data-ttu-id="bb67b-225">Por lo tanto, en el resto de este debate se tratará la estimación de fases en términos de $R _ 1 (\phi) $, que se implementan mediante el uso de la *fase Kickback*.</span><span class="sxs-lookup"><span data-stu-id="bb67b-225">Thus, for the rest of this discussion we will discuss phase estimation in terms of $R_1(\phi)$, which we implement by using so-called *phase kickback*.</span></span>

<span data-ttu-id="bb67b-226">Dado que el registro de destino y el control permanecen inalterados después de este proceso, podemos volver a usar $ \ket{\phi} $ como destino de una aplicación controlada de $U ^ $2 para preparar un segundo control qubit en el estado $R _ 1 (2 \phi) \ket{+} $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-226">Since the control and target register remain untangled after this process, we can reuse $\ket{\phi}$ as the target of a controlled application of $U^2$ to prepare a second control qubit in the state $R_1(2 \phi) \ket{+}$.</span></span>
<span data-ttu-id="bb67b-227">Continuando de este modo, podemos obtener un registro con el formato \begin{align} \ket{\psi} & = \sum_{j = 0} ^ n R_1 (2 ^ j \phi) \ket{+} \\\\ & \propto \bigotimes_{j = 0} ^ {n} \left (\ket{0} + \exp (i 2 ^ {j} \phi) \ket{1}\right) @no__ t_4_ \\ & \propto \sum_{k = 0} ^ {2 ^ n-1} \exp (i \phi k) \ket{k} \end{align}, donde $n $ es el número de bits de precisión que se requiere y donde se ha usado ${} \propto {}$ para indicar que se ha suprimido el factor de normalización de $ 1/\sqrt{2 ^ n} $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-227">Continuing in this way, we can obtain a register of the form \begin{align} \ket{\psi} & = \sum_{j = 0}^n R_1(2^j \phi) \ket{+} \\\\ & \propto \bigotimes_{j=0}^{n} \left(\ket{0} + \exp(i 2^{j} \phi) \ket{1}\right) \\\\ & \propto \sum_{k = 0}^{2^n - 1} \exp(i \phi k) \ket{k} \end{align} where $n$ is the number of bits of precision that we require, and where we have used ${} \propto {}$ to indicate that we have suppressed the normalization factor of $1 / \sqrt{2^n}$.</span></span>

<span data-ttu-id="bb67b-228">Si damos por hecho que $ \phi = 2 \pi p/2 ^ k $ para un entero $p $, se reconocerá como $ \ket{\psi} = \operatorname{QFT} \ket{p_0 P_1 \dots p_n} $, donde $p _J $ es el $j ^ {\textrm{TH}} $ bit de $2 \pi \phi $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-228">If we assume that $\phi = 2 \pi p / 2^k$ for an integer $p$, then we recognize this as $\ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n}$, where $p_j$ is the $j^{\textrm{th}}$ bit of $2 \pi \phi$.</span></span>
<span data-ttu-id="bb67b-229">Al aplicar el contiguo de la transformación de Fourier de Quantum, se obtiene la representación binaria de la fase codificada como estado de Quantum.</span><span class="sxs-lookup"><span data-stu-id="bb67b-229">Applying the adjoint of the quantum Fourier transform, we therefore obtain the binary representation of the phase encoded as a quantum state.</span></span>

<span data-ttu-id="bb67b-230">En Q #, esto lo implementa la operación <xref:microsoft.quantum.characterization.quantumphaseestimation>, que toma <xref:microsoft.quantum.oracles.discreteoracle> aplicación de implementación de $U ^ m $ como una función de enteros positivos $m $.</span><span class="sxs-lookup"><span data-stu-id="bb67b-230">In Q#, this is implemented by the <xref:microsoft.quantum.characterization.quantumphaseestimation> operation, which takes a <xref:microsoft.quantum.oracles.discreteoracle> implementing application of $U^m$ as a function of positive integers $m$.</span></span>
