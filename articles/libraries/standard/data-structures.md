---
title: Estructuras de datos de las bibliotecas estándar de preguntas y respuestas
description: Obtenga información sobre las estructuras de datos, Oracle y generadores dinámicos en las bibliotecas de preguntas y respuestas estándar de Microsoft.
author: QuantumWriter
uid: microsoft.quantum.libraries.data-structures
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 46ac6794d1e21e111aa1d98e11a6f83194f8d54e
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907790"
---
# <a name="data-structures-and-modeling"></a><span data-ttu-id="ce5d8-103">Modelado y estructuras de datos</span><span class="sxs-lookup"><span data-stu-id="ce5d8-103">Data Structures and Modeling</span></span> #

## <a name="classical-data-structures"></a><span data-ttu-id="ce5d8-104">Estructuras de datos clásicas</span><span class="sxs-lookup"><span data-stu-id="ce5d8-104">Classical Data Structures</span></span> ##

<span data-ttu-id="ce5d8-105">Junto con los tipos definidos por el usuario para representar los conceptos de Quantum, el Canon también proporciona operaciones, funciones y tipos para trabajar con datos de uso clásico en el control de sistemas Quantum.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-105">Along with user-defined types for representing quantum concepts, the canon also provides operations, functions, and types for working with classical data used in the control of quantum systems.</span></span>
<span data-ttu-id="ce5d8-106">Por ejemplo, la función <xref:microsoft.quantum.arrays.reversed> toma una matriz como entrada y devuelve la misma matriz en orden inverso.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-106">For instance, the <xref:microsoft.quantum.arrays.reversed> function takes an array as input and returns the same array in reverse order.</span></span>
<span data-ttu-id="ce5d8-107">A continuación, se puede usar en una matriz de tipo `Qubit[]` para evitar tener que aplicar las puertas $ \operatorname{SWAP} $ innecesarias al convertir entre representaciones de Quantum de enteros.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-107">This can then be used on an array of type `Qubit[]` to avoid having to apply unnecessary $\operatorname{SWAP}$ gates when converting between quantum representations of integers.</span></span>
<span data-ttu-id="ce5d8-108">Del mismo modo, vimos en la sección anterior que los tipos de `(Int, Int -> T)` de formulario pueden ser útiles para representar colecciones de acceso aleatorio, por lo que la función <xref:microsoft.quantum.arrays.lookupfunction> proporciona una forma cómoda de construir estos tipos a partir de tipos de matriz.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-108">Similarly, we saw in the previous section that types of the form `(Int, Int -> T)` can be useful for representing random access collections, so the <xref:microsoft.quantum.arrays.lookupfunction> function provides a convenient way of constructing such types from array types.</span></span>

### <a name="pairs"></a><span data-ttu-id="ce5d8-109">Pair</span><span class="sxs-lookup"><span data-stu-id="ce5d8-109">Pairs</span></span> ###

<span data-ttu-id="ce5d8-110">Canon admite la notación de estilo funcional para pares, que complementa el acceso a tuplas mediante la desconstrucción:</span><span class="sxs-lookup"><span data-stu-id="ce5d8-110">The canon supports functional-style notation for pairs, complementing accessing tuples by deconstruction:</span></span>

```qsharp
let pair = (PauliZ, register); // type (Pauli, Qubit[])
ApplyToEach(H, Snd(pair)); // No need to deconstruct to access the register.
```

### <a name="arrays"></a><span data-ttu-id="ce5d8-111">Matrices</span><span class="sxs-lookup"><span data-stu-id="ce5d8-111">Arrays</span></span> ###

<span data-ttu-id="ce5d8-112">La Canon proporciona varias funciones para manipular matrices.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-112">The canon provides several functions for manipulating arrays.</span></span>
<span data-ttu-id="ce5d8-113">Estas funciones son con parámetros de tipo y, por tanto, se pueden usar con matrices de cualquier tipo de Q #.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-113">These functions are type-parameterized, and thus can be used with arrays of any Q# type.</span></span>
<span data-ttu-id="ce5d8-114">Por ejemplo, la función <xref:microsoft.quantum.arrays.reversed> devuelve una nueva matriz cuyos elementos están en orden inverso al de su entrada.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-114">For instance, the <xref:microsoft.quantum.arrays.reversed> function returns a new array whose elements are in reverse order from its input.</span></span>
<span data-ttu-id="ce5d8-115">Se puede usar para cambiar el modo en que se representa un registro de Quantum cuando se llama a las operaciones:</span><span class="sxs-lookup"><span data-stu-id="ce5d8-115">This can be used to change how a quantum register is represented when calling operations:</span></span>

```qsharp
let leRegister = LittleEndian(register);
// QFT expects a BigEndian, so we can reverse before calling.
QFT(BigEndian(Reversed(leRegister!)));
// This is how the LittleEndianAsBigEndian function is implemented:
QFT(LittleEndianAsBigEndian(leRegister));
```

<span data-ttu-id="ce5d8-116">Del mismo modo, la función <xref:microsoft.quantum.arrays.subarray> se puede usar para reordenar o tomar subconjuntos de los elementos de una matriz:</span><span class="sxs-lookup"><span data-stu-id="ce5d8-116">Similarly, the <xref:microsoft.quantum.arrays.subarray> function can be used to reorder or take subsets of the elements of an array:</span></span>

```qsharp
// Applies H to qubits 2 and 5.
ApplyToEach(H, Subarray([2, 5], register));
```

<span data-ttu-id="ce5d8-117">Cuando se combina con el control de flujo, las funciones de manipulación de matrices como <xref:microsoft.quantum.arrays.zip> pueden proporcionar una manera eficaz de expresar programas Quantum:</span><span class="sxs-lookup"><span data-stu-id="ce5d8-117">When combined with flow control, array manipulation functions such as <xref:microsoft.quantum.arrays.zip> can provide a powerful way to express quantum programs:</span></span>

```qsharp
// Applies X₃ Y₁ Z₇ to a register of any size.
ApplyToEach(
    ApplyPauli(_, register),
    Map(
        EmbedPauli(_, _, Length(register)),
        Zip([PauliX, PauliY, PauliZ], [3, 1, 7])
    )
);
```

## <a name="oracles"></a><span data-ttu-id="ce5d8-118">Oracle</span><span class="sxs-lookup"><span data-stu-id="ce5d8-118">Oracles</span></span> ##

<span data-ttu-id="ce5d8-119">En la literatura de estimación de la [fase](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) y de la [amplificación de amplitud](https://en.wikipedia.org/wiki/Amplitude_amplification) , el concepto de Oracle aparece con frecuencia.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-119">In the [phase estimation](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) and [amplitude amplification](https://en.wikipedia.org/wiki/Amplitude_amplification) literature the concept of an oracle appears frequently.</span></span>
<span data-ttu-id="ce5d8-120">Aquí el término Oracle hace referencia a una subrutina caja negra Quantum que actúa sobre un conjunto de qubits y devuelve la respuesta como una fase.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-120">Here the term oracle refers to a blackbox quantum subroutine that acts upon a set of qubits and returns the answer as a phase.</span></span>
<span data-ttu-id="ce5d8-121">Esta subrutina a menudo se puede considerar como una entrada a un algoritmo Quantum que acepta Oracle, además de otros parámetros, y aplica una serie de operaciones Quantum y el tratamiento de una llamada a esta subrutina Quantum como si fuera una puerta fundamental.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-121">This subroutine often can be thought of as an input to a quantum algorithm that accepts the oracle, in addition to some other parameters, and applies a series of quantum operations and treating a call to this quantum subroutine as if it were a fundamental gate.</span></span>
<span data-ttu-id="ce5d8-122">Obviamente, para implementar el algoritmo más grande, se debe proporcionar una descomposición concreta de Oracle en las puertas fundamentales, pero no es necesaria una descomposición para comprender el algoritmo que llama a Oracle.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-122">Obviously, in order to actually implement the larger algorithm a concrete decomposition of the oracle into fundamental gates must be provided but such a decomposition is not needed in order to understand the algorithm that calls the oracle.</span></span>
<span data-ttu-id="ce5d8-123">En Q #, esta abstracción se representa mediante el uso de que las operaciones son valores de primera clase, de modo que las operaciones se pueden pasar a las implementaciones de los algoritmos Quantum de manera negra.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-123">In Q#, this abstraction is represented by using that operations are first-class values, such that operations can be passed to implementations of quantum algorithms in a black-box manner.</span></span>
<span data-ttu-id="ce5d8-124">Además, los tipos definidos por el usuario se usan para etiquetar las distintas representaciones de Oracle de una manera con seguridad de tipos, lo que dificulta la creación accidental de diferentes tipos de operaciones de caja negra.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-124">Moreover, user-defined types are used to label the different oracle representations in a type-safe way, making it difficult to accidentally conflate different kinds of black box operations.</span></span>

<span data-ttu-id="ce5d8-125">Estas Oracle aparecen en varios contextos diferentes, incluidos ejemplos famosos como los algoritmos [de búsqueda y de simulación de Quantum de Grover](https://en.wikipedia.org/wiki/Grover%27s_algorithm) .</span><span class="sxs-lookup"><span data-stu-id="ce5d8-125">Such oracles appear in a number of different contexts, including famous examples such as [Grover's search](https://en.wikipedia.org/wiki/Grover%27s_algorithm) and quantum simulation algorithms.</span></span>
<span data-ttu-id="ce5d8-126">Aquí nos centramos en los Oracle necesarios solo para dos aplicaciones: amplificación de amplitud y estimación de fase.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-126">Here we focus on the oracles needed for just two applications: amplitude amplification and phase estimation.</span></span>
<span data-ttu-id="ce5d8-127">En primer lugar, analizaremos la amplificación de amplitud Oracle antes de proceder a la estimación de fase.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-127">We will first discuss amplitude amplification oracles before proceeding to phase estimation.</span></span>

### <a name="amplitude-amplification-oracles"></a><span data-ttu-id="ce5d8-128">Oracle de amplificación de amplitud</span><span class="sxs-lookup"><span data-stu-id="ce5d8-128">Amplitude Amplification Oracles</span></span> ###

<span data-ttu-id="ce5d8-129">El algoritmo de amplificación de amplitud pretende realizar una rotación entre un estado inicial y un estado final aplicando una secuencia de reflexiones del estado.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-129">The amplitude amplification algorithm aims to perform a rotation between an initial state and a final state by applying a sequence of reflections of the state.</span></span>
<span data-ttu-id="ce5d8-130">Para que el algoritmo funcione, necesita una especificación de ambos Estados.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-130">In order for the algorithm to function, it needs a specification of both of these states.</span></span>
<span data-ttu-id="ce5d8-131">Estas especificaciones las proporcionan dos Oracle.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-131">These specifications are given by two oracles.</span></span>
<span data-ttu-id="ce5d8-132">Estas Oracle funcionan dividiendo las entradas en dos espacios, un subespacio de "destino" y un subespacio "inicial".</span><span class="sxs-lookup"><span data-stu-id="ce5d8-132">These oracles work by breaking the inputs into two spaces, a "target" subspace and an "initial" subspace.</span></span>
<span data-ttu-id="ce5d8-133">Los Oracle identifican estos subespacios, de forma similar al modo en que los operadores de Pauli identifican dos espacios, aplicando una fase de $ \pm $1 a estos espacios.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-133">The oracles identify such subspaces, similar to how Pauli operators identify two spaces, by applying a $\pm 1$ phase to these spaces.</span></span>
<span data-ttu-id="ce5d8-134">La principal diferencia es que no es necesario que estos espacios estén en medio espacio en esta aplicación.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-134">The main difference is that these spaces need not be half-spaces in this application.</span></span>
<span data-ttu-id="ce5d8-135">Tenga en cuenta también que estos dos subespacios no suelen ser mutuamente excluyentes: habrá vectores que sean miembros de ambos espacios.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-135">Also note that these two subspaces are not usually mutually exclusive: there will be vectors that are members of both spaces.</span></span>
<span data-ttu-id="ce5d8-136">Si no se cumple esto, la amplificación de amplitud no tendría ningún efecto, por lo que necesitamos que el subespacio inicial tenga una superposición distinta de cero con el subespacio de destino.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-136">If this were not true then amplitude amplification would have no effect so we need the initial subspace to have non-zero overlap with the target subspace.</span></span>

<span data-ttu-id="ce5d8-137">Indicaremos la primera Oracle que necesitamos para que se $P la amplificación de amplitud\_$0, que se define para que tenga la siguiente acción.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-137">We will denote the first oracle that we need for amplitude amplification to be $P\_0$, defined to have the following action.</span></span>  <span data-ttu-id="ce5d8-138">Para todos los Estados $ \ket{x} $ en el subespacio "inicial" $P\_0 \ket{x} =-\ket{x} $ y para todos los Estados $ \ket{y} $ que no están en este subespacio, tenemos $P\_0 \ket{y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-138">For all states $\ket{x}$ in the "initial" subspace $P\_0 \ket{x} = -\ket{x}$ and for all states $\ket{y}$ that are not in this subspace we have $P\_0 \ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="ce5d8-139">La Oracle que marca el subespacio de destino, $P _ 1 _, toma exactamente la misma forma.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-139">The oracle that marks the target subspace, $P_1$, takes exactly the same form.</span></span>
<span data-ttu-id="ce5d8-140">Para todos los Estados $ \ket{x} $ en el subespacio de destino (es decir, para todos los Estados en los que desea que se genere el algoritmo), $P _ 1 \ les {x} =-\ket{x} $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-140">For all states $\ket{x}$ in the target subspace (i.e., for all states that you'd like the algorithm to output), $P_1\ket{x} = -\ket{x}$.</span></span>
<span data-ttu-id="ce5d8-141">Del mismo modo, para todos los Estados $ \ket{y} $ que no están en el subespacio de destino $P _ 1 \ les {y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-141">Similarly, for all states $\ket{y}$ that are not in the target subspace $P_1\ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="ce5d8-142">A continuación, estas dos reflexiones se combinan para formar un operador que actúe en un único paso de amplificación de amplitud, $Q =-P_0 P_1 $, donde el signo menos global solo es importante tener en cuenta en las aplicaciones controladas.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-142">These two reflections are then combined to form an operator that enacts a single step of amplitude amplification, $Q = -P_0 P_1$, where the overall minus sign is only important to consider in controlled applications.</span></span>
<span data-ttu-id="ce5d8-143">La amplificación de amplitud procede entonces tomando un estado inicial, $ \ket{\psi} $ que se encuentra en el subespacio inicial y, a continuación, realiza $ \ket{\psi} \mapsto Q ^ m \ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-143">Amplitude amplification then proceeds by taking an initial state, $\ket{\psi}$ that is in the initial subspace and then performs $\ket{\psi} \mapsto Q^m \ket{\psi}$.</span></span>
<span data-ttu-id="ce5d8-144">La realización de este tipo de iteración garantiza que, si se inicia con un estado inicial que se superpone a $ \sin ^ 2 (\theta) $ con el espacio marcado, después de $m $ ITERATIONS esta superposición se convierte en $ \sin ^ 2 ([2m + 1] \theta) $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-144">Performing such an iteration guarantees that if one starts with an initial state that has overlap $\sin^2(\theta)$ with the marked space then after $m$ iterations this overlap becomes $\sin^2([2m + 1] \theta)$.</span></span>
<span data-ttu-id="ce5d8-145">Por lo tanto, normalmente queremos elegir $m $ para ser un parámetro gratuito, de modo que $ [2m + 1] \theta = \ pi/2 $; sin embargo, estas opciones rígidas no son tan importantes para algunas formas de amplificación de amplitud, como la amplificación de amplitud de punto fijo.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-145">We therefore typically wish to choose $m$ to be a free parameter such that $[2m+1]\theta = \pi/2$; however, such rigid choices are not as important for some forms of amplitude amplification such as fixed point amplitude amplification.</span></span>
<span data-ttu-id="ce5d8-146">Este proceso nos permite preparar un estado en el subespacio marcado usando de forma cuadrática menos consultas a la función de marcado y la función de preparación de estado que sería posible en un dispositivo estrictamente clásico.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-146">This process allows us to prepare a state in the marked subspace using quadratically fewer queries to the marking function and the state preparation function than would be possible on a strictly classical device.</span></span>
<span data-ttu-id="ce5d8-147">Este es el motivo por el que la amplificación de amplitud es un bloque de creación importante para muchas aplicaciones de la informática Quantum.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-147">This is why amplitude amplification is a significant building block for many applications of quantum computing.</span></span>

<span data-ttu-id="ce5d8-148">Con el fin de comprender cómo usar el algoritmo, es útil proporcionar un ejemplo que proporciona una construcción de Oracle.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-148">In order to understand how to use the algorithm, it is useful to provide an example that gives a construction of the oracles.</span></span>  <span data-ttu-id="ce5d8-149">Considere la posibilidad de realizar búsquedas en el algoritmo de Grover en esta configuración.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-149">Consider performing Grover's algorithm for database searches in this setting.</span></span>
<span data-ttu-id="ce5d8-150">En la búsqueda de Grover, el objetivo es transformar el estado $ \ket{+} ^ {\otimes n} = H ^ {\otimes n} \ket{0}$ en uno de (potencialmente) muchos Estados marcados.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-150">In Grover's search the goal is to transform the state $\ket{+}^{\otimes n} = H^{\otimes n} \ket{0}$ into one of (potentially) many marked states.</span></span>
<span data-ttu-id="ce5d8-151">Para simplificar aún más, veamos el caso en el que el único estado marcado es $ \ket{0}$.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-151">To further simplify, let's just look at the case where the only marked state is $\ket{0}$.</span></span>
<span data-ttu-id="ce5d8-152">Después tenemos un diseño de dos Oracle: uno que solo marca el estado inicial $ \ket{+} ^ {\otimes n} $ con un signo menos y otro que marca el estado marcado $ \ket{0}$ con un signo menos.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-152">Then we have design two oracles: one that only marks the initial state $\ket{+}^{\otimes n}$ with a minus sign and another that marks the marked state $\ket{0}$ with a minus sign.</span></span>
<span data-ttu-id="ce5d8-153">La última puerta se puede implementar mediante la siguiente operación de procesamiento, mediante el uso de las operaciones de flujo de control en Canon:</span><span class="sxs-lookup"><span data-stu-id="ce5d8-153">The latter gate can be implemented using the following process operation, by using the control flow operations in the canon:</span></span>

```qsharp
operation ReflectAboutAllZeros(register : Qubit[]) : Unit 
is Adj + Ctl {

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);

    // Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.
    // This gate will lead to a sign flip if and only if every qubit is
    // $1$, which happens only if each of the qubits were $0$ before step 1.
    Controlled Z(Most(register), Tail(register));

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);
}
```

<span data-ttu-id="ce5d8-154">Este es un caso especial de la operación de <xref:microsoft.quantum.canon.rall1>, que permite rotar por una fase arbitraria en lugar de por el caso de reflexión $ \phi = \pi $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-154">This oracle is then a special case of the <xref:microsoft.quantum.canon.rall1> operation, which allows for rotating by an arbitrary phase instead of the reflection case $\phi = \pi$.</span></span>
<span data-ttu-id="ce5d8-155">En este caso, `RAll1` es similar a la operación de pre\ket{11\cdots1}ción de <xref:microsoft.quantum.intrinsic.r1>, en que gira aproximadamente $ $ en lugar del estado de qubit único $ \ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-155">In this case, `RAll1` is similar to the <xref:microsoft.quantum.intrinsic.r1> prelude operation, in that it rotates about $\ket{11\cdots1}$ instead of the single-qubit state $\ket{1}$.</span></span>

<span data-ttu-id="ce5d8-156">El Oracle que marca el subespacio inicial se puede construir de forma similar.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-156">The oracle that marks the initial subspace can be constructed similarly.</span></span>
<span data-ttu-id="ce5d8-157">En pseudocódigo:</span><span class="sxs-lookup"><span data-stu-id="ce5d8-157">In pseudocode:</span></span>

1. <span data-ttu-id="ce5d8-158">Aplique $H $ Gates a cada qubit.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-158">Apply $H$ gates to every qubit.</span></span>
2. <span data-ttu-id="ce5d8-159">Aplique $X $ Gates a cada qubit.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-159">Apply $X$ gates to every qubit.</span></span>
3. <span data-ttu-id="ce5d8-160">Aplique un $n-$1 controlado $Z $-Gate al $n ^ {\text{TH}} $ qubit.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-160">Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.</span></span>
4. <span data-ttu-id="ce5d8-161">Aplique $X $ Gates a cada qubit.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-161">Apply $X$ gates to every qubit.</span></span>
5. <span data-ttu-id="ce5d8-162">Aplique $H $ Gates a cada qubit.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-162">Apply $H$ gates to every qubit.</span></span>

<span data-ttu-id="ce5d8-163">Esta vez, también se muestra el uso de <xref:microsoft.quantum.canon.applywith> junto con la operación de <xref:microsoft.quantum.canon.rall1> descrita anteriormente:</span><span class="sxs-lookup"><span data-stu-id="ce5d8-163">This time, we also demonstrate using <xref:microsoft.quantum.canon.applywith> together with the <xref:microsoft.quantum.canon.rall1> operation discussed above:</span></span>

```qsharp
operation ReflectAboutInitial(register : Qubit[]) : Unit
is Adj + Ctl {
    ApplyWithCA(ApplyToEach(H, _), ApplyWith(ApplyToEach(X, _), RAll1(_, PI()), _), register);
}
```

<span data-ttu-id="ce5d8-164">A continuación, podemos combinar estos dos Oracle juntos para rotar entre los dos Estados y transformar de forma determinista $ \ket{+} ^ {\otimes n} $ en $ \ket{0}$ mediante un número de capas de puertas de Hadamard que es proporcional a $ \sqrt{2 ^ n} $ (es decir, $m \propto \sqrt{2 ^ n} $) frente a las capas aproximadamente de $2 ^ n $ que serían necesarias para preparar de forma no determinista el estado $ \ket{0}$ mediante la preparación y medición del estado inicial hasta que se observe el resultado $0 $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-164">We can then combine these two oracles together to rotate between the two states and deterministically transform $\ket{+}^{\otimes n}$ to $\ket{0}$ using a number of layers of Hadamard gates that is proportional to $\sqrt{2^n}$ (ie $m\propto \sqrt{2^n}$) versus the roughly $2^n$ layers that would be needed to non-deterministically prepare the $\ket{0}$ state by preparing and measuring the initial state until the outcome $0$ is observed.</span></span>

### <a name="phase-estimation-oracles"></a><span data-ttu-id="ce5d8-165">Estimación de fase de Oracle</span><span class="sxs-lookup"><span data-stu-id="ce5d8-165">Phase Estimation Oracles</span></span> ###

<span data-ttu-id="ce5d8-166">En el caso de la estimación por fases, los Oracle son algo más naturales.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-166">For phase estimation the oracles are somewhat more natural.</span></span>
<span data-ttu-id="ce5d8-167">El objetivo de la estimación de la fase es diseñar una subrutina que sea capaz de realizar el muestreo desde el vectores propios de una matriz de una unitario.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-167">The aim in phase estimation is to design a subroutine that is capable of sampling from the eigenvalues of a unitary matrix.</span></span>
<span data-ttu-id="ce5d8-168">Este método es indispensable en la simulación de Quantum porque, en el caso de muchos problemas físicos en química y ciencia de materias, estos vectores propios proporcionan el esfuerzos de estado de fondo de los sistemas Quantum, que nos proporciona información valiosa sobre los diagramas de fases de materiales y dinámica de reacción para moléculas.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-168">This method is indispensable in quantum simulation because for many physical problems in chemistry and material science these eigenvalues give the ground-state energies of quantum systems which provides us valuable information about the phase diagrams of materials and reaction dynamics for molecules.</span></span>
<span data-ttu-id="ce5d8-169">Cada tipo de estimación de fase necesita una unitario de entrada.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-169">Every flavor of phase estimation needs an input unitary.</span></span>
<span data-ttu-id="ce5d8-170">Esta unitario se describe habitualmente mediante uno de dos tipos de Oracle.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-170">This unitary is customarily described by one of two types of oracles.</span></span>

> [!TIP]
> <span data-ttu-id="ce5d8-171">Los dos tipos de Oracle descritos a continuación se describen en los ejemplos.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-171">Both of the oracle types described below are covered in the samples.</span></span>
> <span data-ttu-id="ce5d8-172">Para obtener más información acerca de las Oracle de consulta continua, consulte el ejemplo de [ **PhaseEstimation** ](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="ce5d8-172">To learn more about continuous query oracles, please see the [**PhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation).</span></span>
> <span data-ttu-id="ce5d8-173">Para obtener más información sobre Oracle de consultas discretas, consulte el [ejemplo de **IsingPhaseEstimation** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="ce5d8-173">To learn more about discrete query oracles, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span></span>

<span data-ttu-id="ce5d8-174">El primer tipo de Oracle, que llamamos una consulta discreta de Oracle y que se representa con el tipo definido por el usuario <xref:microsoft.quantum.oracles.discreteoracle>, simplemente implica una matriz de unitarios.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-174">The first type of oracle, which we call a discrete query oracle and represent with the user-defined type <xref:microsoft.quantum.oracles.discreteoracle>, simply involves a unitary matrix.</span></span>
<span data-ttu-id="ce5d8-175">Si $U $ es la unitario cuyo vectores propios desea calcular, Oracle para $U $ es simplemente un producto para una subrutina que implementa $U $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-175">If $U$ is the unitary whose eigenvalues we wish to estimate then the oracle for $U$ is simply a stand-in for a subroutine that implements $U$.</span></span>
<span data-ttu-id="ce5d8-176">Por ejemplo, podría tomar $U $ para ser el $Q de Oracle $ definido anteriormente para la estimación de amplitud.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-176">For example, one could take $U$ to be the oracle $Q$ defined above for amplitude estimation.</span></span>
<span data-ttu-id="ce5d8-177">La vectores propios de esta matriz se puede usar para calcular la superposición entre los Estados inicial y de destino, $ \sin ^ 2 (\theta) $, lo que significa que, de lo contrario, se necesitarán menos muestras que una.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-177">The eigenvalues of this matrix can be used to estimate the overlap between the initial and target states, $\sin^2(\theta)$, using quadratically fewer samples than one would need otherwise.</span></span>
<span data-ttu-id="ce5d8-178">Esto gana la aplicación de la estimación de fase mediante el Grover Oracle $Q $ como entrada el moniker de la estimación de amplitude.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-178">This earns the application of phase estimation using the Grover oracle $Q$ as input the moniker of amplitude estimation.</span></span>
<span data-ttu-id="ce5d8-179">Otra aplicación común, ampliamente utilizada en la metrología de Quantum, implica la estimación de un ángulo de rotación pequeño.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-179">Another common application, widely used in quantum metrology, involves estimating a small rotation angle.</span></span>
<span data-ttu-id="ce5d8-180">En otras palabras, deseamos calcular $ \theta $ para una puerta de rotación desconocida con el formato $R _z (\theta) $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-180">In other words, we wish to estimate $\theta$ for an unknown rotation gate of the form $R_z(\theta)$.</span></span>
<span data-ttu-id="ce5d8-181">En tales casos, la subrutina con la que interactuamos con el fin de aprender este valor fijo de $ \theta $ para la puerta es $ $ \begin{align} U & = R_z (\theta) \\\\ & = \begin{bmatrix} e ^ {-i \theta/2} & 0 \\\\ 0 & e ^ {i \ Theta/2} \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-181">In such cases, the subroutine that we would interact with in order to learn this fixed value of $\theta$ for the gate is $$ \begin{align} U & = R_z(\theta) \\\\ & = \begin{bmatrix} e^{-i \theta / 2} & 0 \\\\ 0 & e^{i\theta/2} \end{bmatrix}.</span></span>
<span data-ttu-id="ce5d8-182">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="ce5d8-182">\end{align} $$</span></span>

<span data-ttu-id="ce5d8-183">El segundo tipo de Oracle que se usa en la estimación de fase es la consulta continua de Oracle, representada por el tipo de <xref:microsoft.quantum.oracles.continuousoracle>.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-183">The second type of oracle used in phase estimation is the continuous query oracle, represented by the <xref:microsoft.quantum.oracles.continuousoracle> type.</span></span>
<span data-ttu-id="ce5d8-184">Una consulta continua de Oracle para la estimación de fase adopta el formato $U (t) $, donde $t $ es un número real conocido por clase.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-184">A continuous query oracle for phase estimation takes the form $U(t)$ where $t$ is a classically known real number.</span></span>
<span data-ttu-id="ce5d8-185">Si se permite que $U $ sea una unidad fija, la consulta continua Oracle adopta la forma $U (t) = U ^ t $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-185">If we let $U$ be a fixed unitary then the continuous query oracle takes the form $U(t) = U^t$.</span></span>
<span data-ttu-id="ce5d8-186">Esto nos permite consultar matrices como $ \sqrt{U} $, que no se pudieron implementar directamente en el modelo de consulta discreta.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-186">This allows us to query matrices such as $\sqrt{U}$, which could not be implemented directly in the discrete query model.</span></span>

<span data-ttu-id="ce5d8-187">Este tipo de Oracle es valioso cuando no está sondeando una unitario determinada, sino que desea conocer las propiedades del generador de la unitario.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-187">This type of oracle is valuable when you're not probing a particular unitary, but rather wish to learn the properties of the generator of the unitary.</span></span>
<span data-ttu-id="ce5d8-188">Por ejemplo, en la simulación de quantums dinámicas, el objetivo es diseñar circuitos Quantum que se aproximen a $U (t) = e ^ {-i H t} $ para una matriz de Hermitian $H $ y el tiempo de evolución $t $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-188">For example, in dynamical quantum simulation the goal is to devise quantum circuits that closely approximate $U(t)=e^{-i H t}$ for a Hermitian matrix $H$ and evolution time $t$.</span></span>
<span data-ttu-id="ce5d8-189">El vectores propios de $U (t) $ está directamente relacionado con el vectores propios de $H $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-189">The eigenvalues of $U(t)$ are directly related to the eigenvalues of $H$.</span></span>
<span data-ttu-id="ce5d8-190">Para ver esto, considere la posibilidad de una Eigenvector de $H $: $H \ket{E} = E\ket {E} $, es fácil ver a partir de la definición de la serie potencia de la matriz exponencial que $U (t) \ket{E} = E ^ {i\phi} \ les {E} = E ^ {-iEt} \ket{E} $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-190">To see this, consider an eigenvector of $H$: $H \ket{E} = E\ket{E}$ then it is easy to see from the power-series definition of the matrix exponential that $U(t) \ket{E} = e^{i\phi}\ket{E}= e^{-iEt}\ket{E}$.</span></span>
<span data-ttu-id="ce5d8-191">Por lo tanto, la estimación del eigenphase de $U (t) $ proporciona el eigenvalue $E $ suponiendo que Eigenvector $ \ket{E} $ sea una entrada en el algoritmo de estimación de fase.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-191">Thus estimating the eigenphase of $U(t)$ gives the eigenvalue $E$ assuming the eigenvector $\ket{E}$ is input into the phase estimation algorithm.</span></span>
<span data-ttu-id="ce5d8-192">Sin embargo, en este caso, se puede elegir el valor $t $ a discreción del usuario, ya que para cualquier valor suficientemente pequeño de $t $, eigenvalue $E $ se puede invertir de forma exclusiva mediante $E =-\ Phi/t $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-192">However, in this case the value $t$ can be chosen at the user's discretion since for any sufficiently small value of $t$ the eigenvalue $E$ can be uniquely inverted through $E=-\phi/t$.</span></span>
<span data-ttu-id="ce5d8-193">Dado que los métodos de simulación de Quantum proporcionan la capacidad de realizar una evolución fraccionaria, esto concede a los algoritmos de estimación de fase una libertad adicional al consultar la unitario, específicamente mientras que el modelo de consulta discreta solo permite unitaries del formulario $U ^ j $ para aplicarlo a un entero $j $ la consulta continua Oracle nos permite aproximar unitaries del formulario $U ^ t $ para cualquier valor real $t $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-193">Since quantum simulation methods provide the ability to perform a fractional evolution, this grants phase estimation algorithms an additional freedom when querying the unitary, specifically while the discrete query model allows only unitaries of the form $U^j$ to applied for integer $j$ the continuous query oracle allows us to approximate unitaries of the form $U^t$ for any real valued $t$.</span></span>
<span data-ttu-id="ce5d8-194">Esto es importante para compensar todos los últimos onzas de rendimiento de los algoritmos de estimación de fase, ya que nos permite elegir precisamente el experimento que proporcionaría más información sobre $E $; mientras que los métodos basados en consultas discretas deben hacer lo que están en peligro eligiendo el mejor número entero de consultas en el algoritmo.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-194">This is important to squeeze every last ounce of efficiency out of phase estimation algorithms because it allows us to choose precisely the experiment that would provide the most information about $E$; whereas methods based on discrete queries must make do with compromising by choosing the best integer number of queries in the algorithm.</span></span>

<span data-ttu-id="ce5d8-195">Como ejemplo concreto, tenga en cuenta el problema de la estimación del ángulo de rotación de una puerta, pero la frecuencia de procesamiento de un sistema Quantum giratorio.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-195">As a concrete example of this, consider the problem of estimating not the rotation angle of a gate but the procession frequency of a rotating quantum system.</span></span>
<span data-ttu-id="ce5d8-196">La unitario que describe la dinámica de este tipo es $U (t) = R_z (2 \ Omega t) $ para el tiempo de evolución $t $ y la frecuencia desconocida $ \omega $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-196">The unitary that describes such quantum dynamics is $U(t)=R_z(2\omega t)$ for evolution time $t$ and unknown frequency $\omega$.</span></span>
<span data-ttu-id="ce5d8-197">En este contexto, se puede simular $U (t) $ para cualquier $t $ mediante un solo $R _z $ Gate y, como tal, no es necesario restringir solo las consultas discretas a la unitario.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-197">In this context, we can simulate $U(t)$ for any $t$ using a single $R_z$ gate and as such do not need to restrict ourselves to only discrete queries to the unitary.</span></span>
<span data-ttu-id="ce5d8-198">Este modelo continuo también tiene la propiedad cuya frecuencia es mayor que $2 \ PI $ se puede obtener de los procesos de estimación de fase que usan consultas continuas, ya que la información de fase que, de otro modo, se enmascararía mediante las ramas de la función logarítmica. revelarse a partir de los resultados de los experimentos realizados en valores no acordes de $t $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-198">Such a continuous model also has the property that frequencies greater than $2\pi$ can be learned from phase estimation processes that use continuous queries because phase information that would otherwise be masked by the branch-cuts of the logarithm function can be revealed from the results of experiments performed on non-commensurate values of $t$.</span></span>
<span data-ttu-id="ce5d8-199">Por lo tanto, para problemas como estos modelos de consulta continua para la estimación de fase, Oracle no solo es adecuado, sino que también son preferibles al modelo de consulta discreto.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-199">Thus for problems such as this continuous query models for the phase estimation oracle are not only appropriate but are also preferable to the discrete query model.</span></span>
<span data-ttu-id="ce5d8-200">Por esta razón, Q # tiene funcionalidad para ambas formas de consultas y la deja al usuario para decidir si un algoritmo de estimación de fase se ajusta a sus necesidades y el tipo de Oracle que está disponible.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-200">For this reason Q# has functionality for both forms of queries and leave it to the user to decide upon a phase estimation algorithm to fit their needs and the type of oracle that is available.</span></span>

## <a name="dynamical-generator-modeling"></a><span data-ttu-id="ce5d8-201">Modelado dinámico de generadores</span><span class="sxs-lookup"><span data-stu-id="ce5d8-201">Dynamical Generator Modeling</span></span> ##

<span data-ttu-id="ce5d8-202">Los generadores de la evolución temporal describen cómo evolucionan los Estados a lo largo del tiempo.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-202">Generators of time-evolution describe how states evolve through time.</span></span> <span data-ttu-id="ce5d8-203">Por ejemplo, la fórmula Dynamics de un estado Quantum $ \ket{\psi} $ se rige por la ecuación Schrödinger $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)}, \end{align} $ $ con una matriz Hermitian $H $, conocida como Hamiltonian, como generador de disminuir.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-203">For instance, the dynamics of a quantum state $\ket{\psi}$ is governed by the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ with a Hermitian matrix $H$, known as the Hamiltonian, as the generator of motion.</span></span> <span data-ttu-id="ce5d8-204">Dado un estado inicial $ \ket{\psi (0)} $ en el momento $t = $0, la solución formal a esta ecuación en el momento $t $ puede ser, en principio, escribir $ $ \begin{align} \ket{\psi (t)} = U (t) \ket{\psi (0)}, \end{align} $ $ donde la matriz exponencial $U (t) = e ^ {-i H t} $ se conoce como operador de evolución de tiempo unitario.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-204">Given an initial state $\ket{\psi(0)}$ at time $t=0$, the formal solution to this equation at time $t$ may be, in principle, written $$ \begin{align} \ket{\psi(t)} = U(t)\ket{\psi(0)}, \end{align} $$ where the matrix exponential $U(t)=e^{-i H t}$ is known as the unitary time-evolution operator.</span></span> <span data-ttu-id="ce5d8-205">Aunque nos centramos en los generadores de este formulario en lo que se indica a continuación, se resalta que el concepto se aplica de forma más amplia, como la simulación de sistemas de Quantum abiertos, o a ecuaciones diferenciales más abstractas.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-205">Though we focus on generators of this form in the following, we emphasize that the concept applies more broadly, such as to the simulation of open quantum systems, or to more abstract differential equations.</span></span>

<span data-ttu-id="ce5d8-206">Un objetivo principal de la simulación dinámica es implementar el operador de evolución de tiempo en algún Estado de Quantum codificado en qubits de un equipo Quantum.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-206">A primary goal of dynamical simulation is to implement the time-evolution operator on some quantum state encoded in qubits of a quantum computer.</span></span>  <span data-ttu-id="ce5d8-207">En muchos casos, el Hamiltonian se puede dividir en una suma de algunos $d $ más sencillos.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-207">In many cases, the Hamiltonian may be broken into a sum of some $d$ simpler terms</span></span>

<span data-ttu-id="ce5d8-208">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j, \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="ce5d8-208">$$ \begin{align} H & = \sum^{d-1}_{j=0} H_j, \end{align} $$</span></span>

<span data-ttu-id="ce5d8-209">en el caso de que la evolución de la hora por cada término solo sea fácil de implementar en un equipo Quantum.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-209">where time-evolution by each term alone is easy to implement on a quantum computer.</span></span> <span data-ttu-id="ce5d8-210">Por ejemplo, si $H _j $ es un operador Pauli $X _1X_2 $ que actúa sobre los elementos 1 y 2 de la `qubits`de registro qubit, la evolución de la hora por ti en cualquier momento $t $ se puede implementar simplemente mediante una llamada a la operación `Exp([PauliX,PauliX], t, qubits[1..2])`, que tiene `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`de firma.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-210">For instance, if $H_j$ is a Pauli $X_1X_2$ operator acting on the 1st and 2nd elements of the qubit register `qubits`, time-evolution by it for any time $t$ may be implemented simply by calling the operation `Exp([PauliX,PauliX], t, qubits[1..2])`, which has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span> <span data-ttu-id="ce5d8-211">Como se describe más adelante en la simulación de Hamiltonian, una solución consiste en aproximar la evolución del tiempo mediante $H $ con una secuencia de operaciones más sencillas.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-211">As discussed later in Hamiltonian Simulation, one solution then is to approximate time-evolution by $H$ with a sequence of simpler operations</span></span>

<span data-ttu-id="ce5d8-212">$ $ \begin{align} U (t) & = \left (e ^ {-admitir\_0 t/r} e ^ {-admitir\_1 t/r} \cdots e ^ {-admitir\_{d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j \\| H\_j\\| ^ 2 t ^ 2/r), \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="ce5d8-212">$$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j \\|H\_j\\|^2 t^2/r), \end{align} $$</span></span>

<span data-ttu-id="ce5d8-213">donde el entero $r > $0 controla el error de aproximación.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-213">where the integer $r > 0$ controls the approximation error.</span></span>

<span data-ttu-id="ce5d8-214">La biblioteca de modelado de generación dinámica proporciona un marco para codificar sistemáticamente generadores complicados en términos de generadores más sencillos.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-214">The dynamical generator modeling library provides a framework for systematically encoding complicated generators in terms of simpler generators.</span></span> <span data-ttu-id="ce5d8-215">Una descripción de este tipo se puede pasar a, por ejemplo, a la biblioteca de simulación para implementar la evolución del tiempo mediante un algoritmo de simulación de elección, con muchos detalles que se deben tener en cuenta automáticamente.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-215">Such a description may then be passed to, say, the simulation library to implement time-evolution by a simulation algorithm of choice, with many details automatically taken care of.</span></span>

> [!TIP]
> <span data-ttu-id="ce5d8-216">La biblioteca de generadores dinámicos que se describe a continuación se incluye en los ejemplos.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-216">The dynamical generator library described below is covered in the samples.</span></span> <span data-ttu-id="ce5d8-217">Para ver un ejemplo basado en el modelo Ising, consulte el [ejemplo **IsingGenerators** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/generators).</span><span class="sxs-lookup"><span data-stu-id="ce5d8-217">For an example based on the Ising model, please see the [**IsingGenerators** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/generators).</span></span>
> <span data-ttu-id="ce5d8-218">Para ver un ejemplo basado en hidrógeno molecular, consulte los ejemplos de [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) y [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/gui) .</span><span class="sxs-lookup"><span data-stu-id="ce5d8-218">For an example based on molecular Hydrogen, please see the [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) and [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/gui) samples.</span></span>

### <a name="complete-description-of-a-generator"></a><span data-ttu-id="ce5d8-219">Descripción completa de un generador</span><span class="sxs-lookup"><span data-stu-id="ce5d8-219">Complete Description of a Generator</span></span> ###

<span data-ttu-id="ce5d8-220">En el nivel superior, se incluye una descripción completa de un Hamiltonian en el `EvolutionGenerator` tipo definido por el usuario que tiene dos componentes:</span><span class="sxs-lookup"><span data-stu-id="ce5d8-220">At the top level, a complete description of a Hamiltonian is contained in the `EvolutionGenerator` user-defined type which has two components.:</span></span>

```qsharp
newtype EvolutionGenerator = (EvolutionSet, GeneratorSystem);
```

<span data-ttu-id="ce5d8-221">El `GeneratorSystem` tipo definido por el usuario es una descripción clásica de Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-221">The `GeneratorSystem` user-defined type is a classical description of the Hamiltonian.</span></span>

```qsharp
newtype GeneratorSystem = (Int, (Int -> GeneratorIndex));
```

<span data-ttu-id="ce5d8-222">El primer elemento `Int` de la tupla almacena el número de términos $d $ en el Hamiltonian y el segundo elemento `(Int -> GeneratorIndex)` es una función que asigna un índice entero en $\{0, 1,..., d-1\}$ a un `GeneratorIndex` tipo definido por el usuario que identifica de forma única cada término primitivo en el Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-222">The first element `Int` of the tuple stores the number of terms $d$ in the Hamiltonian, and the second element `(Int -> GeneratorIndex)` is a function that maps an integer index in $\{0,1,...,d-1\}$ to a `GeneratorIndex` user-defined type which uniquely identifies each primitive term in the Hamiltonian.</span></span> <span data-ttu-id="ce5d8-223">Tenga en cuenta que al expresar la colección de términos de Hamiltonian como una función en lugar de como una matriz `GeneratorIndex[]`, esto permite realizar un cálculo sobre la marcha de la `GeneratorIndex`, lo que resulta especialmente útil al describir Hamiltonians con un gran número de términos.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-223">Note that by expressing the collection of terms in the Hamiltonian as a function rather than as an array `GeneratorIndex[]`, this allows for on-the-fly computation of the `GeneratorIndex` which is especially useful when describing Hamiltonians with a large number of terms.</span></span>

<span data-ttu-id="ce5d8-224">De forma fundamental, no imponemos una Convención sobre qué términos primitivos identificados por el `GeneratorIndex` son fáciles de simular.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-224">Crucially, we do not impose a convention on what primitive terms identified by the `GeneratorIndex` are easy-to-simulate.</span></span> <span data-ttu-id="ce5d8-225">Por ejemplo, los términos primitivos podrían ser operadores Pauli como se explicó anteriormente, pero también podrían ser Fermionic Annihilation y operadores de creación que se usan habitualmente en la simulación de química Quantum.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-225">For instance, primitive terms could be Pauli operators as discussed above, but they could also be Fermionic annihilation and creation operators commonly used in quantum chemistry simulation.</span></span> <span data-ttu-id="ce5d8-226">Por sí solo, una `GeneratorIndex` no tiene sentido, ya que no describe cómo se puede implementar como un circuito Quantum la evolución del tiempo por el término al que señala.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-226">By itself, a `GeneratorIndex` is meaningless as it does not describe how time-evolution by the term it points to may be implemented as a quantum circuit.</span></span>

<span data-ttu-id="ce5d8-227">Esto se resuelve especificando un `EvolutionSet` tipo definido por el usuario que asigna cualquier `GeneratorIndex`, que se extrae de un conjunto canónico, a un operador unitario, el `EvolutionUnitary`, expresado como un circuito de Quantum.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-227">This is resolved by specifying an `EvolutionSet` user-defined type that maps any `GeneratorIndex`, drawn from some canonical set, to a unitary operator, the `EvolutionUnitary`, expressed as a quantum circuit.</span></span> <span data-ttu-id="ce5d8-228">El `EvolutionSet` define la Convención de cómo se estructura un `GeneratorIndex` y también define el conjunto de posibles `GeneratorIndex`.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-228">The `EvolutionSet` defines the convention of how a `GeneratorIndex` is structured, and also defines the set of possible `GeneratorIndex`.</span></span>

```qsharp
newtype EvolutionSet = (GeneratorIndex -> EvolutionUnitary);
```

### <a name="pauli-operator-generators"></a><span data-ttu-id="ce5d8-229">Generadores de operadores Pauli</span><span class="sxs-lookup"><span data-stu-id="ce5d8-229">Pauli Operator Generators</span></span> ###

<span data-ttu-id="ce5d8-230">Un ejemplo concreto y útil de los generadores son Hamiltonians que son una suma de los operadores de Pauli, cada uno con un coeficiente diferente.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-230">A concrete and useful example of generators are Hamiltonians that are a sum of Pauli operators, each possibly with a different coefficient.</span></span>
<span data-ttu-id="ce5d8-231">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} a_j H_j, \end{align} $ $, donde cada $ \hat H_j $ se extrae del grupo Pauli.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-231">$$ \begin{align} H & = \sum^{d-1}_{j=0} a_j H_j, \end{align} $$ where each $\hat H_j$ is now drawn from the Pauli group.</span></span> <span data-ttu-id="ce5d8-232">Para estos sistemas, se proporciona la `PauliEvolutionSet()` de tipo `EvolutionSet` que define una Convención sobre cómo un elemento del grupo Pauli y un coeficiente puede identificarse mediante un `GeneratorIndex`, que tiene la siguiente firma.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-232">For such systems, we provide the `PauliEvolutionSet()` of type `EvolutionSet` that defines a convention for how an element of the Pauli group and a coefficient may be identified by a `GeneratorIndex`, which has the following signature.</span></span>

```qsharp
newtype GeneratorIndex = ((Int[], Double[]), Int[]);
```

<span data-ttu-id="ce5d8-233">En nuestra codificación, el primer parámetro `Int[]` especifica una cadena Pauli, donde $ \hat I\rightarrow $0, $ \hat X\rightarrow $1, $ \hat Y\rightarrow $2 y $ \hat Z\rightarrow $3.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-233">In our encoding, the first parameter `Int[]` specifies a Pauli string, where $\hat I\rightarrow 0$, $\hat X\rightarrow 1$, $\hat Y\rightarrow 2$, and $\hat Z\rightarrow 3$.</span></span> <span data-ttu-id="ce5d8-234">El segundo parámetro `Double[]` almacena el coeficiente de la cadena Pauli en Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-234">The second parameter `Double[]` stores the coefficient of the Pauli string in the Hamiltonian.</span></span> <span data-ttu-id="ce5d8-235">Tenga en cuenta que solo se usa el primer elemento de esta matriz.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-235">Note that only the first element of this array is used.</span></span> <span data-ttu-id="ce5d8-236">El tercer parámetro `Int[]` indiza el qubits en el que actúa esta cadena Pauli y no debe tener elementos duplicados.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-236">The third parameter `Int[]` indexes the qubits that this Pauli string acts on, and must have no duplicate elements.</span></span> <span data-ttu-id="ce5d8-237">Por lo tanto, Hamiltonian term $0,4 \hat X_0 \hat Y_8 \hat I_2 \hat Z_1 $ se puede representar como</span><span class="sxs-lookup"><span data-stu-id="ce5d8-237">Thus the Hamiltonian term $0.4 \hat X_0 \hat Y_8\hat I_2\hat Z_1$ may be represented as</span></span>

```qsharp
let generatorIndexExample = GeneratorIndex(([1,2,0,3], [0.4]]), [0,8,2,1]);
```

<span data-ttu-id="ce5d8-238">El `PauliEvolutionSet()` es una función que asigna cualquier `GeneratorIndex` de este formulario a un `EvolutionUnitary` con la siguiente firma.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-238">The `PauliEvolutionSet()` is a function that maps any `GeneratorIndex` of this form to an `EvolutionUnitary` with the following signature.</span></span>

```qsharp
newtype EvolutionUnitary = ((Double, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="ce5d8-239">El primer parámetro representa una duración de tiempo, que se multiplicará por el coeficiente del `GeneratorIndex`de la evolución de la unitario.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-239">The first parameter represents a time-duration, that will be multiplied by the coefficient in the `GeneratorIndex`, of unitary evolution.</span></span> <span data-ttu-id="ce5d8-240">El segundo parámetro es el registro qubit en el que actúa la unitario.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-240">The second parameter is the qubit register the unitary acts on.</span></span> 

### <a name="time-dependent-generators"></a><span data-ttu-id="ce5d8-241">Generadores dependientes del tiempo</span><span class="sxs-lookup"><span data-stu-id="ce5d8-241">Time-Dependent Generators</span></span> ###

<span data-ttu-id="ce5d8-242">En muchos casos, también estamos interesados en modelar generadores dependientes del tiempo, como pueden ocurrir en la ecuación Schrödinger $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = \hat H (t) \ket{\psi (t)}, \end{align} $ $, donde el generador $ \hat H (t) $ es ahora dependiente del tiempo.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-242">In many cases, we are also interested in modelling time-dependent generators, as might occur in the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = \hat H(t) \ket{\psi(t)}, \end{align} $$ where the generator $\hat H(t)$ is now time-dependent.</span></span> <span data-ttu-id="ce5d8-243">La extensión de los generadores independientes del tiempo anteriores a este caso es sencilla.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-243">The extension from the time-independent generators above to this case is straightforward.</span></span> <span data-ttu-id="ce5d8-244">En lugar de tener un `GeneratorSystem` fijo que describa el Hamiltonian para todas las horas $t $, tenemos el `GeneratorSystemTimeDependent` tipo definido por el usuario.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-244">Rather than having a fixed `GeneratorSystem` describing the Hamiltonian for all times $t$, we instead have the `GeneratorSystemTimeDependent` user-defined type.</span></span>

```qsharp
newtype GeneratorSystemTimeDependent = (Double -> GeneratorSystem);
```

<span data-ttu-id="ce5d8-245">El primer parámetro es un parámetro de programación continuo $s \en [0, 1] $, y las funciones de este tipo devuelven un `GeneratorSystem` para esa programación.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-245">The first parameter is a continuous schedule parameter $s\in [0,1]$, and functions of this type return a `GeneratorSystem` for that schedule.</span></span> <span data-ttu-id="ce5d8-246">Tenga en cuenta que el parámetro Schedule puede estar relacionado linealmente con el parámetro de hora física, por ejemplo $s = t/T $, durante un tiempo total de simulación $T $.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-246">Note that the schedule parameter may be linearly related to the physical time parameter e.g. $s = t / T$, for some total time of simulation $T$.</span></span> <span data-ttu-id="ce5d8-247">Sin embargo, en general, esto no es necesario.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-247">In general however, this need not be the case.</span></span>

<span data-ttu-id="ce5d8-248">Del mismo modo, una descripción completa de este generador requiere un `EvolutionSet`, por lo que definimos un `EvolutionSchedule` tipo definido por el usuario.</span><span class="sxs-lookup"><span data-stu-id="ce5d8-248">Similarly, a complete description of this generator requires an `EvolutionSet`, and so we define an `EvolutionSchedule` user-defined type.</span></span>

```qsharp
newtype EvolutionSchedule = (EvolutionSet, GeneratorSystemTimeDependent);
```
